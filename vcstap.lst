CCS PCH C Compiler, Version 4.135, 4375               30-Nov-17 10:18

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\vcstap\vcstap.lst

               ROM used: 6566 bytes (10%)
                         Largest free fragment is 58394
               RAM used: 619 (19%) at main() level
                         847 (26%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   031E
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   0350
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   0402
00078:  BTFSS  FA3.7
0007A:  GOTO   0084
0007E:  BTFSC  FA4.7
00080:  GOTO   0000
00084:  BTFSS  FA3.1
00086:  GOTO   0090
0008A:  BTFSC  FA4.1
0008C:  GOTO   0822
00090:  BTFSS  FA3.0
00092:  GOTO   009C
00096:  BTFSC  FA4.0
00098:  GOTO   0670
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVF   04,W
000E0:  MOVFF  06,FE0
000E4:  MOVFF  05,FD8
000E8:  RETFIE 0
*
0FDBC:  GOTO   17BE
.................... #include "vcstap.h" 
.................... #include <18F2680.h> 
.................... //////// Standard Header file for the PIC18F2680 device //////////////// 
.................... #device PIC18F2680 
.................... #list 
....................  
.................... #device ADC=10 
.................... #device *=16 
....................  
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */ 
.................... #build(reset=0xfdbc:0xfdbf) 
.................... #org 0xfdc0,0xffff {} 
....................  
....................  
.................... /* 
.................... 		#define		BLPLP		9			;bootloader placement, pages from end 
.................... 		#define		BLSIZEP		9			;bootloader size [pages], used by bootloader protection	 
.................... */ 
....................  
....................  
.................... /* EEPROM locations */ 
.................... #define PARAM_CRC_ADDRESS 0x00 
.................... #define PARAM_ADDRESS     0x01 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#FUSES INTRC_IO,NOPROTECT,WDT8192, NOIESO, NODEBUG 
.................... #use delay(clock=8000000) 
*
00A94:  MOVLW  02
00A96:  MOVWF  FEA
00A98:  MOVLW  6A
00A9A:  MOVWF  FE9
00A9C:  MOVF   FEF,W
00A9E:  BZ    0ABA
00AA0:  MOVLW  02
00AA2:  MOVWF  01
00AA4:  CLRF   00
00AA6:  DECFSZ 00,F
00AA8:  BRA    0AA6
00AAA:  DECFSZ 01,F
00AAC:  BRA    0AA4
00AAE:  MOVLW  97
00AB0:  MOVWF  00
00AB2:  DECFSZ 00,F
00AB4:  BRA    0AB2
00AB6:  DECFSZ FEF,F
00AB8:  BRA    0AA0
00ABA:  RETURN 0
....................  
.................... /* 
....................  Sensors  WorldData R33 R34 R35 R36 XBee | UART1    | UART2 | SCI_UART                  | STATUS 
....................  on-board Ethernet  DNS DNS DNS DNS DNS  | inverter | world | (onboard XRW2G)           | done 
....................  802.15.4 Ethernet  0   DNS DNS DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  802.15.4 802.15.4  0   0   0   DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  on-board 802.15.4  DNS 0   0   DNS YES  | inverter | world | (onboard XRW2G)           | done 
....................  */ 
....................  
....................  
....................  
.................... #use rs232(UART1,stream=rs232,baud=9600,xmit=PIN_C6,rcv=PIN_C7, errors)	 /* also connected to XPort transmit ... xport receive not connected */ 
*
003BC:  BTFSS  F9E.5
003BE:  BRA    03BC
003C0:  MOVFF  FAB,1F
003C4:  MOVFF  FAE,01
003C8:  BTFSS  1F.1
003CA:  BRA    03D0
003CC:  BCF    FAB.4
003CE:  BSF    FAB.4
003D0:  GOTO   0408 (RETURN)
*
0147E:  BTFSS  F9E.4
01480:  BRA    147E
01482:  MOVWF  FAD
01484:  RETURN 0
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST) 
*
00ABC:  MOVLW  08
00ABE:  MOVWF  01
00AC0:  NOP   
00AC2:  BCF    F8B.3
00AC4:  BCF    F94.3
00AC6:  NOP   
00AC8:  MOVLB  2
00ACA:  RLCF   x75,F
00ACC:  BCF    F8B.4
00ACE:  BTFSC  FD8.0
00AD0:  BSF    F94.4
00AD2:  BTFSS  FD8.0
00AD4:  BCF    F94.4
00AD6:  BSF    F94.3
00AD8:  BTFSS  F82.3
00ADA:  BRA    0AD8
00ADC:  DECFSZ 01,F
00ADE:  BRA    0AE2
00AE0:  BRA    0AE6
00AE2:  MOVLB  0
00AE4:  BRA    0AC0
00AE6:  NOP   
00AE8:  BCF    F8B.3
00AEA:  BCF    F94.3
00AEC:  NOP   
00AEE:  BSF    F94.4
00AF0:  NOP   
00AF2:  NOP   
00AF4:  BSF    F94.3
00AF6:  BTFSS  F82.3
00AF8:  BRA    0AF6
00AFA:  CLRF   01
00AFC:  NOP   
00AFE:  BTFSC  F82.4
00B00:  BSF    01.0
00B02:  BCF    F8B.3
00B04:  BCF    F94.3
00B06:  BCF    F8B.4
00B08:  BCF    F94.4
00B0A:  MOVLB  0
00B0C:  RETURN 0
*
011D6:  MOVLW  08
011D8:  MOVLB  2
011DA:  MOVWF  x6E
011DC:  MOVFF  00,26F
011E0:  BSF    F94.4
011E2:  NOP   
011E4:  BSF    F94.3
011E6:  BTFSS  F82.3
011E8:  BRA    11E6
011EA:  BTFSC  F82.4
011EC:  BSF    FD8.0
011EE:  BTFSS  F82.4
011F0:  BCF    FD8.0
011F2:  RLCF   01,F
011F4:  NOP   
011F6:  BCF    F94.3
011F8:  BCF    F8B.3
011FA:  DECFSZ x6E,F
011FC:  BRA    11E0
011FE:  BSF    F94.4
01200:  NOP   
01202:  BCF    F8B.4
01204:  MOVF   x6F,W
01206:  BTFSS  FD8.2
01208:  BCF    F94.4
0120A:  NOP   
0120C:  BSF    F94.3
0120E:  BTFSS  F82.3
01210:  BRA    120E
01212:  NOP   
01214:  BCF    F8B.3
01216:  BCF    F94.3
01218:  NOP   
0121A:  BCF    F8B.4
0121C:  BCF    F94.4
0121E:  MOVLB  0
01220:  GOTO   128E (RETURN)
....................  
....................  
....................  
....................  
.................... #use standard_io(A) 
.................... #use standard_io(B) 
.................... #use standard_io(C) 
....................  
.................... #define LED_GREEN                  PIN_B4 
.................... // #define LED_RED                    PIN_B5 repurposed as relay 
.................... #define RELAY_RED                  PIN_B5 
....................  
.................... #define XBEE_SLEEP                 PIN_A0 
.................... #define XBEE_NRTS                  PIN_A1 
.................... #define XBEE_NCTS                  PIN_A2 
....................  
.................... #define SYNC_OUT                   PIN_C5 /* really labeled sync in */ 
....................  
.................... #define UART_IRQ                   PIN_B0 
.................... #define UART_RESET                 PIN_B1 
....................  
.................... #define TP14                       PIN_B3 
.................... #define TP15                       PIN_B2 
....................  
....................  
.................... #define TP_RED     PIN_B6 
.................... #define TP_ORANGE  PIN_B7 
....................  
....................  
.................... //#byte ANCON0=GETENV("SFR:ancon0") 
.................... //#byte ANCON1=GETENV("SFR:ancon1") 
....................  
....................  
....................  
.................... #define SERIAL_PREFIX_DEFAULT      'Z' 
.................... #define SERIAL_NUMBER_DEFAULT      6543 
....................  
.................... #define SENSOR_SOURCE_ONBOARD  0 
.................... #define SENSOR_SOURCE_WIRELESS 1 
....................  
....................  
.................... /* can baud rate registers */ 
.................... //#byte BRGCON1=GETENV("SFR:brgcon1") 
.................... //#byte BRGCON2=GETENV("SFR:brgcon2") 
.................... //#byte BRGCON3=GETENV("SFR:brgcon3") 
....................  
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 revision; 
....................  
.................... 	int8 modbus_address; 
....................  
.................... 	int8  serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int8  pair_serial_prefix; 
.................... 	int16 pair_serial_number; 
....................  
.................... 	int8  sensor_source; 
.................... 	int8  world_to_xbee; 
.................... 	int8  world_to_xport; 
.................... } struct_config; 
....................  
.................... #define VCS_N_REGISTERS 40 
....................  
.................... typedef struct { 
.................... 	int8  modbus_enable; 
.................... 	int8  modbus_last_error; 
.................... 	int8  factory_unlocked; 
.................... 	int16 telem_age; 
....................  
.................... 	int8  xrw2g_packet[128]; 
.................... 	int8  xrw2g_buff_pos; 
.................... 	int16 xrw2g_age; 
....................  
.................... 	/* VCS data as updated by the CAN bus */ 
.................... 	int8 vcs_register     [VCS_N_REGISTERS*4]; /* 40 32-bit registers */ 
.................... 	int16 vcs_query_age; 
.................... 	int8 vcs_read_lock; /* 1 means nobody can modify the data */ 
.................... 	int16 vcs_last_data_age; 
....................  
.................... 	int16 led_on_red; 
.................... 	int16 led_on_green; 
....................  
.................... 	int8 dump_register; 
....................  
.................... 	int8 now_telem; 
.................... } struct_timer; 
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_timer  timer; 
....................  
.................... #include "can.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "can.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define CAN_DO_DEBUG                FALSE 
....................  
.................... #define CAN_USE_EXTENDED_ID         FALSE 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH    0  //synchronized jump width (def: 1 x Tq) 
.................... #define CAN_BRG_PRESCALAR           4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #define CAN_BRG_SEG_2_PHASE_TS      TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #define CAN_BRG_SAM                 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #define CAN_BRG_PHASE_SEGMENT_1     5 //phase segment 1 (def: 6 x Tq) 
.................... #define CAN_BRG_PROPAGATION_TIME    2 //propagation time select (def: 3 x Tq) 
.................... #define CAN_BRG_WAKE_FILTER         FALSE   //selects can bus line filter for wake up bit 
.................... #define CAN_BRG_PHASE_SEGMENT_2     5 //phase segment 2 time select (def: 6 x Tq) 
.................... #define CAN_USE_RX_DOUBLE_BUFFER    TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #define CAN_ENABLE_DRIVE_HIGH       1      // required by CTIW CAN / VCSTAP 
.................... #define CAN_ENABLE_CAN_CAPTURE      0 
.................... #define CAN_ENABLE_CANTX2           0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #define CAN_CANTX2_SOURCE           0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
....................  
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
00D4A:  MOVLW  04
00D4C:  MOVLB  2
00D4E:  MOVWF  x74
00D50:  MOVLB  0
00D52:  RCALL  0BE2
....................    can_set_baud(); 
00D54:  BRA    0C08
....................  
....................    RXB0CON=0; 
00D56:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
00D58:  MOVLW  9F
00D5A:  ANDWF  F60,W
00D5C:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
00D5E:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
00D60:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
00D64:  BSF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
00D66:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
00D68:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
00D6A:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
00D6C:  MOVLW  0F
00D6E:  MOVLB  2
00D70:  MOVWF  x83
00D72:  MOVLW  1B
00D74:  MOVWF  x82
00D76:  CLRF   x87
00D78:  CLRF   x86
00D7A:  CLRF   x85
00D7C:  CLRF   x84
00D7E:  CLRF   x88
00D80:  MOVLB  0
00D82:  RCALL  0C16
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
00D84:  MOVLW  0F
00D86:  MOVLB  2
00D88:  MOVWF  x83
00D8A:  MOVLW  03
00D8C:  MOVWF  x82
00D8E:  CLRF   x87
00D90:  CLRF   x86
00D92:  CLRF   x85
00D94:  CLRF   x84
00D96:  CLRF   x88
00D98:  MOVLB  0
00D9A:  RCALL  0C16
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
00D9C:  MOVLW  0F
00D9E:  MOVLB  2
00DA0:  MOVWF  x83
00DA2:  MOVLW  07
00DA4:  MOVWF  x82
00DA6:  CLRF   x87
00DA8:  CLRF   x86
00DAA:  CLRF   x85
00DAC:  CLRF   x84
00DAE:  CLRF   x88
00DB0:  MOVLB  0
00DB2:  RCALL  0C16
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
00DB4:  MOVLW  0F
00DB6:  MOVLB  2
00DB8:  MOVWF  x83
00DBA:  MOVLW  1F
00DBC:  MOVWF  x82
00DBE:  CLRF   x87
00DC0:  CLRF   x86
00DC2:  CLRF   x85
00DC4:  CLRF   x84
00DC6:  CLRF   x88
00DC8:  MOVLB  0
00DCA:  RCALL  0C16
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
00DCC:  MOVLW  0F
00DCE:  MOVLB  2
00DD0:  MOVWF  x83
00DD2:  MOVLW  0B
00DD4:  MOVWF  x82
00DD6:  CLRF   x87
00DD8:  CLRF   x86
00DDA:  CLRF   x85
00DDC:  CLRF   x84
00DDE:  CLRF   x88
00DE0:  MOVLB  0
00DE2:  RCALL  0C16
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
00DE4:  MOVLW  0F
00DE6:  MOVLB  2
00DE8:  MOVWF  x83
00DEA:  MOVWF  x82
00DEC:  CLRF   x87
00DEE:  CLRF   x86
00DF0:  CLRF   x85
00DF2:  CLRF   x84
00DF4:  CLRF   x88
00DF6:  MOVLB  0
00DF8:  RCALL  0C16
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
00DFA:  MOVLW  0F
00DFC:  MOVLB  2
00DFE:  MOVWF  x83
00E00:  MOVLW  13
00E02:  MOVWF  x82
00E04:  CLRF   x87
00E06:  CLRF   x86
00E08:  CLRF   x85
00E0A:  CLRF   x84
00E0C:  CLRF   x88
00E0E:  MOVLB  0
00E10:  RCALL  0C16
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
00E12:  MOVLW  0F
00E14:  MOVLB  2
00E16:  MOVWF  x83
00E18:  MOVLW  17
00E1A:  MOVWF  x82
00E1C:  CLRF   x87
00E1E:  CLRF   x86
00E20:  CLRF   x85
00E22:  CLRF   x84
00E24:  CLRF   x88
00E26:  MOVLB  0
00E28:  RCALL  0C16
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
00E2A:  MOVF   F93,W
00E2C:  ANDLW  FB
00E2E:  IORLW  08
00E30:  MOVLB  2
00E32:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
00E34:  CLRF   x74
00E36:  MOVLB  0
00E38:  RCALL  0BE2
.................... } 
00E3A:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
.................... /* 250 kbps from 8 MHz oscillator */ 
.................... 	BRGCON1=0x00; 
*
00C08:  CLRF   F70
.................... 	BRGCON2=0xB8; 
00C0A:  MOVLW  B8
00C0C:  MOVWF  F71
.................... 	BRGCON3=0x05; 
00C0E:  MOVLW  05
00C10:  MOVWF  F72
.................... #if 0 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
....................    BRGCON2.sam=CAN_BRG_SAM; 
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
.................... #endif 
.................... } 
00C12:  GOTO   0D56 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
00BE2:  MOVLB  2
00BE4:  SWAPF  x74,W
00BE6:  ANDLW  70
00BE8:  MOVWF  00
00BEA:  BCF    FD8.0
00BEC:  RLCF   00,F
00BEE:  MOVLW  1F
00BF0:  ANDWF  F6F,W
00BF2:  IORWF  00,W
00BF4:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
00BF6:  MOVFF  F6E,00
00BFA:  SWAPF  00,F
00BFC:  RRCF   00,W
00BFE:  ANDLW  07
00C00:  SUBWF  x74,W
00C02:  BNZ   0BF6
.................... } 
00C04:  MOVLB  0
00C06:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
00C16:  MOVFF  283,28A
00C1A:  MOVFF  282,289
....................  
....................    if (ext) {  //extended 
00C1E:  MOVLB  2
00C20:  MOVF   x88,F
00C22:  BZ    0CC8
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
00C24:  MOVFF  289,FE9
00C28:  MOVFF  28A,FEA
00C2C:  MOVFF  284,FEF
....................  
....................       //eidh 
....................       ptr--; 
00C30:  MOVF   x89,W
00C32:  BTFSC  FD8.2
00C34:  DECF   x8A,F
00C36:  DECF   x89,F
....................       *ptr=make8(id,1); //8:15 
00C38:  MOVFF  289,FE9
00C3C:  MOVFF  28A,FEA
00C40:  MOVFF  285,FEF
....................  
....................       //sidl 
....................       ptr--; 
00C44:  MOVF   x89,W
00C46:  BTFSC  FD8.2
00C48:  DECF   x8A,F
00C4A:  DECF   x89,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
00C4C:  MOVFF  289,FE9
00C50:  MOVFF  28A,FEA
00C54:  MOVF   x86,W
00C56:  ANDLW  03
00C58:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
00C5A:  MOVFF  289,FE9
00C5E:  MOVFF  28A,FEA
00C62:  MOVFF  286,00
00C66:  RLCF   00,F
00C68:  RLCF   00,F
00C6A:  RLCF   00,F
00C6C:  MOVLW  F8
00C6E:  ANDWF  00,F
00C70:  MOVF   00,W
00C72:  ANDLW  E0
00C74:  IORWF  FEF,W
00C76:  MOVWF  FEF
....................       *ptr|=0x08; 
00C78:  MOVFF  289,FE9
00C7C:  MOVFF  28A,FEA
00C80:  MOVF   FEF,W
00C82:  IORLW  08
00C84:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
00C86:  MOVF   x89,W
00C88:  BTFSC  FD8.2
00C8A:  DECF   x8A,F
00C8C:  DECF   x89,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
00C8E:  MOVFF  289,FE9
00C92:  MOVFF  28A,FEA
00C96:  MOVFF  286,00
00C9A:  SWAPF  00,F
00C9C:  RRCF   00,F
00C9E:  MOVLW  07
00CA0:  ANDWF  00,F
00CA2:  MOVF   00,W
00CA4:  ANDLW  07
00CA6:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
00CA8:  MOVFF  289,FE9
00CAC:  MOVFF  28A,FEA
00CB0:  MOVFF  287,00
00CB4:  RLCF   00,F
00CB6:  RLCF   00,F
00CB8:  RLCF   00,F
00CBA:  MOVLW  F8
00CBC:  ANDWF  00,F
00CBE:  MOVF   00,W
00CC0:  ANDLW  F8
00CC2:  IORWF  FEF,W
00CC4:  MOVWF  FEF
....................    } 
....................    else {   //standard 
00CC6:  BRA    0D46
....................       //eidl 
....................       *ptr=0; 
00CC8:  MOVFF  289,FE9
00CCC:  MOVFF  28A,FEA
00CD0:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
00CD2:  MOVF   x89,W
00CD4:  BTFSC  FD8.2
00CD6:  DECF   x8A,F
00CD8:  DECF   x89,F
....................       *ptr=0; 
00CDA:  MOVFF  289,FE9
00CDE:  MOVFF  28A,FEA
00CE2:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
00CE4:  MOVF   x89,W
00CE6:  BTFSC  FD8.2
00CE8:  DECF   x8A,F
00CEA:  DECF   x89,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
00CEC:  MOVFF  289,FE9
00CF0:  MOVFF  28A,FEA
00CF4:  MOVFF  284,00
00CF8:  SWAPF  00,F
00CFA:  RLCF   00,F
00CFC:  MOVLW  E0
00CFE:  ANDWF  00,F
00D00:  MOVF   00,W
00D02:  ANDLW  E0
00D04:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
00D06:  MOVF   x89,W
00D08:  BTFSC  FD8.2
00D0A:  DECF   x8A,F
00D0C:  DECF   x89,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
00D0E:  MOVFF  289,FE9
00D12:  MOVFF  28A,FEA
00D16:  MOVFF  284,00
00D1A:  RRCF   00,F
00D1C:  RRCF   00,F
00D1E:  RRCF   00,F
00D20:  MOVLW  1F
00D22:  ANDWF  00,F
00D24:  MOVF   00,W
00D26:  ANDLW  1F
00D28:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
00D2A:  MOVFF  289,FE9
00D2E:  MOVFF  28A,FEA
00D32:  MOVFF  285,00
00D36:  SWAPF  00,F
00D38:  RLCF   00,F
00D3A:  MOVLW  E0
00D3C:  ANDWF  00,F
00D3E:  MOVF   00,W
00D40:  ANDLW  E0
00D42:  IORWF  FEF,W
00D44:  MOVWF  FEF
....................    } 
.................... } 
00D46:  MOVLB  0
00D48:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
00478:  MOVLB  3
0047A:  CLRF   x47
0047C:  CLRF   x46
0047E:  CLRF   x45
00480:  CLRF   x44
....................    ptr=addr; 
00482:  MOVFF  342,349
00486:  MOVFF  341,348
....................  
....................    if (ext) { 
0048A:  MOVF   x43,F
0048C:  BTFSC  FD8.2
0048E:  BRA    05B6
....................       ret=*ptr;  //eidl 
00490:  MOVFF  349,03
00494:  MOVFF  348,FE9
00498:  MOVFF  349,FEA
0049C:  MOVFF  FEF,00
004A0:  CLRF   01
004A2:  CLRF   02
004A4:  CLRF   03
004A6:  MOVFF  03,347
004AA:  MOVFF  02,346
004AE:  MOVFF  01,345
004B2:  MOVFF  00,344
....................  
....................       ptr--;     //eidh 
004B6:  MOVF   x48,W
004B8:  BTFSC  FD8.2
004BA:  DECF   x49,F
004BC:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 8); 
004BE:  MOVFF  348,FE9
004C2:  MOVFF  349,FEA
004C6:  MOVF   FEF,W
004C8:  CLRF   x4C
004CA:  CLRF   x4B
004CC:  MOVWF  x4A
004CE:  CLRF   00
004D0:  MOVF   00,W
004D2:  IORWF  x44,F
004D4:  MOVF   x4A,W
004D6:  IORWF  x45,F
004D8:  MOVF   x4B,W
004DA:  IORWF  x46,F
004DC:  MOVF   x4C,W
004DE:  IORWF  x47,F
....................  
....................       ptr--;     //sidl 
004E0:  MOVF   x48,W
004E2:  BTFSC  FD8.2
004E4:  DECF   x49,F
004E6:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
004E8:  MOVFF  348,FE9
004EC:  MOVFF  349,FEA
004F0:  MOVF   FEF,W
004F2:  CLRF   x4D
004F4:  CLRF   x4C
004F6:  CLRF   x4B
004F8:  MOVWF  x4A
004FA:  MOVLW  03
004FC:  ANDWF  x4A,F
004FE:  CLRF   x4B
00500:  CLRF   x4C
00502:  CLRF   x4D
00504:  CLRF   00
00506:  CLRF   01
00508:  MOVF   00,W
0050A:  IORWF  x44,F
0050C:  MOVF   01,W
0050E:  IORWF  x45,F
00510:  MOVF   x4A,W
00512:  IORWF  x46,F
00514:  MOVF   x4B,W
00516:  IORWF  x47,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
00518:  MOVFF  348,FE9
0051C:  MOVFF  349,FEA
00520:  MOVF   FEF,W
00522:  CLRF   x4D
00524:  CLRF   x4C
00526:  CLRF   x4B
00528:  MOVWF  x4A
0052A:  MOVLW  E0
0052C:  ANDWF  x4A,F
0052E:  CLRF   x4B
00530:  CLRF   x4C
00532:  CLRF   x4D
00534:  CLRF   00
00536:  RLCF   x4A,W
00538:  MOVWF  01
0053A:  RLCF   x4B,W
0053C:  MOVWF  02
0053E:  RLCF   x4C,W
00540:  MOVWF  03
00542:  RLCF   01,F
00544:  RLCF   02,F
00546:  RLCF   03,F
00548:  RLCF   01,F
0054A:  RLCF   02,F
0054C:  RLCF   03,F
0054E:  RLCF   01,F
00550:  RLCF   02,F
00552:  RLCF   03,F
00554:  RLCF   01,F
00556:  RLCF   02,F
00558:  RLCF   03,F
0055A:  MOVLW  E0
0055C:  ANDWF  01,F
0055E:  MOVF   00,W
00560:  IORWF  x44,F
00562:  MOVF   01,W
00564:  IORWF  x45,F
00566:  MOVF   02,W
00568:  IORWF  x46,F
0056A:  MOVF   03,W
0056C:  IORWF  x47,F
....................  
....................       ptr--;     //sidh 
0056E:  MOVF   x48,W
00570:  BTFSC  FD8.2
00572:  DECF   x49,F
00574:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 21); 
00576:  MOVFF  348,FE9
0057A:  MOVFF  349,FEA
0057E:  MOVF   FEF,W
00580:  CLRF   x4B
00582:  MOVWF  x4A
00584:  CLRF   00
00586:  CLRF   01
00588:  RLCF   x4A,W
0058A:  MOVWF  02
0058C:  RLCF   x4B,W
0058E:  MOVWF  03
00590:  RLCF   02,F
00592:  RLCF   03,F
00594:  RLCF   02,F
00596:  RLCF   03,F
00598:  RLCF   02,F
0059A:  RLCF   03,F
0059C:  RLCF   02,F
0059E:  RLCF   03,F
005A0:  MOVLW  E0
005A2:  ANDWF  02,F
005A4:  MOVF   00,W
005A6:  IORWF  x44,F
005A8:  MOVF   01,W
005AA:  IORWF  x45,F
005AC:  MOVF   02,W
005AE:  IORWF  x46,F
005B0:  MOVF   03,W
005B2:  IORWF  x47,F
....................  
....................    } 
....................    else { 
005B4:  BRA    065C
....................       ptr-=2;    //sidl 
005B6:  MOVLW  02
005B8:  SUBWF  x48,F
005BA:  MOVLW  00
005BC:  SUBWFB x49,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
005BE:  MOVFF  348,FE9
005C2:  MOVFF  349,FEA
005C6:  MOVF   FEF,W
005C8:  CLRF   x4D
005CA:  CLRF   x4C
005CC:  CLRF   x4B
005CE:  MOVWF  x4A
005D0:  MOVLW  E0
005D2:  ANDWF  x4A,F
005D4:  CLRF   x4B
005D6:  CLRF   x4C
005D8:  CLRF   x4D
005DA:  RRCF   x4D,W
005DC:  MOVWF  x47
005DE:  RRCF   x4C,W
005E0:  MOVWF  x46
005E2:  RRCF   x4B,W
005E4:  MOVWF  x45
005E6:  RRCF   x4A,W
005E8:  MOVWF  x44
005EA:  RRCF   x47,F
005EC:  RRCF   x46,F
005EE:  RRCF   x45,F
005F0:  RRCF   x44,F
005F2:  RRCF   x47,F
005F4:  RRCF   x46,F
005F6:  RRCF   x45,F
005F8:  RRCF   x44,F
005FA:  RRCF   x47,F
005FC:  RRCF   x46,F
005FE:  RRCF   x45,F
00600:  RRCF   x44,F
00602:  RRCF   x47,F
00604:  RRCF   x46,F
00606:  RRCF   x45,F
00608:  RRCF   x44,F
0060A:  MOVLW  07
0060C:  ANDWF  x47,F
....................  
....................       ptr--;     //sidh 
0060E:  MOVF   x48,W
00610:  BTFSC  FD8.2
00612:  DECF   x49,F
00614:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 3); 
00616:  MOVFF  348,FE9
0061A:  MOVFF  349,FEA
0061E:  MOVF   FEF,W
00620:  CLRF   x4D
00622:  CLRF   x4C
00624:  CLRF   x4B
00626:  MOVWF  x4A
00628:  RLCF   x4A,W
0062A:  MOVWF  00
0062C:  RLCF   x4B,W
0062E:  MOVWF  01
00630:  RLCF   x4C,W
00632:  MOVWF  02
00634:  RLCF   x4D,W
00636:  MOVWF  03
00638:  RLCF   00,F
0063A:  RLCF   01,F
0063C:  RLCF   02,F
0063E:  RLCF   03,F
00640:  RLCF   00,F
00642:  RLCF   01,F
00644:  RLCF   02,F
00646:  RLCF   03,F
00648:  MOVLW  F8
0064A:  ANDWF  00,F
0064C:  MOVF   00,W
0064E:  IORWF  x44,F
00650:  MOVF   01,W
00652:  IORWF  x45,F
00654:  MOVF   02,W
00656:  IORWF  x46,F
00658:  MOVF   03,W
0065A:  IORWF  x47,F
....................    } 
....................  
....................    return(ret); 
0065C:  MOVFF  344,00
00660:  MOVFF  345,01
00664:  MOVFF  346,02
00668:  MOVFF  347,03
.................... } 
0066C:  MOVLB  0
0066E:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
012FE:  MOVLW  0F
01300:  MOVLB  2
01302:  MOVWF  x80
01304:  MOVLW  66
01306:  MOVWF  x7F
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
01308:  MOVLB  F
0130A:  BTFSC  x40.3
0130C:  BRA    131E
....................       CANCON.win=CAN_WIN_TX0; 
0130E:  MOVLW  F1
01310:  ANDWF  F6F,W
01312:  IORLW  08
01314:  MOVWF  F6F
....................       port=0; 
01316:  MOVLB  2
01318:  CLRF   x81
....................    } 
....................    else if (!TXB1CON.txreq) { 
0131A:  BRA    1352
0131C:  MOVLB  F
0131E:  BTFSC  x30.3
01320:  BRA    1334
....................       CANCON.win=CAN_WIN_TX1; 
01322:  MOVLW  F1
01324:  ANDWF  F6F,W
01326:  IORLW  06
01328:  MOVWF  F6F
....................       port=1; 
0132A:  MOVLW  01
0132C:  MOVLB  2
0132E:  MOVWF  x81
....................    } 
....................    else if (!TXB2CON.txreq) { 
01330:  BRA    1352
01332:  MOVLB  F
01334:  BTFSC  x20.3
01336:  BRA    134A
....................       CANCON.win=CAN_WIN_TX2; 
01338:  MOVLW  F1
0133A:  ANDWF  F6F,W
0133C:  IORLW  04
0133E:  MOVWF  F6F
....................       port=2; 
01340:  MOVLW  02
01342:  MOVLB  2
01344:  MOVWF  x81
....................    } 
....................    else { 
01346:  BRA    1352
01348:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0134A:  MOVLW  00
0134C:  MOVWF  01
0134E:  BRA    13CA
01350:  MOVLB  2
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
01352:  MOVF   x7B,W
01354:  ANDLW  03
01356:  MOVWF  00
01358:  MOVLW  FC
0135A:  ANDWF  F60,W
0135C:  IORWF  00,W
0135E:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
01360:  MOVLW  0F
01362:  MOVWF  x83
01364:  MOVLW  64
01366:  MOVWF  x82
01368:  MOVFF  277,287
0136C:  MOVFF  276,286
01370:  MOVFF  275,285
01374:  MOVFF  274,284
01378:  MOVFF  27C,288
0137C:  MOVLB  0
0137E:  RCALL  0C16
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
01380:  MOVFF  27A,F65
....................    TXBaDLC.rtr=rtr; 
01384:  BCF    F65.6
01386:  MOVLB  2
01388:  BTFSC  x7D.0
0138A:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
0138C:  CLRF   x7E
0138E:  MOVF   x7A,W
01390:  SUBWF  x7E,W
01392:  BC    13BC
....................       *txd0=*data; 
01394:  MOVFF  278,FE9
01398:  MOVFF  279,FEA
0139C:  MOVFF  FEF,284
013A0:  MOVFF  280,FEA
013A4:  MOVFF  27F,FE9
013A8:  MOVFF  284,FEF
....................       txd0++; 
013AC:  INCF   x7F,F
013AE:  BTFSC  FD8.2
013B0:  INCF   x80,F
....................       data++; 
013B2:  INCF   x78,F
013B4:  BTFSC  FD8.2
013B6:  INCF   x79,F
....................     } 
013B8:  INCF   x7E,F
013BA:  BRA    138E
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
013BC:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
013BE:  MOVLW  F1
013C0:  ANDWF  F6F,W
013C2:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
013C4:  MOVLW  01
013C6:  MOVWF  01
013C8:  MOVLB  F
.................... } 
013CA:  MOVLB  0
013CC:  GOTO   140C (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
0067E:  BTFSS  F60.7
00680:  BRA    06B0
*
00830:  BTFSS  F60.7
00832:  BRA    0862
....................         CANCON.win=CAN_WIN_RX0; 
*
00682:  MOVLW  F1
00684:  ANDWF  F6F,W
00686:  MOVWF  F6F
*
00834:  MOVLW  F1
00836:  ANDWF  F6F,W
00838:  MOVWF  F6F
....................         stat.buffer=0; 
*
00688:  BCF    x34.4
*
0083A:  BCF    x34.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
0068A:  BCF    FA4.0
*
0083C:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
0068C:  BCF    x34.0
0068E:  BTFSC  F74.7
00690:  BSF    x34.0
*
0083E:  BCF    x34.0
00840:  BTFSC  F74.7
00842:  BSF    x34.0
....................         COMSTAT.rx0ovfl=0; 
*
00692:  BCF    F74.7
*
00844:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
00694:  BTFSS  F60.2
00696:  BRA    06AE
*
00846:  BTFSS  F60.2
00848:  BRA    0860
....................          stat.filthit=RXB0CON.filthit0; 
*
00698:  MOVLW  00
0069A:  BTFSC  F60.0
0069C:  MOVLW  01
0069E:  ANDLW  07
006A0:  MOVWF  00
006A2:  BCF    FD8.0
006A4:  RLCF   00,F
006A6:  MOVLW  F1
006A8:  ANDWF  x34,W
006AA:  IORWF  00,W
006AC:  MOVWF  x34
*
0084A:  MOVLW  00
0084C:  BTFSC  F60.0
0084E:  MOVLW  01
00850:  ANDLW  07
00852:  MOVWF  00
00854:  BCF    FD8.0
00856:  RLCF   00,F
00858:  MOVLW  F1
0085A:  ANDWF  x34,W
0085C:  IORWF  00,W
0085E:  MOVWF  x34
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
006AE:  BRA    06F0
006B0:  MOVLB  F
006B2:  BTFSS  x50.7
006B4:  BRA    06E8
*
00860:  BRA    08A2
00862:  MOVLB  F
00864:  BTFSS  x50.7
00866:  BRA    089A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
006B6:  MOVLW  F1
006B8:  ANDWF  F6F,W
006BA:  IORLW  0A
006BC:  MOVWF  F6F
*
00868:  MOVLW  F1
0086A:  ANDWF  F6F,W
0086C:  IORLW  0A
0086E:  MOVWF  F6F
....................         stat.buffer=1; 
*
006BE:  MOVLB  3
006C0:  BSF    x34.4
*
00870:  MOVLB  3
00872:  BSF    x34.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
006C2:  BCF    FA4.1
*
00874:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
006C4:  BCF    x34.0
006C6:  BTFSC  F74.6
006C8:  BSF    x34.0
*
00876:  BCF    x34.0
00878:  BTFSC  F74.6
0087A:  BSF    x34.0
....................         COMSTAT.rx1ovfl=0; 
*
006CA:  BCF    F74.6
*
0087C:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
006CC:  MOVLB  F
006CE:  MOVF   x50,W
006D0:  ANDLW  07
006D2:  ANDLW  07
006D4:  MOVWF  00
006D6:  BCF    FD8.0
006D8:  RLCF   00,F
006DA:  MOVLW  F1
006DC:  MOVLB  3
006DE:  ANDWF  x34,W
006E0:  IORWF  00,W
006E2:  MOVWF  x34
*
0087E:  MOVLB  F
00880:  MOVF   x50,W
00882:  ANDLW  07
00884:  ANDLW  07
00886:  MOVWF  00
00888:  BCF    FD8.0
0088A:  RLCF   00,F
0088C:  MOVLW  F1
0088E:  MOVLB  3
00890:  ANDWF  x34,W
00892:  IORWF  00,W
00894:  MOVWF  x34
....................     } 
....................     else { 
*
006E4:  BRA    06F0
006E6:  MOVLB  F
*
00896:  BRA    08A2
00898:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
006E8:  MOVLW  00
006EA:  MOVWF  01
006EC:  BRA    0786
006EE:  MOVLB  3
*
0089A:  MOVLW  00
0089C:  MOVWF  01
0089E:  BRA    0938
008A0:  MOVLB  3
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
006F0:  MOVF   F65,W
006F2:  ANDLW  0F
006F4:  MOVWF  x33
*
008A2:  MOVF   F65,W
008A4:  ANDLW  0F
008A6:  MOVWF  x33
....................     stat.rtr=RXBaDLC.rtr; 
*
006F6:  BCF    x34.5
006F8:  BTFSC  F65.6
006FA:  BSF    x34.5
*
008A8:  BCF    x34.5
008AA:  BTFSC  F65.6
008AC:  BSF    x34.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
006FC:  BCF    x34.6
006FE:  BTFSC  F62.3
00700:  BSF    x34.6
*
008AE:  BCF    x34.6
008B0:  BTFSC  F62.3
008B2:  BSF    x34.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
00702:  MOVLW  00
00704:  BTFSC  x34.6
00706:  MOVLW  01
00708:  MOVWF  x3A
0070A:  MOVLW  0F
0070C:  MOVWF  x42
0070E:  MOVLW  64
00710:  MOVWF  x41
00712:  MOVFF  33A,343
00716:  MOVLB  0
00718:  RCALL  0478
0071A:  MOVFF  03,332
0071E:  MOVFF  02,331
00722:  MOVFF  01,330
00726:  MOVFF  00,32F
*
008B4:  MOVLW  00
008B6:  BTFSC  x34.6
008B8:  MOVLW  01
008BA:  MOVWF  x3A
008BC:  MOVLW  0F
008BE:  MOVWF  x42
008C0:  MOVLW  64
008C2:  MOVWF  x41
008C4:  MOVFF  33A,343
008C8:  MOVLB  0
008CA:  RCALL  0478
008CC:  MOVFF  03,332
008D0:  MOVFF  02,331
008D4:  MOVFF  01,330
008D8:  MOVFF  00,32F
....................  
....................     ptr = &TXRXBaD0; 
*
0072A:  MOVLW  0F
0072C:  MOVLB  3
0072E:  MOVWF  x39
00730:  MOVLW  66
00732:  MOVWF  x38
*
008DC:  MOVLW  0F
008DE:  MOVLB  3
008E0:  MOVWF  x39
008E2:  MOVLW  66
008E4:  MOVWF  x38
....................     for ( i = 0; i < len; i++ ) { 
*
00734:  CLRF   x37
00736:  MOVF   x33,W
00738:  SUBWF  x37,W
0073A:  BC    0764
*
008E6:  CLRF   x37
008E8:  MOVF   x33,W
008EA:  SUBWF  x37,W
008EC:  BC    0916
....................         *data = *ptr; 
*
0073C:  MOVFF  338,FE9
00740:  MOVFF  339,FEA
00744:  MOVFF  FEF,33C
00748:  MOVFF  336,FEA
0074C:  MOVFF  335,FE9
00750:  MOVFF  33C,FEF
*
008EE:  MOVFF  338,FE9
008F2:  MOVFF  339,FEA
008F6:  MOVFF  FEF,33C
008FA:  MOVFF  336,FEA
008FE:  MOVFF  335,FE9
00902:  MOVFF  33C,FEF
....................         data++; 
*
00754:  INCF   x35,F
00756:  BTFSC  FD8.2
00758:  INCF   x36,F
*
00906:  INCF   x35,F
00908:  BTFSC  FD8.2
0090A:  INCF   x36,F
....................         ptr++; 
*
0075A:  INCF   x38,F
0075C:  BTFSC  FD8.2
0075E:  INCF   x39,F
*
0090C:  INCF   x38,F
0090E:  BTFSC  FD8.2
00910:  INCF   x39,F
....................     } 
*
00760:  INCF   x37,F
00762:  BRA    0736
*
00912:  INCF   x37,F
00914:  BRA    08E8
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
00764:  MOVLW  F1
00766:  ANDWF  F6F,W
00768:  MOVWF  F6F
*
00916:  MOVLW  F1
00918:  ANDWF  F6F,W
0091A:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
0076A:  BCF    x34.7
0076C:  BTFSC  FA4.7
0076E:  BSF    x34.7
*
0091C:  BCF    x34.7
0091E:  BTFSC  FA4.7
00920:  BSF    x34.7
....................     CAN_INT_IRXIF = 0; 
*
00770:  BCF    FA4.7
*
00922:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
00772:  BTFSS  x34.4
00774:  BRA    077E
*
00924:  BTFSS  x34.4
00926:  BRA    0930
....................       RXB1CON.rxful=0; 
*
00776:  MOVLB  F
00778:  BCF    x50.7
*
00928:  MOVLB  F
0092A:  BCF    x50.7
....................     } 
....................     else { 
*
0077A:  BRA    0782
0077C:  MOVLB  3
*
0092C:  BRA    0934
0092E:  MOVLB  3
....................       RXB0CON.rxful=0; 
*
0077E:  BCF    F60.7
00780:  MOVLB  F
*
00930:  BCF    F60.7
00932:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
00782:  MOVLW  01
00784:  MOVWF  01
*
00934:  MOVLW  01
00936:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include "uart_sci16is740.c" 
.................... /* register map for SCI16IS740 */ 
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode 
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode 
.................... #define UART_IER          0x01  // Interrupt Enable Register 
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode 
.................... #define UART_LCR          0x03  // Line Control Register 
.................... #define UART_MCR          0x04  // Modem Control Register 
.................... #define UART_LSR          0x05  // Line status Register 
.................... #define UART_MSR          0x06  // Modem Status Register 
.................... #define UART_SPR          0x07  // ScratchPad Register 
.................... #define UART_TCR          0x06  // Transmission Control Register 
.................... #define UART_TLR          0x07  // Trigger Level Register 
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register 
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register 
.................... #define UART_EFCR         0x0F  // Extra Features Control Register 
....................  
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00 
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01 
....................  
.................... #define UART_EFR          0x02  // Enhanced Function Register 
....................  
.................... #define UART_I2C_WRITE    0x00 
.................... #define UART_I2C_READ     0x01                                                
....................  
.................... /* A0 and A1 at VSS */ 
.................... #define UART_ADDR         0x9A 
....................  
.................... int8 uart_read(int8 regaddr) { 
.................... 	int8 data; 
....................  
.................... 	i2c_start(); 
*
01224:  BSF    F94.4
01226:  NOP   
01228:  BSF    F94.3
0122A:  NOP   
0122C:  BCF    F8B.4
0122E:  BCF    F94.4
01230:  NOP   
01232:  BCF    F8B.3
01234:  BCF    F94.3
.................... 	delay_us(15); 
01236:  MOVLW  09
01238:  MOVWF  00
0123A:  DECFSZ 00,F
0123C:  BRA    123A
0123E:  BRA    1240
.................... 	i2c_write(UART_ADDR); 
01240:  MOVLW  9A
01242:  MOVLB  2
01244:  MOVWF  x75
01246:  MOVLB  0
01248:  RCALL  0ABC
.................... 	i2c_write(regaddr<<3); 
0124A:  MOVLB  2
0124C:  RLCF   x6B,W
0124E:  MOVWF  x6D
01250:  RLCF   x6D,F
01252:  RLCF   x6D,F
01254:  MOVLW  F8
01256:  ANDWF  x6D,F
01258:  MOVFF  26D,275
0125C:  MOVLB  0
0125E:  RCALL  0ABC
.................... 	i2c_start(); 
01260:  BSF    F94.4
01262:  NOP   
01264:  BSF    F94.3
01266:  NOP   
01268:  BTFSS  F82.3
0126A:  BRA    1268
0126C:  BCF    F8B.4
0126E:  BCF    F94.4
01270:  NOP   
01272:  BCF    F8B.3
01274:  BCF    F94.3
.................... 	delay_us(15); 
01276:  MOVLW  09
01278:  MOVWF  00
0127A:  DECFSZ 00,F
0127C:  BRA    127A
0127E:  BRA    1280
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                  
01280:  MOVLW  9B
01282:  MOVLB  2
01284:  MOVWF  x75
01286:  MOVLB  0
01288:  RCALL  0ABC
.................... 	data=i2c_read(0); 
0128A:  CLRF   00
0128C:  BRA    11D6
0128E:  MOVFF  01,26C
.................... 	i2c_stop(); 
01292:  BCF    F94.4
01294:  NOP   
01296:  BSF    F94.3
01298:  BTFSS  F82.3
0129A:  BRA    1298
0129C:  NOP   
0129E:  BRA    12A0
012A0:  NOP   
012A2:  BSF    F94.4
012A4:  NOP   
....................  
.................... 	return data; 
012A6:  MOVLB  2
012A8:  MOVFF  26C,01
.................... } 
012AC:  MOVLB  0
012AE:  RETURN 0
....................  
.................... void uart_write(int8 regaddr, int8 data ) {                                                                   
.................... 	i2c_start(); 
*
00B0E:  BSF    F94.4
00B10:  NOP   
00B12:  BSF    F94.3
00B14:  NOP   
00B16:  BCF    F8B.4
00B18:  BCF    F94.4
00B1A:  NOP   
00B1C:  BCF    F8B.3
00B1E:  BCF    F94.3
.................... 	delay_us(15);                                                  
00B20:  MOVLW  09
00B22:  MOVWF  00
00B24:  DECFSZ 00,F
00B26:  BRA    0B24
00B28:  BRA    0B2A
.................... 	i2c_write(UART_ADDR); // write cycle                        
00B2A:  MOVLW  9A
00B2C:  MOVLB  2
00B2E:  MOVWF  x75
00B30:  MOVLB  0
00B32:  RCALL  0ABC
.................... 	i2c_write(regaddr<< 3);  // write cycle          
00B34:  MOVLB  2
00B36:  RLCF   x72,W
00B38:  MOVWF  x74
00B3A:  RLCF   x74,F
00B3C:  RLCF   x74,F
00B3E:  MOVLW  F8
00B40:  ANDWF  x74,F
00B42:  MOVFF  274,275
00B46:  MOVLB  0
00B48:  RCALL  0ABC
.................... 	i2c_write(data); 
00B4A:  MOVFF  273,275
00B4E:  RCALL  0ABC
.................... 	i2c_stop(); 
00B50:  BCF    F94.4
00B52:  NOP   
00B54:  BSF    F94.3
00B56:  BTFSS  F82.3
00B58:  BRA    0B56
00B5A:  NOP   
00B5C:  BRA    0B5E
00B5E:  NOP   
00B60:  BSF    F94.4
00B62:  NOP   
.................... }  
00B64:  RETURN 0
....................  
.................... void uart_putc(int8 data ) { 
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register 
*
01654:  MOVLB  2
01656:  CLRF   x72
01658:  MOVFF  271,273
0165C:  MOVLB  0
0165E:  CALL   0B0E
.................... } 
01662:  GOTO   17AC (RETURN)
....................  
.................... int1 uart_kbhit(void) { 
.................... 	return (uart_read(UART_LSR) & 0x01); 
*
012B0:  MOVLW  05
012B2:  MOVLB  2
012B4:  MOVWF  x6B
012B6:  MOVLB  0
012B8:  RCALL  1224
012BA:  MOVF   01,W
012BC:  ANDLW  01
012BE:  MOVWF  01
.................... } 
012C0:  RETURN 0
....................  
.................... #inline 
.................... int8 uart_getc() { 
.................... 	return uart_read(UART_RHR); 
*
012CE:  MOVLB  2
012D0:  CLRF   x6B
012D2:  MOVLB  0
012D4:  RCALL  1224
012D6:  MOVF   01,W
.................... } 
....................  
.................... void uart_init(void) { 
.................... 	output_low(UART_RESET); 
*
00B66:  BCF    F93.1
00B68:  BCF    F8A.1
.................... 	delay_ms(10); 
00B6A:  MOVLW  0A
00B6C:  MOVLB  2
00B6E:  MOVWF  x6A
00B70:  MOVLB  0
00B72:  RCALL  0A94
.................... 	output_high(UART_RESET); 
00B74:  BCF    F93.1
00B76:  BSF    F8A.1
.................... 	delay_ms(10); 
00B78:  MOVLW  0A
00B7A:  MOVLB  2
00B7C:  MOVWF  x6A
00B7E:  MOVLB  0
00B80:  RCALL  0A94
....................  
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */ 
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor 
00B82:  MOVLW  03
00B84:  MOVLB  2
00B86:  MOVWF  x72
00B88:  MOVLW  80
00B8A:  MOVWF  x73
00B8C:  MOVLB  0
00B8E:  RCALL  0B0E
.................... 	uart_write(UART_DLL, 12);    // divide clock by 12 for 9600 baud when using 1.8432 crystal 
00B90:  MOVLB  2
00B92:  CLRF   x72
00B94:  MOVLW  0C
00B96:  MOVWF  x73
00B98:  MOVLB  0
00B9A:  RCALL  0B0E
.................... 	uart_write(UART_DLH, 0); 
00B9C:  MOVLW  01
00B9E:  MOVLB  2
00BA0:  MOVWF  x72
00BA2:  CLRF   x73
00BA4:  MOVLB  0
00BA6:  RCALL  0B0E
....................  
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register 
00BA8:  MOVLW  03
00BAA:  MOVLB  2
00BAC:  MOVWF  x72
00BAE:  MOVLW  BF
00BB0:  MOVWF  x73
00BB2:  MOVLB  0
00BB4:  RCALL  0B0E
.................... 	uart_write(UART_EFR, 0x10); // enable enhanced registers 
00BB6:  MOVLW  02
00BB8:  MOVLB  2
00BBA:  MOVWF  x72
00BBC:  MOVLW  10
00BBE:  MOVWF  x73
00BC0:  MOVLB  0
00BC2:  RCALL  0B0E
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity 
00BC4:  MOVLW  03
00BC6:  MOVLB  2
00BC8:  MOVWF  x72
00BCA:  MOVWF  x73
00BCC:  MOVLB  0
00BCE:  RCALL  0B0E
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available 
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode 
00BD0:  MOVLW  02
00BD2:  MOVLB  2
00BD4:  MOVWF  x72
00BD6:  MOVLW  07
00BD8:  MOVWF  x73
00BDA:  MOVLB  0
00BDC:  RCALL  0B0E
.................... } 
00BDE:  GOTO   0E80 (RETURN)
....................  
....................  
.................... #include "live.c" 
.................... int16 crc_chk(int8 *data, int8 length) { 
*
01418:  MOVLB  3
0141A:  SETF   x24
0141C:  SETF   x23
.................... 	int8 j; 
.................... 	int16 reg_crc=0xFFFF; 
....................  
.................... 	while ( length-- ) { 
0141E:  MOVF   x21,W
01420:  DECF   x21,F
01422:  XORLW  00
01424:  BZ    1472
.................... 		reg_crc ^= *data++; 
01426:  MOVFF  320,03
0142A:  MOVF   x1F,W
0142C:  INCF   x1F,F
0142E:  BTFSC  FD8.2
01430:  INCF   x20,F
01432:  MOVWF  FE9
01434:  MOVFF  03,FEA
01438:  MOVF   FEF,W
0143A:  XORWF  x23,F
....................  
.................... 		for ( j=0 ; j<8 ; j++ ) { 
0143C:  CLRF   x22
0143E:  MOVF   x22,W
01440:  SUBLW  07
01442:  BNC   1470
.................... 			if ( reg_crc & 0x01 ) { 
01444:  MOVF   x23,W
01446:  ANDLW  01
01448:  MOVWF  00
0144A:  CLRF   03
0144C:  MOVF   00,W
0144E:  IORWF  03,W
01450:  BZ    1466
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001; 
01452:  BCF    FD8.0
01454:  RRCF   x24,W
01456:  MOVWF  x26
01458:  RRCF   x23,W
0145A:  XORLW  01
0145C:  MOVWF  x23
0145E:  MOVF   x26,W
01460:  XORLW  A0
01462:  MOVWF  x24
.................... 			} else { 
01464:  BRA    146C
.................... 				reg_crc=reg_crc>>1; 
01466:  BCF    FD8.0
01468:  RRCF   x24,F
0146A:  RRCF   x23,F
.................... 			} 
.................... 		}	 
0146C:  INCF   x22,F
0146E:  BRA    143E
.................... 	} 
01470:  BRA    141E
.................... 	 
.................... 	return reg_crc; 
01472:  MOVFF  323,01
01476:  MOVFF  324,02
.................... } 
0147A:  MOVLB  0
0147C:  RETURN 0
....................  
.................... /* send CAN registers in RSTap data format */ 
.................... void live_send_vcs(void) { 
.................... 	static int16 sequenceNumber=0; 
.................... 	int16 lCRC; 
.................... 	int8 i,j; 
.................... 	int8 buff[177]; 
....................  
.................... 	memset(buff,0,sizeof(buff)); 
*
01486:  MOVLW  02
01488:  MOVWF  FEA
0148A:  MOVLW  6E
0148C:  MOVWF  FE9
0148E:  CLRF   00
01490:  CLRF   02
01492:  MOVLW  B1
01494:  MOVWF  01
01496:  RCALL  0E3C
....................  
.................... 	buff[0]='#'; 
01498:  MOVLW  23
0149A:  MOVLB  2
0149C:  MOVWF  x6E
.................... 	buff[1]=config.serial_prefix; 
0149E:  MOVFF  22,26F
.................... 	buff[2]=make8(config.serial_number,1); 
014A2:  MOVFF  24,270
.................... 	buff[3]=make8(config.serial_number,0);  
014A6:  MOVFF  23,271
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */ 
014AA:  SETF   x72
.................... 	buff[5]=18; /* packet type */ 
014AC:  MOVLW  12
014AE:  MOVWF  x73
.................... 	buff[6]=0; 
014B0:  CLRF   x74
.................... 	buff[7]=179; /* 17 bytes header + 160 bytes CAN data + 2 bytes CRC */ 
014B2:  MOVLW  B3
014B4:  MOVWF  x75
....................  
.................... 	buff[8]=make8(sequenceNumber,1); 
014B6:  MOVFF  15F,276
014BA:  MOVLB  2
.................... 	buff[9]=make8(sequenceNumber,0); 
014BC:  MOVFF  15E,277
014C0:  MOVLB  2
....................  
.................... 	/* device info */ 
.................... 	/* WorldData device type identifier (16-bit) .... 1600 for VCSTap */ 
.................... 	buff[10]=make8(1600,1); 
014C2:  MOVLW  06
014C4:  MOVWF  x78
.................... 	buff[11]=make8(1600,0); 
014C6:  MOVLW  40
014C8:  MOVWF  x79
.................... 	/* manufacturers serial number */ 
.................... 	buff[12]=0; 
014CA:  CLRF   x7A
.................... 	buff[13]=config.pair_serial_prefix; 
014CC:  MOVFF  25,27B
.................... 	buff[14]=make8(config.pair_serial_number,1); 
014D0:  MOVFF  27,27C
.................... 	buff[15]=make8(config.pair_serial_number,0); 
014D4:  MOVFF  26,27D
.................... 	/* status of the data read  .... no error */ 
.................... 	buff[16]=0; 
014D8:  CLRF   x7E
....................  
.................... 	/* shut down CAN reception and copy CAN registers over */ 
.................... 	disable_interrupts(INT_CANRX0); 
014DA:  BCF    FA3.0
.................... 	disable_interrupts(INT_CANRX1); 
014DC:  BCF    FA3.1
.................... 	/* do our endian swap one word at a time */ 
.................... 	for ( i=0 ; i<160 ; i+=4 ) { 
014DE:  CLRF   x6C
014E0:  MOVF   x6C,W
014E2:  SUBLW  9F
014E4:  BNC   15B6
.................... 		j=i + 17; 
014E6:  MOVLW  11
014E8:  ADDWF  x6C,W
014EA:  MOVWF  x6D
....................  
.................... 		buff[j+0]=timer.vcs_register[i+1]; 
014EC:  CLRF   03
014EE:  MOVF   x6D,W
014F0:  ADDLW  6E
014F2:  MOVWF  01
014F4:  MOVLW  02
014F6:  ADDWFC 03,F
014F8:  MOVLW  01
014FA:  MOVLB  2
014FC:  ADDWF  x6C,W
014FE:  ADDLW  B3
01500:  MOVWF  FE9
01502:  CLRF   FEA
01504:  BTFSC  FD8.0
01506:  INCF   FEA,F
01508:  MOVFF  FEF,321
0150C:  MOVLB  3
0150E:  MOVFF  03,FEA
01512:  MOVFF  01,FE9
01516:  MOVFF  321,FEF
.................... 		buff[j+1]=timer.vcs_register[i+0]; 
0151A:  MOVLW  01
0151C:  MOVLB  2
0151E:  ADDWF  x6D,W
01520:  CLRF   03
01522:  ADDLW  6E
01524:  MOVWF  01
01526:  MOVLW  02
01528:  ADDWFC 03,F
0152A:  MOVLW  B3
0152C:  MOVLB  2
0152E:  ADDWF  x6C,W
01530:  MOVWF  FE9
01532:  CLRF   FEA
01534:  BTFSC  FD8.0
01536:  INCF   FEA,F
01538:  MOVFF  FEF,321
0153C:  MOVLB  3
0153E:  MOVFF  03,FEA
01542:  MOVFF  01,FE9
01546:  MOVFF  321,FEF
.................... 		buff[j+2]=timer.vcs_register[i+3]; 
0154A:  MOVLW  02
0154C:  MOVLB  2
0154E:  ADDWF  x6D,W
01550:  CLRF   03
01552:  ADDLW  6E
01554:  MOVWF  01
01556:  MOVLW  02
01558:  ADDWFC 03,F
0155A:  MOVLW  03
0155C:  MOVLB  2
0155E:  ADDWF  x6C,W
01560:  ADDLW  B3
01562:  MOVWF  FE9
01564:  CLRF   FEA
01566:  BTFSC  FD8.0
01568:  INCF   FEA,F
0156A:  MOVFF  FEF,321
0156E:  MOVLB  3
01570:  MOVFF  03,FEA
01574:  MOVFF  01,FE9
01578:  MOVFF  321,FEF
.................... 		buff[j+3]=timer.vcs_register[i+2]; 
0157C:  MOVLW  03
0157E:  MOVLB  2
01580:  ADDWF  x6D,W
01582:  CLRF   03
01584:  ADDLW  6E
01586:  MOVWF  01
01588:  MOVLW  02
0158A:  ADDWFC 03,F
0158C:  MOVLW  02
0158E:  MOVLB  2
01590:  ADDWF  x6C,W
01592:  ADDLW  B3
01594:  MOVWF  FE9
01596:  CLRF   FEA
01598:  BTFSC  FD8.0
0159A:  INCF   FEA,F
0159C:  MOVFF  FEF,321
015A0:  MOVLB  3
015A2:  MOVFF  03,FEA
015A6:  MOVFF  01,FE9
015AA:  MOVFF  321,FEF
.................... 	} 
015AE:  MOVLW  04
015B0:  MOVLB  2
015B2:  ADDWF  x6C,F
015B4:  BRA    14E0
....................  
.................... 	/* set fault indicator LED */ 
....................  
.................... 	/* any fault */ 
.................... //	if ( timer.vcs_register[30*4] || timer.vcs_register[30*4+1] || timer.vcs_register[30*4+2] || timer.vcs_register[30*4+3] ) { 
.................... 	/* system state 6 (FAULT) */ 
.................... //	if ( 6==timer.vcs_register[19*4+3] || 6==timer.vcs_register[19*4+2] || 6==timer.vcs_register[19*4+1] || 6==timer.vcs_register[19*4+0] ) { 
.................... 	if (  
.................... 		(0==timer.vcs_register[19*4+3] && 0==timer.vcs_register[19*4+2] && 0==timer.vcs_register[19*4+1] && 6==timer.vcs_register[19*4+0]) 
.................... //		|| timer.vcs_last_data_age>12000 
.................... 	 ) { 
015B6:  MOVLB  1
015B8:  MOVF   x02,F
015BA:  BNZ   15DA
015BC:  MOVF   x01,F
015BE:  BNZ   15DA
015C0:  MOVF   x00,F
015C2:  BNZ   15DA
015C4:  MOVLB  0
015C6:  MOVF   xFF,W
015C8:  SUBLW  06
015CA:  BTFSC  FD8.2
015CC:  BRA    15D2
015CE:  MOVLB  1
015D0:  BRA    15DA
.................... 		output_low(RELAY_RED); 
015D2:  BCF    F93.5
015D4:  BCF    F8A.5
.................... 	} else { 
015D6:  BRA    15E0
015D8:  MOVLB  1
.................... 		output_high(RELAY_RED); 
015DA:  BCF    F93.5
015DC:  BSF    F8A.5
015DE:  MOVLB  0
.................... 	} 
....................  
.................... 	enable_interrupts(INT_CANRX0); 
015E0:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1); 
015E2:  BSF    FA3.1
....................  
.................... 	/* compute CRC on header and result data */ 
.................... 	lCRC=crc_chk(buff+1,sizeof(buff)-1); 
015E4:  MOVLW  02
015E6:  MOVLB  3
015E8:  MOVWF  x20
015EA:  MOVLW  6F
015EC:  MOVWF  x1F
015EE:  MOVLW  B0
015F0:  MOVWF  x21
015F2:  MOVLB  0
015F4:  RCALL  1418
015F6:  MOVFF  02,26B
015FA:  MOVFF  01,26A
....................  
.................... 	/* send buff, qbuff.rResult, CRC */ 
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) { 
015FE:  MOVLB  2
01600:  CLRF   x6C
01602:  MOVF   x6C,W
01604:  SUBLW  B0
01606:  BNC   1628
.................... 		fputc(buff[i],rs232); 
01608:  CLRF   03
0160A:  MOVF   x6C,W
0160C:  ADDLW  6E
0160E:  MOVWF  FE9
01610:  MOVLW  02
01612:  ADDWFC 03,W
01614:  MOVWF  FEA
01616:  MOVFF  FEF,31F
0161A:  MOVLB  3
0161C:  MOVF   x1F,W
0161E:  MOVLB  0
01620:  RCALL  147E
.................... 	}	 
01622:  MOVLB  2
01624:  INCF   x6C,F
01626:  BRA    1602
.................... 	fputc(make8(lCRC,1),rs232); 
01628:  MOVFF  26B,31F
0162C:  MOVLB  3
0162E:  MOVF   x1F,W
01630:  MOVLB  0
01632:  RCALL  147E
.................... 	fputc(make8(lCRC,0),rs232); 
01634:  MOVFF  26A,31F
01638:  MOVLB  3
0163A:  MOVF   x1F,W
0163C:  MOVLB  0
0163E:  RCALL  147E
....................  
.................... 	sequenceNumber++; 
01640:  MOVLB  1
01642:  INCF   x5E,F
01644:  BTFSC  FD8.2
01646:  INCF   x5F,F
....................  
.................... 	output_high(SYNC_OUT); 
01648:  BCF    F94.5
0164A:  BSF    F8B.5
....................  
.................... 	restart_wdt(); 
0164C:  CLRWDT
.................... } 
0164E:  MOVLB  0
01650:  GOTO   1984 (RETURN)
....................  
.................... /*		 
.................... '#'                 0  STX 
.................... UNIT ID PREFIX      1  First character (A-Z) for serial number 
.................... UNIT ID MSB         2  high byte of sending station ID 
.................... UNIT ID LSB         3  low byte of sending station ID 
.................... PACKET LENGTH       4  number of byte for packet including STX through CRC 
.................... PACKET TYPE         5  type of packet we are sending, 27 
.................... SEQUENCE MSB        6 
.................... SEQUENCE LSB        7 
....................  
.................... CRC MSB              high byte of CRC on everything after STX and before CRC 
.................... CRC LSB              low byte of CRC 
.................... */ 
....................  
....................  
.................... int1 live_send_xrw2g() { 
*
01666:  MOVLB  2
01668:  BSF    x6F.0
.................... 	int16 lCRC, rCRC; 
.................... 	int8 i; 
.................... 	int1 valid=1; 
....................  
.................... //	fprintf(rs232,"# (live) xrw2g_packet{=0x%02X, 0x%02X, 0x%02X}\r\n",timer.xrw2g_packet[1],timer.xrw2g_packet[2],timer.xrw2g_packet[3]); 
....................  
....................  
....................  
.................... 	/* if wireless sensors, we might have heard something else and gotten in here. In that case, we 
.................... 	 drop back out and try again*/ 
.................... 	if ( SENSOR_SOURCE_WIRELESS == config.sensor_source ) { 
0166A:  DECFSZ 28,W
0166C:  BRA    16C2
.................... 	    valid=0; 
0166E:  BCF    x6F.0
....................  
.................... 	    /* check packet type */ 
.................... 	    if ( 23==timer.xrw2g_packet[5] && timer.xrw2g_buff_pos>10 ) { 
01670:  MOVF   35,W
01672:  SUBLW  17
01674:  BNZ   16C2
01676:  MOVLB  0
01678:  MOVF   xB0,W
0167A:  SUBLW  0A
0167C:  BTFSS  FD8.0
0167E:  BRA    1684
01680:  MOVLB  2
01682:  BRA    16C2
.................... 			/* is XRW2G packet */ 
.................... 			if ( 0==config.pair_serial_prefix && 0==config.pair_serial_number ) { 
01684:  MOVF   25,F
01686:  BNZ   1698
01688:  MOVF   26,F
0168A:  BNZ   1698
0168C:  MOVF   27,F
0168E:  BNZ   1698
.................... 			    /* valid packet from an XRW2G, and we don't care which one */ 
.................... 			    valid=1; 
01690:  MOVLB  2
01692:  BSF    x6F.0
.................... 			} else if ( timer.xrw2g_packet[1] == config.pair_serial_prefix && make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) == config.pair_serial_number ) { 
01694:  BRA    16C2
01696:  MOVLB  0
01698:  MOVF   25,W
0169A:  SUBWF  31,W
0169C:  BNZ   16C4
0169E:  MOVFF  32,271
016A2:  MOVFF  33,270
016A6:  MOVF   26,W
016A8:  MOVLB  2
016AA:  SUBWF  33,W
016AC:  BTFSC  FD8.2
016AE:  BRA    16B4
016B0:  MOVLB  0
016B2:  BRA    16C4
016B4:  MOVF   27,W
016B6:  SUBWF  x71,W
016B8:  BTFSC  FD8.2
016BA:  BRA    16C0
016BC:  MOVLB  0
016BE:  BRA    16C4
.................... 			    valid=1; 
016C0:  BSF    x6F.0
016C2:  MOVLB  0
.................... 			} 
.................... 	    } 
.................... 	} 
....................  
.................... 	if ( 0 == valid ) { 
016C4:  MOVLB  2
016C6:  BTFSC  x6F.0
016C8:  BRA    16D4
.................... 	    /* clear buffer and we'll try again next time */ 
.................... 	    timer.xrw2g_buff_pos=0; 
016CA:  MOVLB  0
016CC:  CLRF   xB0
.................... 	    return false; 
016CE:  MOVLW  00
016D0:  MOVWF  01
016D2:  BRA    17BA
.................... 	} 
....................  
.................... /*		 
.................... '#'                   0  STX 
.................... UNIT ID PREFIX        1  First character (A-Z) for serial number 
.................... UNIT ID MSB           2  high byte of sending station ID 
.................... UNIT ID LSB           3  low byte of sending station ID 
.................... PACKET LENGTH         4  number of byte for packet including STX through CRC 
.................... PACKET TYPE           5  type of packet we are sending, 23 
.................... SEQUENCE MSB          6 
.................... SEQUENCE LSB          7 
.................... (snip) 
.................... CRC MSB               96 high byte of CRC on everything after STX and before CRC 
.................... CRC LSB               97 low byte of CRC 
.................... 	config.serial_prefix='Z'; 
.................... 	config.serial_number=9876; 
.................... */ 
.................... 	/* check for valid CRC */ 
.................... 	if ( timer.xrw2g_buff_pos>=98 ) { 
016D4:  MOVLB  0
016D6:  MOVF   xB0,W
016D8:  SUBLW  61
016DA:  BC    1714
.................... 		rCRC = make16(timer.xrw2g_packet[96],timer.xrw2g_packet[97]); 
016DC:  MOVFF  90,26D
016E0:  MOVFF  91,26C
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
016E4:  MOVLB  3
016E6:  CLRF   x20
016E8:  MOVLW  31
016EA:  MOVWF  x1F
016EC:  MOVLW  5F
016EE:  MOVWF  x21
016F0:  MOVLB  0
016F2:  RCALL  1418
016F4:  MOVFF  02,26B
016F8:  MOVFF  01,26A
....................  
.................... 		if ( lCRC != rCRC ) { 
016FC:  MOVLB  2
016FE:  MOVF   x6C,W
01700:  SUBWF  x6A,W
01702:  BNZ   170A
01704:  MOVF   x6D,W
01706:  SUBWF  x6B,W
01708:  BZ    1716
.................... 		    /* clear buffer and we'll try again next time */ 
.................... 		    timer.xrw2g_buff_pos=0; 
0170A:  MOVLB  0
0170C:  CLRF   xB0
.................... 		    return false; 
0170E:  MOVLW  00
01710:  MOVWF  01
01712:  BRA    17BA
01714:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
.................... //	fprintf(rs232,"@ (sp=%c) (sn=%lu) (buff_pos=%u) @\r\n",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]),timer.xrw2g_buff_pos); 
.................... 	/* check for default serial number */ 
.................... 	if ( 'Z' == timer.xrw2g_packet[1] && 9876 == make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) && timer.xrw2g_buff_pos>=98 ) { 
01716:  MOVF   31,W
01718:  SUBLW  5A
0171A:  BNZ   176C
0171C:  MOVFF  32,03
01720:  MOVF   33,W
01722:  SUBLW  94
01724:  BNZ   176C
01726:  MOVF   03,W
01728:  SUBLW  26
0172A:  BNZ   176C
0172C:  MOVLB  0
0172E:  MOVF   xB0,W
01730:  SUBLW  61
01732:  BTFSS  FD8.0
01734:  BRA    173A
01736:  MOVLB  2
01738:  BRA    176C
.................... 		/* valid XRW2G packet with default serial number ... now we overwrite with our serial number */ 
.................... 		timer.xrw2g_packet[1]=config.serial_prefix; 
0173A:  MOVFF  22,31
.................... 		timer.xrw2g_packet[2]=make8(config.serial_number,1); 
0173E:  MOVFF  24,32
.................... 		timer.xrw2g_packet[3]=make8(config.serial_number,0); 
01742:  MOVFF  23,33
....................  
.................... 		/* and re-calculate and replace CRC */ 
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
01746:  MOVLB  3
01748:  CLRF   x20
0174A:  MOVLW  31
0174C:  MOVWF  x1F
0174E:  MOVLW  5F
01750:  MOVWF  x21
01752:  MOVLB  0
01754:  RCALL  1418
01756:  MOVFF  02,26B
0175A:  MOVFF  01,26A
.................... 		timer.xrw2g_packet[96]=make8(lCRC,1);		timer.xrw2g_packet[97]=make8(lCRC,0); 
0175E:  MOVFF  26B,90
01762:  MOVLB  2
01764:  MOVFF  26A,91
01768:  MOVLB  0
0176A:  MOVLB  2
.................... 	} 
....................  
....................  
....................  
.................... 	for ( i=0 ; i<98 ; i++ ) { 
0176C:  CLRF   x6E
0176E:  MOVF   x6E,W
01770:  SUBLW  61
01772:  BNC   17B2
.................... 	    if ( config.world_to_xport ) 
01774:  MOVF   2A,F
01776:  BZ    1790
.................... 			fputc(timer.xrw2g_packet[i],rs232); 
01778:  MOVLW  30
0177A:  ADDWF  x6E,W
0177C:  MOVWF  FE9
0177E:  CLRF   FEA
01780:  BTFSC  FD8.0
01782:  INCF   FEA,F
01784:  MOVFF  FEF,270
01788:  MOVF   x70,W
0178A:  MOVLB  0
0178C:  RCALL  147E
0178E:  MOVLB  2
.................... 	    if ( config.world_to_xbee ) 
01790:  MOVF   29,F
01792:  BZ    17AE
.................... 			uart_putc(timer.xrw2g_packet[i]); 
01794:  MOVLW  30
01796:  ADDWF  x6E,W
01798:  MOVWF  FE9
0179A:  CLRF   FEA
0179C:  BTFSC  FD8.0
0179E:  INCF   FEA,F
017A0:  MOVFF  FEF,270
017A4:  MOVFF  270,271
017A8:  MOVLB  0
017AA:  BRA    1654
017AC:  MOVLB  2
.................... 	} 
017AE:  INCF   x6E,F
017B0:  BRA    176E
....................  
.................... 	timer.xrw2g_buff_pos=0; 
017B2:  MOVLB  0
017B4:  CLRF   xB0
.................... 	return true; 
017B6:  MOVLW  01
017B8:  MOVWF  01
.................... } 
017BA:  GOTO   199E (RETURN)
....................  
....................  
.................... #include "modbus_slave_vcstap.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE 88888 
.................... #define MODBUS_INT_RDA2 66666 
....................  
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_INT_SOURCE   MODBUS_INT_RDA    // Select between external interrupt 
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us 
....................  
.................... #inline  
.................... void rcv_off(void) { 
.................... 	disable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
....................  
.................... #byte TXSTA=0xfad // PIC18F24J11 TXSTA for UART1 */ 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #inline 
.................... void wait_for_hw_buffer(void) { 
.................... 	while ( ! TRMT ) 
.................... 		; 
.................... } 
....................  
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while(kbhit(rs232)) { 
.................... 		fgetc(rs232); 
.................... 	}   
.................... 	 
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
....................  
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); 
.................... 	enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0030A:  BCF    FF2.5
.................... 	if (enable) { 
0030C:  MOVLB  3
0030E:  MOVF   x28,F
00310:  BZ    031A
.................... 		set_timer0(0); 
00312:  CLRF   FD7
00314:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00316:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00318:  BSF    FF2.5
.................... 	} 
.................... } 
0031A:  MOVLB  0
0031C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... //#int_timer2 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0031E:  MOVLB  1
00320:  MOVF   x61,W
00322:  SUBLW  02
00324:  BNZ   033A
00326:  MOVF   x62,F
00328:  BNZ   033A
0032A:  MOVF   x63,F
0032C:  BNZ   033A
0032E:  BTFSC  x60.0
00330:  BRA    033A
....................    { 
....................       modbus_rx.len-=2; 
00332:  MOVLW  02
00334:  SUBWF  x65,F
....................       modbus_serial_new=TRUE; 
00336:  BSF    x60.0
....................    } 
....................    else 
00338:  BRA    033C
....................       modbus_serial_new=FALSE; 
0033A:  BCF    x60.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0033C:  SETF   x63
0033E:  SETF   x62
....................    modbus_serial_state=MODBUS_GETADDY; 
00340:  CLRF   x61
....................    modbus_enable_timeout(FALSE); 
00342:  MOVLB  3
00344:  CLRF   x28
00346:  MOVLB  0
00348:  RCALL  030A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0034A:  BCF    FF2.2
0034C:  GOTO   009C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
003D4:  MOVLB  1
003D6:  MOVF   x63,W
003D8:  MOVLB  3
003DA:  XORWF  x28,W
003DC:  MOVWF  x29
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
003DE:  CLRF   03
003E0:  MOVF   x29,W
003E2:  MOVLB  0
003E4:  RCALL  00EA
003E6:  MOVWF  01
003E8:  MOVLB  1
003EA:  MOVF   x62,W
003EC:  XORWF  01,W
003EE:  MOVWF  x63
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
003F0:  CLRF   03
003F2:  MOVLB  3
003F4:  MOVF   x29,W
003F6:  MOVLB  0
003F8:  RCALL  01FA
003FA:  MOVFF  FE8,162
.................... } 
003FE:  GOTO   0460 (RETURN)
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, rs232); 
.................... 	modbus_calc_crc(c); 
.................... 	delay_us(53); 
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
....................    modbus_serial_new=FALSE; 
....................  
....................    RCV_OFF(); 
....................     
....................  
....................  
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    modbus_serial_putc(to); 
....................    modbus_serial_putc(func); 
.................... } 
....................  
.................... void modbus_serial_send_stop() { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
....................    crc_low=modbus_serial_crc.b[0]; 
....................  
....................    modbus_serial_putc(crc_high); 
....................    modbus_serial_putc(crc_low); 
....................  
....................    WAIT_FOR_HW_BUFFER(); 
....................      
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    RCV_ON(); 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
....................       return FALSE; 
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
....................       modbus_rx.len = 1; 
....................    } 
....................    modbus_serial_new=FALSE; 
....................    return TRUE; 
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "interrupt.c" 
.................... #int_timer2 
.................... void isr_1ms(void) { 
.................... 	static int16 telem_count=0; 
.................... 	output_high(TP_RED); 
*
00350:  BCF    F93.6
00352:  BSF    F8A.6
.................... 	 
.................... 	if ( timer.vcs_query_age < 65535 ) 
00354:  MOVLB  1
00356:  INCFSZ x53,W
00358:  BRA    0360
0035A:  INCFSZ x54,W
0035C:  BRA    0360
0035E:  BRA    0366
.................... 		timer.vcs_query_age++; 
00360:  INCF   x53,F
00362:  BTFSC  FD8.2
00364:  INCF   x54,F
....................  
.................... 	if ( timer.vcs_last_data_age < 65535 ) 
00366:  INCFSZ x56,W
00368:  BRA    0370
0036A:  INCFSZ x57,W
0036C:  BRA    0370
0036E:  BRA    0376
.................... 		timer.vcs_last_data_age++; 
00370:  INCF   x56,F
00372:  BTFSC  FD8.2
00374:  INCF   x57,F
....................  
....................  
.................... 	/* data ages */ 
.................... 	if ( timer.xrw2g_age < 65535 ) 
00376:  MOVLB  0
00378:  INCFSZ xB1,W
0037A:  BRA    0382
0037C:  INCFSZ xB2,W
0037E:  BRA    0382
00380:  BRA    0388
.................... 		timer.xrw2g_age++; 
00382:  INCF   xB1,F
00384:  BTFSC  FD8.2
00386:  INCF   xB2,F
....................  
....................  
.................... 	if ( telem_count < 10000 ) { 
00388:  MOVLB  2
0038A:  MOVF   x68,W
0038C:  SUBLW  27
0038E:  BNC   03A0
00390:  BNZ   0398
00392:  MOVF   x67,W
00394:  SUBLW  0F
00396:  BNC   03A0
.................... 		telem_count++; 
00398:  INCF   x67,F
0039A:  BTFSC  FD8.2
0039C:  INCF   x68,F
.................... 	} else { 
0039E:  BRA    03AC
.................... 		timer.now_telem=1; 
003A0:  MOVLW  01
003A2:  MOVLB  1
003A4:  MOVWF  x5D
.................... 		telem_count=0; 
003A6:  MOVLB  2
003A8:  CLRF   x68
003AA:  CLRF   x67
.................... 	} 
....................  
.................... 	output_toggle(LED_GREEN); 
003AC:  BCF    F93.4
003AE:  BTG    F8A.4
....................  
.................... #if 0 
.................... 	/* LED Green */ 
.................... 	if ( 0==timer.led_on_green ) { 
.................... 		output_low(LED_GREEN); 
.................... 	} else { 
.................... 		output_high(LED_GREEN); 
.................... 		timer.led_on_green--; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* LED Red */ 
.................... 	if ( 0==timer.led_on_red ) { 
.................... 		output_low(LED_RED); 
.................... 	} else { 
.................... 		output_high(LED_RED); 
.................... 		timer.led_on_red--; 
.................... 	} 
.................... #endif 
....................  
.................... 	output_low(TP_RED); 
003B0:  BCF    F93.6
003B2:  BCF    F8A.6
.................... } 
....................  
003B4:  BCF    F9E.1
003B6:  MOVLB  0
003B8:  GOTO   009C
.................... #int_rda 
.................... void isr_serial_inverter(void) { 
.................... 	int8 c; 
.................... 	output_high(TP_ORANGE); 
*
00402:  BCF    F93.7
00404:  BSF    F8A.7
....................  
.................... 	c=fgetc(rs232); 
00406:  BRA    03BC
00408:  MOVFF  01,327
....................  
.................... 	if ( timer.modbus_enable )  { 
0040C:  MOVF   2B,F
0040E:  BZ    046A
.................... 		if ( ! modbus_serial_new) { 
00410:  MOVLB  1
00412:  BTFSC  x60.0
00414:  BRA    046C
.................... 			if ( modbus_serial_state == MODBUS_GETADDY) { 
00416:  MOVF   x61,F
00418:  BNZ   042A
.................... 				modbus_serial_crc.d = 0xFFFF; 
0041A:  SETF   x63
0041C:  SETF   x62
.................... 				modbus_rx.address = c; 
0041E:  MOVFF  327,164
.................... 				modbus_serial_state++; 
00422:  INCF   x61,F
.................... 				modbus_rx.len = 0; 
00424:  CLRF   x65
.................... 				modbus_rx.error=0; 
00426:  CLRF   x67
.................... 			} else if ( modbus_serial_state == MODBUS_GETFUNC) { 
00428:  BRA    0458
0042A:  DECFSZ x61,W
0042C:  BRA    0436
.................... 				modbus_rx.func = c; 
0042E:  MOVFF  327,166
.................... 				modbus_serial_state++; 
00432:  INCF   x61,F
.................... 			} else if(modbus_serial_state == MODBUS_GETDATA) { 
00434:  BRA    0458
00436:  MOVF   x61,W
00438:  SUBLW  02
0043A:  BNZ   0458
.................... 				if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0043C:  INCFSZ x65,W
0043E:  BRA    0444
.................... 					modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00440:  MOVLW  FE
00442:  MOVWF  x65
.................... 				} 
.................... 				modbus_rx.data[modbus_rx.len]=c; 
00444:  MOVLW  68
00446:  ADDWF  x65,W
00448:  MOVWF  FE9
0044A:  MOVLW  01
0044C:  MOVWF  FEA
0044E:  BTFSC  FD8.0
00450:  INCF   FEA,F
00452:  MOVFF  327,FEF
.................... 				modbus_rx.len++; 
00456:  INCF   x65,F
.................... 			} 
.................... 	 
.................... 			modbus_calc_crc(c); 
00458:  MOVFF  327,328
0045C:  MOVLB  0
0045E:  BRA    03D4
.................... 			modbus_enable_timeout(TRUE); 
00460:  MOVLW  01
00462:  MOVLB  3
00464:  MOVWF  x28
00466:  MOVLB  0
00468:  RCALL  030A
0046A:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	 
.................... 	output_low(TP_ORANGE); 
0046C:  BCF    F93.7
0046E:  BCF    F8A.7
.................... } 
....................  
....................  
....................  
00470:  BCF    F9E.5
00472:  MOVLB  0
00474:  GOTO   009C
.................... #inline 
.................... void can_receive(void) { 
.................... 	int8 buffer[8]; 
.................... 	int32 rx_id; 
.................... 	int8 rx_len; 
.................... 	struct rx_stat rx; 
....................  
....................  
.................... 	if ( can_getd(rx_id,&buffer,rx_len,rx) ) { 
*
00674:  MOVLW  03
00676:  MOVLB  3
00678:  MOVWF  x36
0067A:  MOVLW  27
0067C:  MOVWF  x35
*
00786:  MOVF   01,F
00788:  BZ    0814
*
00826:  MOVLW  03
00828:  MOVLB  3
0082A:  MOVWF  x36
0082C:  MOVLW  27
0082E:  MOVWF  x35
*
00938:  MOVF   01,F
0093A:  BZ    09C6
.................... 		/* got something! */ 
.................... 		timer.led_on_green=50; 
*
0078A:  MOVLB  1
0078C:  CLRF   x5B
0078E:  MOVLW  32
00790:  MOVWF  x5A
*
0093C:  MOVLB  1
0093E:  CLRF   x5B
00940:  MOVLW  32
00942:  MOVWF  x5A
....................  
.................... 		/* VCS is ID ... ignore everything else */ 
.................... 		if ( 3 != rx_id ) 
*
00792:  MOVLB  3
00794:  MOVF   x2F,W
00796:  SUBLW  03
00798:  BNZ   07A6
0079A:  MOVF   x30,F
0079C:  BNZ   07A6
0079E:  MOVF   x31,F
007A0:  BNZ   07A6
007A2:  MOVF   x32,F
007A4:  BZ    07A8
*
00944:  MOVLB  3
00946:  MOVF   x2F,W
00948:  SUBLW  03
0094A:  BNZ   0958
0094C:  MOVF   x30,F
0094E:  BNZ   0958
00950:  MOVF   x31,F
00952:  BNZ   0958
00954:  MOVF   x32,F
00956:  BZ    095A
.................... 			return; 
*
007A6:  BRA    0816
*
00958:  BRA    09C8
....................  
.................... 		if ( 8 != rx_len ) 
*
007A8:  MOVF   x33,W
007AA:  SUBLW  08
007AC:  BZ    07B0
*
0095A:  MOVF   x33,W
0095C:  SUBLW  08
0095E:  BZ    0962
.................... 			return; 
*
007AE:  BRA    0816
*
00960:  BRA    09C8
....................  
.................... 		/* make sure register number is in range */ 
.................... 		if ( buffer[0] >= VCS_N_REGISTERS )  
*
007B0:  MOVF   x27,W
007B2:  SUBLW  27
007B4:  BC    07B8
*
00962:  MOVF   x27,W
00964:  SUBLW  27
00966:  BC    096A
.................... 			return; 
*
007B6:  BRA    0816
*
00968:  BRA    09C8
....................  
.................... 		timer.dump_register=buffer[0]; 
*
007B8:  MOVFF  327,15C
*
0096A:  MOVFF  327,15C
....................  
.................... 		/* re-use rx_len */ 
.................... 		rx_len = buffer[0]<<2; 
*
007BC:  RLCF   x27,W
007BE:  MOVWF  x33
007C0:  RLCF   x33,F
007C2:  MOVLW  FC
007C4:  ANDWF  x33,F
*
0096E:  RLCF   x27,W
00970:  MOVWF  x33
00972:  RLCF   x33,F
00974:  MOVLW  FC
00976:  ANDWF  x33,F
....................  
.................... 		/* copy CAN data into appropriate register */ 
.................... 		timer.vcs_register[rx_len + 0]=buffer[4]; 
*
007C6:  MOVLW  B3
007C8:  ADDWF  x33,W
007CA:  MOVWF  FE9
007CC:  CLRF   FEA
007CE:  BTFSC  FD8.0
007D0:  INCF   FEA,F
007D2:  MOVFF  32B,FEF
*
00978:  MOVLW  B3
0097A:  ADDWF  x33,W
0097C:  MOVWF  FE9
0097E:  CLRF   FEA
00980:  BTFSC  FD8.0
00982:  INCF   FEA,F
00984:  MOVFF  32B,FEF
.................... 		timer.vcs_register[rx_len + 1]=buffer[5]; 
*
007D6:  MOVLW  01
007D8:  ADDWF  x33,W
007DA:  ADDLW  B3
007DC:  MOVWF  FE9
007DE:  CLRF   FEA
007E0:  BTFSC  FD8.0
007E2:  INCF   FEA,F
007E4:  MOVFF  32C,FEF
*
00988:  MOVLW  01
0098A:  ADDWF  x33,W
0098C:  ADDLW  B3
0098E:  MOVWF  FE9
00990:  CLRF   FEA
00992:  BTFSC  FD8.0
00994:  INCF   FEA,F
00996:  MOVFF  32C,FEF
.................... 		timer.vcs_register[rx_len + 2]=buffer[6]; 
*
007E8:  MOVLW  02
007EA:  ADDWF  x33,W
007EC:  ADDLW  B3
007EE:  MOVWF  FE9
007F0:  CLRF   FEA
007F2:  BTFSC  FD8.0
007F4:  INCF   FEA,F
007F6:  MOVFF  32D,FEF
*
0099A:  MOVLW  02
0099C:  ADDWF  x33,W
0099E:  ADDLW  B3
009A0:  MOVWF  FE9
009A2:  CLRF   FEA
009A4:  BTFSC  FD8.0
009A6:  INCF   FEA,F
009A8:  MOVFF  32D,FEF
.................... 		timer.vcs_register[rx_len + 3]=buffer[7]; 
*
007FA:  MOVLW  03
007FC:  ADDWF  x33,W
007FE:  ADDLW  B3
00800:  MOVWF  FE9
00802:  CLRF   FEA
00804:  BTFSC  FD8.0
00806:  INCF   FEA,F
00808:  MOVFF  32E,FEF
*
009AC:  MOVLW  03
009AE:  ADDWF  x33,W
009B0:  ADDLW  B3
009B2:  MOVWF  FE9
009B4:  CLRF   FEA
009B6:  BTFSC  FD8.0
009B8:  INCF   FEA,F
009BA:  MOVFF  32E,FEF
....................  
.................... 		/* reset last data received timer */ 
.................... 		timer.vcs_last_data_age=0; 
*
0080C:  MOVLB  1
0080E:  CLRF   x57
00810:  CLRF   x56
00812:  MOVLB  F
00814:  MOVLB  3
*
009BE:  MOVLB  1
009C0:  CLRF   x57
009C2:  CLRF   x56
009C4:  MOVLB  F
009C6:  MOVLB  3
.................... 	} 
.................... } 
....................  
....................  
.................... #INT_CANRX0 
.................... void isr_can_rx0(void) { 
.................... 	output_high(TP_ORANGE); 
*
00670:  BCF    F93.7
00672:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
00816:  BCF    F93.7
00818:  BCF    F8A.7
.................... } 
....................  
0081A:  BCF    FA4.0
0081C:  MOVLB  0
0081E:  GOTO   009C
.................... #INT_CANRX1 
.................... void isr_can_rx1(void) { 
.................... 	output_high(TP_ORANGE); 
00822:  BCF    F93.7
00824:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
009C8:  BCF    F93.7
009CA:  BCF    F8A.7
.................... } 
....................  
....................  
009CC:  BCF    FA4.1
009CE:  MOVLB  0
009D0:  GOTO   009C
.................... #INT_CANIRX 
.................... /* CAN packet error lights up RED led for two seconds */ 
.................... void isr_canirx() { 
.................... 	clear_interrupt(INT_CANIRX); 
*
00000:  BCF    FA4.7
.................... //	timer.led_on_red=2000; 
.................... } 
....................  
.................... #include "param.c" 
00002:  BCF    FA4.7
00004:  GOTO   009C
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00F42:  MOVF   x76,W
00F44:  XORWF  x77,W
00F46:  MOVWF  01
*
00F94:  MOVF   x76,W
00F96:  XORWF  x77,W
00F98:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00ED2:  MOVLB  2
00ED4:  CLRF   x73
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00ED6:  MOVFF  272,03
00EDA:  MOVF   x71,W
00EDC:  BTFSC  FD8.2
00EDE:  DECF   x72,F
00EE0:  DECF   x71,F
00EE2:  MOVWF  x74
00EE4:  MOVFF  03,275
00EE8:  MOVF   x74,F
00EEA:  BNZ   0EF0
00EEC:  MOVF   x75,F
00EEE:  BZ    0F54
.................... 		*data = read_eeprom( address++ ); 
00EF0:  MOVFF  270,03
00EF4:  MOVF   x6F,W
00EF6:  MOVWF  FE9
00EF8:  MOVFF  03,FEA
00EFC:  MOVF   x6E,W
00EFE:  MOVWF  03
00F00:  MOVF   x6D,W
00F02:  INCF   x6D,F
00F04:  BTFSC  FD8.2
00F06:  INCF   x6E,F
00F08:  MOVWF  x76
00F0A:  MOVFF  03,277
00F0E:  MOVFF  FF2,278
00F12:  BCF    FF2.7
00F14:  MOVFF  277,FAA
00F18:  MOVFF  276,FA9
00F1C:  BCF    FA6.6
00F1E:  BCF    FA6.7
00F20:  BSF    FA6.0
00F22:  MOVF   FA8,W
00F24:  BTFSC  x78.7
00F26:  BSF    FF2.7
00F28:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00F2A:  MOVFF  270,03
00F2E:  MOVF   x6F,W
00F30:  MOVWF  FE9
00F32:  MOVFF  03,FEA
00F36:  MOVFF  FEF,274
00F3A:  MOVFF  273,276
00F3E:  MOVFF  274,277
*
00F48:  MOVFF  01,273
.................... 		data++; 
00F4C:  INCF   x6F,F
00F4E:  BTFSC  FD8.2
00F50:  INCF   x70,F
.................... 	} 
00F52:  BRA    0ED6
.................... 	return crc; 
00F54:  MOVFF  273,01
.................... } 
00F58:  MOVLB  0
00F5A:  GOTO   10A6 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00F5E:  MOVLB  2
00F60:  CLRF   x74
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00F62:  MOVFF  273,03
00F66:  MOVF   x72,W
00F68:  BTFSC  FD8.2
00F6A:  DECF   x73,F
00F6C:  DECF   x72,F
00F6E:  MOVWF  x75
00F70:  MOVFF  03,276
00F74:  MOVF   x75,F
00F76:  BNZ   0F7C
00F78:  MOVF   x76,F
00F7A:  BZ    0FF8
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00F7C:  MOVFF  271,03
00F80:  MOVF   x70,W
00F82:  MOVWF  FE9
00F84:  MOVFF  03,FEA
00F88:  MOVFF  FEF,275
00F8C:  MOVFF  274,276
00F90:  MOVFF  275,277
*
00F9A:  MOVFF  01,274
.................... 		write_eeprom( address++, *data++ ); 
00F9E:  MOVF   x6F,W
00FA0:  MOVWF  03
00FA2:  MOVF   x6E,W
00FA4:  INCF   x6E,F
00FA6:  BTFSC  FD8.2
00FA8:  INCF   x6F,F
00FAA:  MOVWF  x75
00FAC:  MOVFF  03,276
00FB0:  MOVF   x71,W
00FB2:  MOVWF  03
00FB4:  MOVF   x70,W
00FB6:  INCF   x70,F
00FB8:  BTFSC  FD8.2
00FBA:  INCF   x71,F
00FBC:  MOVWF  FE9
00FBE:  MOVFF  03,FEA
00FC2:  MOVFF  FEF,277
00FC6:  MOVFF  276,FAA
00FCA:  MOVFF  275,FA9
00FCE:  MOVFF  277,FA8
00FD2:  BCF    FA6.6
00FD4:  BCF    FA6.7
00FD6:  BSF    FA6.2
00FD8:  MOVF   FF2,W
00FDA:  MOVWF  00
00FDC:  BCF    FF2.7
00FDE:  MOVLB  F
00FE0:  MOVLW  55
00FE2:  MOVWF  FA7
00FE4:  MOVLW  AA
00FE6:  MOVWF  FA7
00FE8:  BSF    FA6.1
00FEA:  BTFSC  FA6.1
00FEC:  BRA    0FEA
00FEE:  BCF    FA6.2
00FF0:  MOVF   00,W
00FF2:  IORWF  FF2,F
.................... 	} 
00FF4:  MOVLB  2
00FF6:  BRA    0F62
....................  
.................... 	return crc; 
00FF8:  MOVFF  274,01
.................... } 
00FFC:  MOVLB  0
00FFE:  GOTO   1022 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
01002:  MOVLB  2
01004:  CLRF   x6D
01006:  MOVLW  20
01008:  MOVWF  x6C
0100A:  CLRF   x6F
0100C:  MOVLW  01
0100E:  MOVWF  x6E
01010:  MOVFF  26D,271
01014:  MOVFF  26C,270
01018:  CLRF   x73
0101A:  MOVLW  0B
0101C:  MOVWF  x72
0101E:  MOVLB  0
01020:  BRA    0F5E
01022:  MOVFF  01,26B
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
01026:  CLRF   FAA
01028:  CLRF   FA9
0102A:  MOVFF  26B,FA8
0102E:  BCF    FA6.6
01030:  BCF    FA6.7
01032:  BSF    FA6.2
01034:  MOVF   FF2,W
01036:  MOVWF  00
01038:  BCF    FF2.7
0103A:  MOVLB  F
0103C:  MOVLW  55
0103E:  MOVWF  FA7
01040:  MOVLW  AA
01042:  MOVWF  FA7
01044:  BSF    FA6.1
01046:  BTFSC  FA6.1
01048:  BRA    1046
0104A:  BCF    FA6.2
0104C:  MOVF   00,W
0104E:  IORWF  FF2,F
....................  
.................... } 
01050:  MOVLB  0
01052:  GOTO   1084 (RETURN)
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timer.led_on_red=150; 
01056:  MOVLB  1
01058:  CLRF   x59
0105A:  MOVLW  96
0105C:  MOVWF  x58
.................... //	fprintf(world,"# writing default parameters\r\n"); 
....................  
.................... 	config.revision='a'; 
0105E:  MOVLW  61
01060:  MOVWF  20
....................  
.................... 	config.serial_prefix='A'; //SERIAL_PREFIX_DEFAULT; 
01062:  MOVLW  41
01064:  MOVWF  22
.................... 	config.serial_number=5361; //SERIAL_NUMBER_DEFAULT; 
01066:  MOVLW  14
01068:  MOVWF  24
0106A:  MOVLW  F1
0106C:  MOVWF  23
....................  
....................  
.................... 	config.sensor_source=SENSOR_SOURCE_ONBOARD; 
0106E:  CLRF   28
....................  
.................... 	config.world_to_xbee=0; 
01070:  CLRF   29
.................... 	config.world_to_xport=1; 
01072:  MOVLW  01
01074:  MOVWF  2A
....................  
.................... 	config.pair_serial_prefix=0; 
01076:  CLRF   25
.................... 	config.pair_serial_number=0; 
01078:  CLRF   27
0107A:  CLRF   26
....................  
.................... 	config.modbus_address=29; 
0107C:  MOVLW  1D
0107E:  MOVWF  21
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
01080:  MOVLB  0
01082:  BRA    1002
....................  
.................... } 
01084:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
01086:  MOVLB  2
01088:  CLRF   x6C
0108A:  MOVLW  20
0108C:  MOVWF  x6B
0108E:  CLRF   x6E
01090:  MOVLW  01
01092:  MOVWF  x6D
01094:  MOVFF  26C,270
01098:  MOVFF  26B,26F
0109C:  CLRF   x72
0109E:  MOVLW  0B
010A0:  MOVWF  x71
010A2:  MOVLB  0
010A4:  BRA    0ED2
010A6:  MOVFF  01,26A
....................  
.................... //	fprintf(modem,"# read_param_file()\r\n"); 
.................... //	print_param_file(); 
....................  
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) { 
010AA:  MOVFF  FF2,26B
010AE:  BCF    FF2.7
010B0:  CLRF   FAA
010B2:  CLRF   FA9
010B4:  BCF    FA6.6
010B6:  BCF    FA6.7
010B8:  BSF    FA6.0
010BA:  MOVF   FA8,W
010BC:  MOVLB  2
010BE:  BTFSC  x6B.7
010C0:  BSF    FF2.7
010C2:  SUBWF  x6A,W
010C4:  BNZ   10D2
010C6:  MOVF   20,W
010C8:  SUBLW  60
010CA:  BC    10D2
010CC:  MOVF   20,W
010CE:  SUBLW  7A
010D0:  BC    10D8
.................... 		write_default_param_file(); 
010D2:  MOVLB  0
010D4:  RCALL  1056
010D6:  MOVLB  2
.................... 	} 
....................  
.................... } 
010D8:  MOVLB  0
010DA:  GOTO   1810 (RETURN)
....................  
....................  
.................... #include "modbus_handler_vcstap.c" 
.................... #define MAX_DATA_REGISTER   100 
....................  
.................... #define MIN_CONFIG_REGISTER 1000 
.................... #define MAX_CONFIG_REGISTER 1011 
....................  
....................  
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	int16 val; 
.................... 	int8 i; 
....................  
.................... 	/* VCS registers */ 
.................... 	if ( addr >= 3 && addr <= 83 ) { 
.................... 		addr -= 3; 
....................  
.................... 		i=addr % 2; 
.................... 		if ( 1 == i ) 
.................... 			addr -= 1; 
....................  
.................... 		addr = addr >> 1; 
....................  
.................... 		timer.vcs_read_lock=1; 
.................... 		 
....................  
.................... 		return 0; 
.................... 	} 
....................  
.................... 	/* XRW2G data */ 
....................  
.................... 	switch ( addr ) { 
.................... 		 
.................... 		/* data */ 
.................... 		case   0: return 0; /* VCS control register ... always reads as 0 */ 
.................... 		case   1: return timer.vcs_query_age; 
.................... 		case   2: return timer.xrw2g_age; 
....................  
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return config.serial_prefix; 
.................... 		case 1001: return config.serial_number; 
.................... 		case 1002: return 'V'; 
.................... 		case 1003: return 'C'; 
.................... 		case 1004: return 'S'; 
.................... 		case 1005: return  0; 
.................... 		case 1006: return config.modbus_address; 
.................... 		case 1007: return config.sensor_source; 
.................... 		case 1008: return config.pair_serial_prefix; 
.................... 		case 1009: return config.pair_serial_number; 
.................... 		case 1010: return config.world_to_xbee; 
.................... 		case 1011: return config.world_to_xport; 
....................  
.................... 	    
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return 65535; 
.................... 	} 
....................  
.................... } 
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( start <= MAX_DATA_REGISTER && end <= MAX_DATA_REGISTER+1 )  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	/* factory unlock */ 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	/* write eeprom */ 
.................... 	if ( start >= 1998 && end <= 2000+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
.................... 	modbus_serial_putc(register_count*2); 
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
.................... 		l=map_modbus(start_address+i); 
.................... 		modbus_serial_putc(make8(l,1)); 
....................   		modbus_serial_putc(make8(l,0)); 
.................... 	} 
....................  
.................... 	modbus_serial_send_stop(); 
.................... } 
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( timer.factory_unlocked ) { 
.................... 		if ( 1000 == address ) { 
.................... 			config.serial_prefix=value; 
.................... 			return 0; 
.................... 		} else if ( 1001 == address ) { 
.................... 			config.serial_number=value; 
.................... 			return 0; 
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.modbus_address=value; 
.................... 			break; 
....................                 case 1007: 
....................                         if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
....................                         config.sensor_source=value; 
....................                         break; 
....................                 case 1008: 
....................                         if ( value > 255 ) return ILLEGAL_DATA_VALUE; 
....................                         config.pair_serial_prefix=value; 
....................                         break; 
....................                 case 1009: 
....................                         config.pair_serial_number=value; 
....................                         break; 
.................... 		case 1010: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xbee=value; 
.................... 			break; 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xport=value; 
.................... 			break; 
.................... 		case 1997: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			reset_cpu(); 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_default_param_file(); 
.................... 			break; 
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_param_file(); 
.................... 			break; 
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
.................... 				timer.factory_unlocked=0; 
.................... 				return ILLEGAL_DATA_VALUE; 
.................... 			} 
.................... 			timer.factory_unlocked=1; 
.................... 			/* green LED for 2 seconds */ 
.................... 			timer.led_on_green=200; 
.................... 			timer.led_on_red=0; 
.................... 			break; 
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
.................... 		/* check if it is addressed to us */ 
.................... 		if ( modbus_rx.address==config.modbus_address ) {	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=0; 
....................  
.................... 			switch(modbus_rx.func) { 
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
.................... 						timer.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					} else { 
.................... 						modbus_read_register_response(config.modbus_address,start_addr,num_registers); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
....................  
.................... 					if ( result ) { 
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 						timer.modbus_last_error=result; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					}  else { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(config.modbus_address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
....................  
.................... 						if ( result ) { 
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 							timer.modbus_last_error=result; 
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timer.led_on_red=100; 
.................... 							timer.led_on_green=0; 
.................... 			 
.................... 							break; 
.................... 						} 
.................... 					} 
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers); 
.................... 					} 
....................  
.................... 					break;   
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION); 
.................... 					timer.modbus_last_error=ILLEGAL_FUNCTION; 
....................  
.................... 					/* red led for 1 second */ 
.................... 					timer.led_on_red=100; 
.................... 					timer.led_on_green=0; 
.................... 			} 
.................... 		} else { 
.................... 			/* MODBUS packet for somebody else */ 
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=20; 
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void init() { 
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
00E56:  MOVLW  72
00E58:  MOVWF  FD3
00E5A:  MOVF   FD3,W
.................... 	restart_wdt(); 
00E5C:  CLRWDT
.................... 	setup_wdt(WDT_ON); 
00E5E:  BSF    FD1.0
.................... 	setup_adc(ADC_OFF); 
00E60:  BCF    FC2.0
.................... 	/*  
.................... 	setup_adc_ports(NO_ANALOGS); doesn't seem to work.  
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital 
.................... 	*/ 
.................... //	ANCON0=0xff; 
.................... //	ANCON1=0x1f; 
.................... 	 
.................... 	 
.................... //	setup_comparator(NC_NC_NC_NC); 
....................  
.................... 	setup_timer_2(T2_DIV_BY_16,61,2); // set 1 millisecond period with 8 MHz oscillator 
00E62:  MOVLW  08
00E64:  IORLW  06
00E66:  MOVWF  FCA
00E68:  MOVLW  3D
00E6A:  MOVWF  FCB
....................  
.................... 	port_b_pullups(TRUE); 
00E6C:  BCF    FF1.7
.................... 	delay_ms(10); 
00E6E:  MOVLW  0A
00E70:  MOVLB  2
00E72:  MOVWF  x6A
00E74:  MOVLB  0
00E76:  RCALL  0A94
.................... 	 
.................... 	output_low(SYNC_OUT); 
00E78:  BCF    F94.5
00E7A:  BCF    F8B.5
....................  
....................  
.................... 	timer.modbus_enable=FALSE; 
00E7C:  CLRF   2B
....................  
....................  
.................... 	/* xrw2g uart */ 
.................... 	uart_init(); 
00E7E:  BRA    0B66
....................  
.................... 	/* CAN interface to VCS */ 
.................... 	can_init(); 
00E80:  RCALL  0D4A
....................  
.................... 	/* receive and receiver error interrupts */ 
.................... 	enable_interrupts(INT_CANRX0);  
00E82:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1);  
00E84:  BSF    FA3.1
.................... 	enable_interrupts(INT_CANIRX); 
00E86:  BSF    FA3.7
....................  
....................  
....................  
.................... 	/* global structures */ 
.................... 	timer.factory_unlocked=0; 
00E88:  CLRF   2D
.................... 	timer.telem_age=0; 
00E8A:  CLRF   2F
00E8C:  CLRF   2E
....................  
.................... 	timer.xrw2g_age=65535; 
00E8E:  SETF   xB2
00E90:  SETF   xB1
.................... 	timer.xrw2g_buff_pos=0; 
00E92:  CLRF   xB0
.................... 	memset(timer.xrw2g_packet, 0, sizeof(timer.xrw2g_packet)); 
00E94:  CLRF   FEA
00E96:  MOVLW  30
00E98:  MOVWF  FE9
00E9A:  CLRF   00
00E9C:  CLRF   02
00E9E:  MOVLW  80
00EA0:  MOVWF  01
00EA2:  RCALL  0E3C
....................  
.................... 	timer.vcs_read_lock=0; 
00EA4:  MOVLB  1
00EA6:  CLRF   x55
.................... 	timer.vcs_query_age=0; 
00EA8:  CLRF   x54
00EAA:  CLRF   x53
.................... 	timer.vcs_last_data_age=65535; 
00EAC:  SETF   x57
00EAE:  SETF   x56
.................... 	memset(timer.vcs_register, 0, sizeof(timer.vcs_register)); 
00EB0:  CLRF   FEA
00EB2:  MOVLW  B3
00EB4:  MOVWF  FE9
00EB6:  CLRF   00
00EB8:  CLRF   02
00EBA:  MOVLW  A0
00EBC:  MOVWF  01
00EBE:  MOVLB  0
00EC0:  RCALL  0E3C
....................  
.................... 	timer.dump_register=255;  
00EC2:  MOVLB  1
00EC4:  SETF   x5C
.................... 	timer.now_telem=0; 
00EC6:  CLRF   x5D
....................  
.................... 	/* receive data from serial ports */ 
.................... 	enable_interrupts(INT_RDA);  /* inverter */ 
00EC8:  BSF    F9D.5
.................... //	enable_interrupts(INT_RDA2); /* world (ethernet or xbee */ 
....................  
.................... 	/* timer0 is used for modbus handler */ 
....................  
.................... 	/* 1 millisecond timer */ 
.................... 	enable_interrupts(INT_TIMER2); 
00ECA:  BSF    F9D.1
....................  
....................  
.................... } 
00ECC:  MOVLB  0
00ECE:  GOTO   180E (RETURN)
....................  
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... void read_data_xrw2g(void) { 
.................... 	int8 c; 
....................  
.................... 	if ( uart_kbhit() ) { 
*
012C2:  RCALL  12B0
012C4:  MOVF   01,F
012C6:  BZ    12FA
.................... 		while ( uart_kbhit() ) { 
012C8:  RCALL  12B0
012CA:  MOVF   01,F
012CC:  BZ    12FA
.................... //			output_high(TP_ORANGE); 
.................... 			c=uart_getc(); 
*
012D8:  MOVFF  01,26A
.................... //			output_low(TP_ORANGE); 
.................... 			timer.xrw2g_age=0; 
012DC:  CLRF   xB2
012DE:  CLRF   xB1
....................  
.................... 			if ( timer.xrw2g_buff_pos < sizeof(timer.xrw2g_packet) ) { 
012E0:  MOVF   xB0,W
012E2:  SUBLW  7F
012E4:  BNC   12F8
.................... 				timer.xrw2g_packet[timer.xrw2g_buff_pos++]=c; 
012E6:  MOVF   xB0,W
012E8:  INCF   xB0,F
012EA:  ADDLW  30
012EC:  MOVWF  FE9
012EE:  CLRF   FEA
012F0:  BTFSC  FD8.0
012F2:  INCF   FEA,F
012F4:  MOVFF  26A,FEF
.................... 			} 
.................... 		} 
012F8:  BRA    12C8
.................... 	} 
.................... } 
012FA:  GOTO   193C (RETURN)
....................  
....................  
.................... void send_can_query(int8 queryRegister) { 
.................... 	unsigned int32 can_id; 
.................... 	unsigned int8 data[4]; 
....................  
.................... 	/* message ID 3 is query */ 
.................... 	can_id=(int32) 3; 
*
013D0:  MOVLB  2
013D2:  CLRF   x6F
013D4:  CLRF   x6E
013D6:  CLRF   x6D
013D8:  MOVLW  03
013DA:  MOVWF  x6C
....................  
.................... 	data[0]=queryRegister; 
013DC:  MOVFF  26B,270
.................... 	data[1]=0x00; 
013E0:  CLRF   x71
.................... 	data[2]=0x00; 
013E2:  CLRF   x72
.................... 	data[3]=0x00;  
013E4:  CLRF   x73
....................  
.................... 	if ( 0 == can_putd(can_id,data,4,0,FALSE,FALSE) ) { 
013E6:  MOVFF  26F,277
013EA:  MOVFF  26E,276
013EE:  MOVFF  26D,275
013F2:  MOVFF  26C,274
013F6:  MOVLW  02
013F8:  MOVWF  x79
013FA:  MOVLW  70
013FC:  MOVWF  x78
013FE:  MOVLW  04
01400:  MOVWF  x7A
01402:  CLRF   x7B
01404:  CLRF   x7C
01406:  CLRF   x7D
01408:  MOVLB  0
0140A:  BRA    12FE
0140C:  MOVF   01,F
0140E:  BNZ   1414
.................... 		/* on error */ 
.................... 		can_abort(); 
01410:  BSF    F6F.4
.................... 		can_init(); 
01412:  RCALL  0D4A
.................... //		timer.led_on_red=50; 
.................... 	} 
....................  
.................... } 
01414:  GOTO   1972 (RETURN)
....................  
....................  
.................... /* this is started after the bootloader is done loading or times out */ 
.................... void main(void) { 
*
017BE:  CLRF   FF8
017C0:  BCF    FD0.7
017C2:  BSF    07.7
017C4:  CLRF   FEA
017C6:  CLRF   FE9
017C8:  CLRF   1F
017CA:  BCF    FB8.3
017CC:  MOVLW  0C
017CE:  MOVWF  FAF
017D0:  MOVLW  A2
017D2:  MOVWF  FAC
017D4:  MOVLW  90
017D6:  MOVWF  FAB
017D8:  MOVLB  1
017DA:  CLRF   x5F
017DC:  CLRF   x5E
017DE:  BCF    x60.0
017E0:  CLRF   x61
017E2:  MOVLB  2
017E4:  CLRF   x68
017E6:  CLRF   x67
017E8:  MOVF   FC1,W
017EA:  ANDLW  C0
017EC:  IORLW  0F
017EE:  MOVWF  FC1
017F0:  CLRF   19
017F2:  CLRF   1A
.................... 	int8 last; 
....................  
.................... 	last=restart_cause(); 
017F4:  MOVF   FD0,W
017F6:  ANDLW  0F
017F8:  BTFSS  FD0.4
017FA:  MOVLW  00
017FC:  BSF    FD0.0
017FE:  BSF    FD0.1
01800:  BSF    FD0.4
01802:  BSF    FD8.3
01804:  BSF    FD8.4
01806:  MOVWF  x69
....................  
.................... 	/* normal device startup */ 
.................... 	init(); 
01808:  MOVLB  0
0180A:  GOTO   0E56
.................... 	read_param_file(); 
0180E:  BRA    1086
.................... 	 
.................... 	write_default_param_file(); 
01810:  RCALL  1056
....................  
.................... 	/* initial watchdog restart. Subsequently only restart in live send */ 
.................... 	restart_wdt(); 
01812:  CLRWDT
....................  
.................... 	/* set relay to be initially off (indicating fault). vcs live send then controls there after */ 
.................... 	output_low(RELAY_RED); 
01814:  BCF    F93.5
01816:  BCF    F8A.5
....................  
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	modbus_init(); 
....................  
.................... 	enable_interrupts(GLOBAL); 
01818:  MOVLW  C0
0181A:  IORWF  FF2,F
....................  
.................... 	fprintf(rs232,"# (world) vcstap.c %s - my serial %c%lu -",__DATE__,config.serial_prefix,config.serial_number); 
0181C:  MOVLW  D4
0181E:  MOVWF  FF6
01820:  MOVLW  09
01822:  MOVWF  FF7
01824:  MOVLW  13
01826:  MOVLB  2
01828:  MOVWF  x6A
0182A:  MOVLB  0
0182C:  RCALL  10DE
0182E:  MOVLW  FE
01830:  MOVWF  FF6
01832:  MOVLW  09
01834:  MOVWF  FF7
01836:  RCALL  1108
01838:  MOVLW  E9
0183A:  MOVWF  FF6
0183C:  MOVLW  09
0183E:  MOVWF  FF7
01840:  MOVLW  0D
01842:  MOVLB  2
01844:  MOVWF  x6A
01846:  MOVLB  0
01848:  RCALL  10DE
0184A:  MOVF   22,W
0184C:  BTFSS  F9E.4
0184E:  BRA    184C
01850:  MOVWF  FAD
01852:  MOVLW  10
01854:  MOVWF  FE9
01856:  MOVFF  24,26B
0185A:  MOVFF  23,26A
0185E:  BRA    112A
01860:  MOVLW  20
01862:  BTFSS  F9E.4
01864:  BRA    1862
01866:  MOVWF  FAD
01868:  MOVLW  2D
0186A:  BTFSS  F9E.4
0186C:  BRA    186A
0186E:  MOVWF  FAD
.................... 	switch ( last ) { 
01870:  MOVLB  2
01872:  MOVF   x69,W
01874:  XORLW  07
01876:  MOVLB  0
01878:  BZ    1894
0187A:  XORLW  0C
0187C:  BZ    18A0
0187E:  XORLW  04
01880:  BZ    18AC
01882:  XORLW  03
01884:  BZ    18B8
01886:  XORLW  02
01888:  BZ    18C4
0188A:  XORLW  0D
0188C:  BZ    18D0
0188E:  XORLW  03
01890:  BZ    18DC
01892:  BRA    18E8
.................... 		case WDT_TIMEOUT:       fprintf(rs232,"WDT_TIMEOUT\r\n"); break; 
01894:  MOVLW  08
01896:  MOVWF  FF6
01898:  MOVLW  0A
0189A:  MOVWF  FF7
0189C:  RCALL  1108
0189E:  BRA    18F2
.................... 		case MCLR_FROM_SLEEP:   fprintf(rs232,"MCLR_FROM_SLEEP\r\n"); break; 
018A0:  MOVLW  16
018A2:  MOVWF  FF6
018A4:  MOVLW  0A
018A6:  MOVWF  FF7
018A8:  RCALL  1108
018AA:  BRA    18F2
.................... 		case MCLR_FROM_RUN:     fprintf(rs232,"MCLR_FROM_RUN\r\n"); break; 
018AC:  MOVLW  28
018AE:  MOVWF  FF6
018B0:  MOVLW  0A
018B2:  MOVWF  FF7
018B4:  RCALL  1108
018B6:  BRA    18F2
.................... 		case NORMAL_POWER_UP:   fprintf(rs232,"NORMAL_POWER_UP\r\n"); break; 
018B8:  MOVLW  38
018BA:  MOVWF  FF6
018BC:  MOVLW  0A
018BE:  MOVWF  FF7
018C0:  RCALL  1108
018C2:  BRA    18F2
.................... 		case BROWNOUT_RESTART:  fprintf(rs232,"BROWNOUT_RESTART\r\n"); break; 
018C4:  MOVLW  4A
018C6:  MOVWF  FF6
018C8:  MOVLW  0A
018CA:  MOVWF  FF7
018CC:  RCALL  1108
018CE:  BRA    18F2
.................... 		case WDT_FROM_SLEEP:    fprintf(rs232,"WDT_FROM_SLEEP\r\n"); break; 
018D0:  MOVLW  5E
018D2:  MOVWF  FF6
018D4:  MOVLW  0A
018D6:  MOVWF  FF7
018D8:  RCALL  1108
018DA:  BRA    18F2
.................... 		case RESET_INSTRUCTION: fprintf(rs232,"RESET_INSTRUCTION\r\n"); break; 
018DC:  MOVLW  70
018DE:  MOVWF  FF6
018E0:  MOVLW  0A
018E2:  MOVWF  FF7
018E4:  RCALL  1108
018E6:  BRA    18F2
.................... 		default:                fprintf(rs232,"UNKNOWN CAUSE\r\n"); 
018E8:  MOVLW  84
018EA:  MOVWF  FF6
018EC:  MOVLW  0A
018EE:  MOVWF  FF7
018F0:  RCALL  1108
.................... 	} 
.................... 		 
....................  
.................... //	fprintf(rs232,"# (rs232) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
....................  
.................... 	/* fast red, yellow, green */ 
.................... 	timer.led_on_red  =200; 
018F2:  MOVLB  1
018F4:  CLRF   x59
018F6:  MOVLW  C8
018F8:  MOVWF  x58
.................... 	delay_ms(160); 
018FA:  MOVLW  A0
018FC:  MOVLB  2
018FE:  MOVWF  x6A
01900:  MOVLB  0
01902:  CALL   0A94
.................... 	timer.led_on_green=400; 
01906:  MOVLW  01
01908:  MOVLB  1
0190A:  MOVWF  x5B
0190C:  MOVLW  90
0190E:  MOVWF  x5A
.................... 	delay_ms(160); 
01910:  MOVLW  A0
01912:  MOVLB  2
01914:  MOVWF  x6A
01916:  MOVLB  0
01918:  CALL   0A94
.................... 	timer.led_on_red=0; 
0191C:  MOVLB  1
0191E:  CLRF   x59
01920:  CLRF   x58
.................... 	delay_ms(160); 
01922:  MOVLW  A0
01924:  MOVLB  2
01926:  MOVWF  x6A
01928:  MOVLB  0
0192A:  CALL   0A94
.................... 	timer.led_on_green=0; 
0192E:  MOVLB  1
01930:  CLRF   x5B
01932:  CLRF   x5A
....................  
....................  
.................... 	last=0; 
01934:  MOVLB  2
01936:  CLRF   x69
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... //		restart_wdt(); 
....................  
.................... 		/* read data from our different sources */ 
.................... 		read_data_xrw2g(); 
01938:  MOVLB  0
0193A:  BRA    12C2
.................... 		 
.................... 		/* transmit buffer empty */ 
.................... 		if ( can_tbe() && timer.vcs_query_age>=25 ) { 
0193C:  MOVLB  F
0193E:  BTFSS  x40.3
01940:  BRA    194A
01942:  BTFSS  x30.3
01944:  BRA    194A
01946:  BTFSC  x20.3
01948:  BRA    1978
0194A:  MOVLB  1
0194C:  MOVF   x54,F
0194E:  BNZ   195C
01950:  MOVF   x53,W
01952:  SUBLW  18
01954:  BTFSS  FD8.0
01956:  BRA    195C
01958:  MOVLB  F
0195A:  BRA    1978
.................... 			/* loop through our list of registers */ 
.................... 			if ( last == VCS_N_REGISTERS ) 
0195C:  MOVLB  2
0195E:  MOVF   x69,W
01960:  SUBLW  28
01962:  BNZ   1966
.................... 				last=0; 
01964:  CLRF   x69
....................  
.................... 			send_can_query(last++); 
01966:  MOVF   x69,W
01968:  INCF   x69,F
0196A:  MOVWF  x6A
0196C:  MOVWF  x6B
0196E:  MOVLB  0
01970:  BRA    13D0
.................... 			timer.vcs_query_age=0; 
01972:  MOVLB  1
01974:  CLRF   x54
01976:  CLRF   x53
.................... 		} 
....................  
....................  
.................... 	    /* 
.................... 	     * every 10 seconds we send a sync pulse which should trigger another packet from XRW2G 
.................... 	     */ 
.................... 	    if ( timer.now_telem ) { 
01978:  MOVLB  1
0197A:  MOVF   x5D,F
0197C:  BZ    1988
.................... 			timer.now_telem=0; 
0197E:  CLRF   x5D
.................... //			output_high(SYNC_OUT); 
.................... 			live_send_vcs(); 
01980:  MOVLB  0
01982:  BRA    1486
.................... //			output_high(TP_ORANGE); 
.................... 	    } else { 
01984:  BRA    198E
01986:  MOVLB  1
.................... 			output_low(SYNC_OUT); 
01988:  BCF    F94.5
0198A:  BCF    F8B.5
0198C:  MOVLB  0
.................... //			output_low(TP_ORANGE); 
.................... 	    } 
....................  
....................  
.................... 		/* we have XRW2G data, and we haven't gotten any more in last 50 miliseconds */ 
.................... 		if ( 0 != timer.xrw2g_buff_pos && timer.xrw2g_age > 50 ) { 
0198E:  MOVF   xB0,F
01990:  BZ    199E
01992:  MOVF   xB2,F
01994:  BNZ   199C
01996:  MOVF   xB1,W
01998:  SUBLW  32
0199A:  BC    199E
.................... #if 1 
.................... 			live_send_xrw2g(); 
0199C:  BRA    1666
.................... #else 
.................... 			fprintf(rs232,"# XRW2G %c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			if ( 0 == live_send_xrw2g() ) { 
.................... 				fprintf(rs232,"error-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} else { 
.................... 				fprintf(rs232,"success-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} 
.................... 			timer.telem_age=0; 
.................... #endif 
.................... 		} 
....................  
.................... 	} 
0199E:  BRA    193A
.................... } 
....................  
019A0:  BRA    19A0

Configuration Fuses:
   Word  1: 4F00   FCMEN NOIESO
   Word  2: 1A19   NOPUT NOBROWNOUT BORV21 NOWDT WDT8192
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
