CCS PCH C Compiler, Version 4.135, 4375               29-Aug-16 18:29

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\vcstap\vcstap.lst

               ROM used: 6582 bytes (10%)
                         Largest free fragment is 58378
               RAM used: 619 (19%) at main() level
                         847 (26%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   031E
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   0350
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   0402
00078:  BTFSS  FA3.7
0007A:  GOTO   0084
0007E:  BTFSC  FA4.7
00080:  GOTO   0000
00084:  BTFSS  FA3.1
00086:  GOTO   0090
0008A:  BTFSC  FA4.1
0008C:  GOTO   0822
00090:  BTFSS  FA3.0
00092:  GOTO   009C
00096:  BTFSC  FA4.0
00098:  GOTO   0670
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVF   04,W
000E0:  MOVFF  06,FE0
000E4:  MOVFF  05,FD8
000E8:  RETFIE 0
*
0FDBC:  GOTO   17CE
.................... #include "vcstap.h" 
.................... #include <18F2680.h> 
.................... //////// Standard Header file for the PIC18F2680 device //////////////// 
.................... #device PIC18F2680 
.................... #list 
....................  
.................... #device ADC=10 
.................... #device *=16 
....................  
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */ 
.................... #build(reset=0xfdbc:0xfdbf) 
.................... #org 0xfdc0,0xffff {} 
....................  
....................  
.................... /* 
.................... 		#define		BLPLP		9			;bootloader placement, pages from end 
.................... 		#define		BLSIZEP		9			;bootloader size [pages], used by bootloader protection	 
.................... */ 
....................  
....................  
.................... /* EEPROM locations */ 
.................... #define PARAM_CRC_ADDRESS 0x00 
.................... #define PARAM_ADDRESS     0x01 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#FUSES INTRC_IO,NOPROTECT,WDT8192, NOIESO, NODEBUG 
.................... #use delay(clock=8000000) 
*
00AA4:  MOVLW  02
00AA6:  MOVWF  FEA
00AA8:  MOVLW  6A
00AAA:  MOVWF  FE9
00AAC:  MOVF   FEF,W
00AAE:  BZ    0ACA
00AB0:  MOVLW  02
00AB2:  MOVWF  01
00AB4:  CLRF   00
00AB6:  DECFSZ 00,F
00AB8:  BRA    0AB6
00ABA:  DECFSZ 01,F
00ABC:  BRA    0AB4
00ABE:  MOVLW  97
00AC0:  MOVWF  00
00AC2:  DECFSZ 00,F
00AC4:  BRA    0AC2
00AC6:  DECFSZ FEF,F
00AC8:  BRA    0AB0
00ACA:  RETURN 0
....................  
.................... /* 
....................  Sensors  WorldData R33 R34 R35 R36 XBee | UART1    | UART2 | SCI_UART                  | STATUS 
....................  on-board Ethernet  DNS DNS DNS DNS DNS  | inverter | world | (onboard XRW2G)           | done 
....................  802.15.4 Ethernet  0   DNS DNS DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  802.15.4 802.15.4  0   0   0   DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  on-board 802.15.4  DNS 0   0   DNS YES  | inverter | world | (onboard XRW2G)           | done 
....................  */ 
....................  
....................  
....................  
.................... #use rs232(UART1,stream=rs232,baud=9600,xmit=PIN_C6,rcv=PIN_C7, errors)	 /* also connected to XPort transmit ... xport receive not connected */ 
*
003BC:  BTFSS  F9E.5
003BE:  BRA    03BC
003C0:  MOVFF  FAB,1F
003C4:  MOVFF  FAE,01
003C8:  BTFSS  1F.1
003CA:  BRA    03D0
003CC:  BCF    FAB.4
003CE:  BSF    FAB.4
003D0:  GOTO   0408 (RETURN)
*
0148E:  BTFSS  F9E.4
01490:  BRA    148E
01492:  MOVWF  FAD
01494:  RETURN 0
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST) 
*
00ACC:  MOVLW  08
00ACE:  MOVWF  01
00AD0:  NOP   
00AD2:  BCF    F8B.3
00AD4:  BCF    F94.3
00AD6:  NOP   
00AD8:  MOVLB  2
00ADA:  RLCF   x75,F
00ADC:  BCF    F8B.4
00ADE:  BTFSC  FD8.0
00AE0:  BSF    F94.4
00AE2:  BTFSS  FD8.0
00AE4:  BCF    F94.4
00AE6:  BSF    F94.3
00AE8:  BTFSS  F82.3
00AEA:  BRA    0AE8
00AEC:  DECFSZ 01,F
00AEE:  BRA    0AF2
00AF0:  BRA    0AF6
00AF2:  MOVLB  0
00AF4:  BRA    0AD0
00AF6:  NOP   
00AF8:  BCF    F8B.3
00AFA:  BCF    F94.3
00AFC:  NOP   
00AFE:  BSF    F94.4
00B00:  NOP   
00B02:  NOP   
00B04:  BSF    F94.3
00B06:  BTFSS  F82.3
00B08:  BRA    0B06
00B0A:  CLRF   01
00B0C:  NOP   
00B0E:  BTFSC  F82.4
00B10:  BSF    01.0
00B12:  BCF    F8B.3
00B14:  BCF    F94.3
00B16:  BCF    F8B.4
00B18:  BCF    F94.4
00B1A:  MOVLB  0
00B1C:  RETURN 0
*
011E6:  MOVLW  08
011E8:  MOVLB  2
011EA:  MOVWF  x6E
011EC:  MOVFF  00,26F
011F0:  BSF    F94.4
011F2:  NOP   
011F4:  BSF    F94.3
011F6:  BTFSS  F82.3
011F8:  BRA    11F6
011FA:  BTFSC  F82.4
011FC:  BSF    FD8.0
011FE:  BTFSS  F82.4
01200:  BCF    FD8.0
01202:  RLCF   01,F
01204:  NOP   
01206:  BCF    F94.3
01208:  BCF    F8B.3
0120A:  DECFSZ x6E,F
0120C:  BRA    11F0
0120E:  BSF    F94.4
01210:  NOP   
01212:  BCF    F8B.4
01214:  MOVF   x6F,W
01216:  BTFSS  FD8.2
01218:  BCF    F94.4
0121A:  NOP   
0121C:  BSF    F94.3
0121E:  BTFSS  F82.3
01220:  BRA    121E
01222:  NOP   
01224:  BCF    F8B.3
01226:  BCF    F94.3
01228:  NOP   
0122A:  BCF    F8B.4
0122C:  BCF    F94.4
0122E:  MOVLB  0
01230:  GOTO   129E (RETURN)
....................  
....................  
....................  
....................  
.................... #use standard_io(A) 
.................... #use standard_io(B) 
.................... #use standard_io(C) 
....................  
.................... #define LED_GREEN                  PIN_B4 
.................... // #define LED_RED                    PIN_B5 repurposed as relay 
.................... #define RELAY_RED                  PIN_B5 
....................  
.................... #define XBEE_SLEEP                 PIN_A0 
.................... #define XBEE_NRTS                  PIN_A1 
.................... #define XBEE_NCTS                  PIN_A2 
....................  
.................... #define SYNC_OUT                   PIN_C5 /* really labeled sync in */ 
....................  
.................... #define UART_IRQ                   PIN_B0 
.................... #define UART_RESET                 PIN_B1 
....................  
.................... #define TP14                       PIN_B3 
.................... #define TP15                       PIN_B2 
....................  
....................  
.................... #define TP_RED     PIN_B6 
.................... #define TP_ORANGE  PIN_B7 
....................  
....................  
.................... //#byte ANCON0=GETENV("SFR:ancon0") 
.................... //#byte ANCON1=GETENV("SFR:ancon1") 
....................  
....................  
....................  
.................... #define SERIAL_PREFIX_DEFAULT      'Z' 
.................... #define SERIAL_NUMBER_DEFAULT      6543 
....................  
.................... #define SENSOR_SOURCE_ONBOARD  0 
.................... #define SENSOR_SOURCE_WIRELESS 1 
....................  
....................  
.................... /* can baud rate registers */ 
.................... //#byte BRGCON1=GETENV("SFR:brgcon1") 
.................... //#byte BRGCON2=GETENV("SFR:brgcon2") 
.................... //#byte BRGCON3=GETENV("SFR:brgcon3") 
....................  
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 revision; 
....................  
.................... 	int8 modbus_address; 
....................  
.................... 	int8  serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int8  pair_serial_prefix; 
.................... 	int16 pair_serial_number; 
....................  
.................... 	int8  sensor_source; 
.................... 	int8  world_to_xbee; 
.................... 	int8  world_to_xport; 
.................... } struct_config; 
....................  
.................... #define VCS_N_REGISTERS 40 
....................  
.................... typedef struct { 
.................... 	int8  modbus_enable; 
.................... 	int8  modbus_last_error; 
.................... 	int8  factory_unlocked; 
.................... 	int16 telem_age; 
....................  
.................... 	int8  xrw2g_packet[128]; 
.................... 	int8  xrw2g_buff_pos; 
.................... 	int16 xrw2g_age; 
....................  
.................... 	/* VCS data as updated by the CAN bus */ 
.................... 	int8 vcs_register     [VCS_N_REGISTERS*4]; /* 40 32-bit registers */ 
.................... 	int16 vcs_query_age; 
.................... 	int8 vcs_read_lock; /* 1 means nobody can modify the data */ 
.................... 	int16 vcs_last_data_age; 
....................  
.................... 	int16 led_on_red; 
.................... 	int16 led_on_green; 
....................  
.................... 	int8 dump_register; 
....................  
.................... 	int8 now_telem; 
.................... } struct_timer; 
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_timer  timer; 
....................  
.................... #include "can.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "can.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define CAN_DO_DEBUG                FALSE 
....................  
.................... #define CAN_USE_EXTENDED_ID         FALSE 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH    0  //synchronized jump width (def: 1 x Tq) 
.................... #define CAN_BRG_PRESCALAR           4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #define CAN_BRG_SEG_2_PHASE_TS      TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #define CAN_BRG_SAM                 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #define CAN_BRG_PHASE_SEGMENT_1     5 //phase segment 1 (def: 6 x Tq) 
.................... #define CAN_BRG_PROPAGATION_TIME    2 //propagation time select (def: 3 x Tq) 
.................... #define CAN_BRG_WAKE_FILTER         FALSE   //selects can bus line filter for wake up bit 
.................... #define CAN_BRG_PHASE_SEGMENT_2     5 //phase segment 2 time select (def: 6 x Tq) 
.................... #define CAN_USE_RX_DOUBLE_BUFFER    TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #define CAN_ENABLE_DRIVE_HIGH       1      // required by CTIW CAN / VCSTAP 
.................... #define CAN_ENABLE_CAN_CAPTURE      0 
.................... #define CAN_ENABLE_CANTX2           0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #define CAN_CANTX2_SOURCE           0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
....................  
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
00D5A:  MOVLW  04
00D5C:  MOVLB  2
00D5E:  MOVWF  x74
00D60:  MOVLB  0
00D62:  RCALL  0BF2
....................    can_set_baud(); 
00D64:  BRA    0C18
....................  
....................    RXB0CON=0; 
00D66:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
00D68:  MOVLW  9F
00D6A:  ANDWF  F60,W
00D6C:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
00D6E:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
00D70:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
00D74:  BSF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
00D76:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
00D78:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
00D7A:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
00D7C:  MOVLW  0F
00D7E:  MOVLB  2
00D80:  MOVWF  x83
00D82:  MOVLW  1B
00D84:  MOVWF  x82
00D86:  CLRF   x87
00D88:  CLRF   x86
00D8A:  CLRF   x85
00D8C:  CLRF   x84
00D8E:  CLRF   x88
00D90:  MOVLB  0
00D92:  RCALL  0C26
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
00D94:  MOVLW  0F
00D96:  MOVLB  2
00D98:  MOVWF  x83
00D9A:  MOVLW  03
00D9C:  MOVWF  x82
00D9E:  CLRF   x87
00DA0:  CLRF   x86
00DA2:  CLRF   x85
00DA4:  CLRF   x84
00DA6:  CLRF   x88
00DA8:  MOVLB  0
00DAA:  RCALL  0C26
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
00DAC:  MOVLW  0F
00DAE:  MOVLB  2
00DB0:  MOVWF  x83
00DB2:  MOVLW  07
00DB4:  MOVWF  x82
00DB6:  CLRF   x87
00DB8:  CLRF   x86
00DBA:  CLRF   x85
00DBC:  CLRF   x84
00DBE:  CLRF   x88
00DC0:  MOVLB  0
00DC2:  RCALL  0C26
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
00DC4:  MOVLW  0F
00DC6:  MOVLB  2
00DC8:  MOVWF  x83
00DCA:  MOVLW  1F
00DCC:  MOVWF  x82
00DCE:  CLRF   x87
00DD0:  CLRF   x86
00DD2:  CLRF   x85
00DD4:  CLRF   x84
00DD6:  CLRF   x88
00DD8:  MOVLB  0
00DDA:  RCALL  0C26
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
00DDC:  MOVLW  0F
00DDE:  MOVLB  2
00DE0:  MOVWF  x83
00DE2:  MOVLW  0B
00DE4:  MOVWF  x82
00DE6:  CLRF   x87
00DE8:  CLRF   x86
00DEA:  CLRF   x85
00DEC:  CLRF   x84
00DEE:  CLRF   x88
00DF0:  MOVLB  0
00DF2:  RCALL  0C26
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
00DF4:  MOVLW  0F
00DF6:  MOVLB  2
00DF8:  MOVWF  x83
00DFA:  MOVWF  x82
00DFC:  CLRF   x87
00DFE:  CLRF   x86
00E00:  CLRF   x85
00E02:  CLRF   x84
00E04:  CLRF   x88
00E06:  MOVLB  0
00E08:  RCALL  0C26
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
00E0A:  MOVLW  0F
00E0C:  MOVLB  2
00E0E:  MOVWF  x83
00E10:  MOVLW  13
00E12:  MOVWF  x82
00E14:  CLRF   x87
00E16:  CLRF   x86
00E18:  CLRF   x85
00E1A:  CLRF   x84
00E1C:  CLRF   x88
00E1E:  MOVLB  0
00E20:  RCALL  0C26
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
00E22:  MOVLW  0F
00E24:  MOVLB  2
00E26:  MOVWF  x83
00E28:  MOVLW  17
00E2A:  MOVWF  x82
00E2C:  CLRF   x87
00E2E:  CLRF   x86
00E30:  CLRF   x85
00E32:  CLRF   x84
00E34:  CLRF   x88
00E36:  MOVLB  0
00E38:  RCALL  0C26
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
00E3A:  MOVF   F93,W
00E3C:  ANDLW  FB
00E3E:  IORLW  08
00E40:  MOVLB  2
00E42:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
00E44:  CLRF   x74
00E46:  MOVLB  0
00E48:  RCALL  0BF2
.................... } 
00E4A:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
.................... /* 250 kbps from 8 MHz oscillator */ 
.................... 	BRGCON1=0x00; 
*
00C18:  CLRF   F70
.................... 	BRGCON2=0xB8; 
00C1A:  MOVLW  B8
00C1C:  MOVWF  F71
.................... 	BRGCON3=0x05; 
00C1E:  MOVLW  05
00C20:  MOVWF  F72
.................... #if 0 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
....................    BRGCON2.sam=CAN_BRG_SAM; 
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
.................... #endif 
.................... } 
00C22:  GOTO   0D66 (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
00BF2:  MOVLB  2
00BF4:  SWAPF  x74,W
00BF6:  ANDLW  70
00BF8:  MOVWF  00
00BFA:  BCF    FD8.0
00BFC:  RLCF   00,F
00BFE:  MOVLW  1F
00C00:  ANDWF  F6F,W
00C02:  IORWF  00,W
00C04:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
00C06:  MOVFF  F6E,00
00C0A:  SWAPF  00,F
00C0C:  RRCF   00,W
00C0E:  ANDLW  07
00C10:  SUBWF  x74,W
00C12:  BNZ   0C06
.................... } 
00C14:  MOVLB  0
00C16:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
00C26:  MOVFF  283,28A
00C2A:  MOVFF  282,289
....................  
....................    if (ext) {  //extended 
00C2E:  MOVLB  2
00C30:  MOVF   x88,F
00C32:  BZ    0CD8
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
00C34:  MOVFF  289,FE9
00C38:  MOVFF  28A,FEA
00C3C:  MOVFF  284,FEF
....................  
....................       //eidh 
....................       ptr--; 
00C40:  MOVF   x89,W
00C42:  BTFSC  FD8.2
00C44:  DECF   x8A,F
00C46:  DECF   x89,F
....................       *ptr=make8(id,1); //8:15 
00C48:  MOVFF  289,FE9
00C4C:  MOVFF  28A,FEA
00C50:  MOVFF  285,FEF
....................  
....................       //sidl 
....................       ptr--; 
00C54:  MOVF   x89,W
00C56:  BTFSC  FD8.2
00C58:  DECF   x8A,F
00C5A:  DECF   x89,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
00C5C:  MOVFF  289,FE9
00C60:  MOVFF  28A,FEA
00C64:  MOVF   x86,W
00C66:  ANDLW  03
00C68:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
00C6A:  MOVFF  289,FE9
00C6E:  MOVFF  28A,FEA
00C72:  MOVFF  286,00
00C76:  RLCF   00,F
00C78:  RLCF   00,F
00C7A:  RLCF   00,F
00C7C:  MOVLW  F8
00C7E:  ANDWF  00,F
00C80:  MOVF   00,W
00C82:  ANDLW  E0
00C84:  IORWF  FEF,W
00C86:  MOVWF  FEF
....................       *ptr|=0x08; 
00C88:  MOVFF  289,FE9
00C8C:  MOVFF  28A,FEA
00C90:  MOVF   FEF,W
00C92:  IORLW  08
00C94:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
00C96:  MOVF   x89,W
00C98:  BTFSC  FD8.2
00C9A:  DECF   x8A,F
00C9C:  DECF   x89,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
00C9E:  MOVFF  289,FE9
00CA2:  MOVFF  28A,FEA
00CA6:  MOVFF  286,00
00CAA:  SWAPF  00,F
00CAC:  RRCF   00,F
00CAE:  MOVLW  07
00CB0:  ANDWF  00,F
00CB2:  MOVF   00,W
00CB4:  ANDLW  07
00CB6:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
00CB8:  MOVFF  289,FE9
00CBC:  MOVFF  28A,FEA
00CC0:  MOVFF  287,00
00CC4:  RLCF   00,F
00CC6:  RLCF   00,F
00CC8:  RLCF   00,F
00CCA:  MOVLW  F8
00CCC:  ANDWF  00,F
00CCE:  MOVF   00,W
00CD0:  ANDLW  F8
00CD2:  IORWF  FEF,W
00CD4:  MOVWF  FEF
....................    } 
....................    else {   //standard 
00CD6:  BRA    0D56
....................       //eidl 
....................       *ptr=0; 
00CD8:  MOVFF  289,FE9
00CDC:  MOVFF  28A,FEA
00CE0:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
00CE2:  MOVF   x89,W
00CE4:  BTFSC  FD8.2
00CE6:  DECF   x8A,F
00CE8:  DECF   x89,F
....................       *ptr=0; 
00CEA:  MOVFF  289,FE9
00CEE:  MOVFF  28A,FEA
00CF2:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
00CF4:  MOVF   x89,W
00CF6:  BTFSC  FD8.2
00CF8:  DECF   x8A,F
00CFA:  DECF   x89,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
00CFC:  MOVFF  289,FE9
00D00:  MOVFF  28A,FEA
00D04:  MOVFF  284,00
00D08:  SWAPF  00,F
00D0A:  RLCF   00,F
00D0C:  MOVLW  E0
00D0E:  ANDWF  00,F
00D10:  MOVF   00,W
00D12:  ANDLW  E0
00D14:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
00D16:  MOVF   x89,W
00D18:  BTFSC  FD8.2
00D1A:  DECF   x8A,F
00D1C:  DECF   x89,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
00D1E:  MOVFF  289,FE9
00D22:  MOVFF  28A,FEA
00D26:  MOVFF  284,00
00D2A:  RRCF   00,F
00D2C:  RRCF   00,F
00D2E:  RRCF   00,F
00D30:  MOVLW  1F
00D32:  ANDWF  00,F
00D34:  MOVF   00,W
00D36:  ANDLW  1F
00D38:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
00D3A:  MOVFF  289,FE9
00D3E:  MOVFF  28A,FEA
00D42:  MOVFF  285,00
00D46:  SWAPF  00,F
00D48:  RLCF   00,F
00D4A:  MOVLW  E0
00D4C:  ANDWF  00,F
00D4E:  MOVF   00,W
00D50:  ANDLW  E0
00D52:  IORWF  FEF,W
00D54:  MOVWF  FEF
....................    } 
.................... } 
00D56:  MOVLB  0
00D58:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
00478:  MOVLB  3
0047A:  CLRF   x47
0047C:  CLRF   x46
0047E:  CLRF   x45
00480:  CLRF   x44
....................    ptr=addr; 
00482:  MOVFF  342,349
00486:  MOVFF  341,348
....................  
....................    if (ext) { 
0048A:  MOVF   x43,F
0048C:  BTFSC  FD8.2
0048E:  BRA    05B6
....................       ret=*ptr;  //eidl 
00490:  MOVFF  349,03
00494:  MOVFF  348,FE9
00498:  MOVFF  349,FEA
0049C:  MOVFF  FEF,00
004A0:  CLRF   01
004A2:  CLRF   02
004A4:  CLRF   03
004A6:  MOVFF  03,347
004AA:  MOVFF  02,346
004AE:  MOVFF  01,345
004B2:  MOVFF  00,344
....................  
....................       ptr--;     //eidh 
004B6:  MOVF   x48,W
004B8:  BTFSC  FD8.2
004BA:  DECF   x49,F
004BC:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 8); 
004BE:  MOVFF  348,FE9
004C2:  MOVFF  349,FEA
004C6:  MOVF   FEF,W
004C8:  CLRF   x4C
004CA:  CLRF   x4B
004CC:  MOVWF  x4A
004CE:  CLRF   00
004D0:  MOVF   00,W
004D2:  IORWF  x44,F
004D4:  MOVF   x4A,W
004D6:  IORWF  x45,F
004D8:  MOVF   x4B,W
004DA:  IORWF  x46,F
004DC:  MOVF   x4C,W
004DE:  IORWF  x47,F
....................  
....................       ptr--;     //sidl 
004E0:  MOVF   x48,W
004E2:  BTFSC  FD8.2
004E4:  DECF   x49,F
004E6:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
004E8:  MOVFF  348,FE9
004EC:  MOVFF  349,FEA
004F0:  MOVF   FEF,W
004F2:  CLRF   x4D
004F4:  CLRF   x4C
004F6:  CLRF   x4B
004F8:  MOVWF  x4A
004FA:  MOVLW  03
004FC:  ANDWF  x4A,F
004FE:  CLRF   x4B
00500:  CLRF   x4C
00502:  CLRF   x4D
00504:  CLRF   00
00506:  CLRF   01
00508:  MOVF   00,W
0050A:  IORWF  x44,F
0050C:  MOVF   01,W
0050E:  IORWF  x45,F
00510:  MOVF   x4A,W
00512:  IORWF  x46,F
00514:  MOVF   x4B,W
00516:  IORWF  x47,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
00518:  MOVFF  348,FE9
0051C:  MOVFF  349,FEA
00520:  MOVF   FEF,W
00522:  CLRF   x4D
00524:  CLRF   x4C
00526:  CLRF   x4B
00528:  MOVWF  x4A
0052A:  MOVLW  E0
0052C:  ANDWF  x4A,F
0052E:  CLRF   x4B
00530:  CLRF   x4C
00532:  CLRF   x4D
00534:  CLRF   00
00536:  RLCF   x4A,W
00538:  MOVWF  01
0053A:  RLCF   x4B,W
0053C:  MOVWF  02
0053E:  RLCF   x4C,W
00540:  MOVWF  03
00542:  RLCF   01,F
00544:  RLCF   02,F
00546:  RLCF   03,F
00548:  RLCF   01,F
0054A:  RLCF   02,F
0054C:  RLCF   03,F
0054E:  RLCF   01,F
00550:  RLCF   02,F
00552:  RLCF   03,F
00554:  RLCF   01,F
00556:  RLCF   02,F
00558:  RLCF   03,F
0055A:  MOVLW  E0
0055C:  ANDWF  01,F
0055E:  MOVF   00,W
00560:  IORWF  x44,F
00562:  MOVF   01,W
00564:  IORWF  x45,F
00566:  MOVF   02,W
00568:  IORWF  x46,F
0056A:  MOVF   03,W
0056C:  IORWF  x47,F
....................  
....................       ptr--;     //sidh 
0056E:  MOVF   x48,W
00570:  BTFSC  FD8.2
00572:  DECF   x49,F
00574:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 21); 
00576:  MOVFF  348,FE9
0057A:  MOVFF  349,FEA
0057E:  MOVF   FEF,W
00580:  CLRF   x4B
00582:  MOVWF  x4A
00584:  CLRF   00
00586:  CLRF   01
00588:  RLCF   x4A,W
0058A:  MOVWF  02
0058C:  RLCF   x4B,W
0058E:  MOVWF  03
00590:  RLCF   02,F
00592:  RLCF   03,F
00594:  RLCF   02,F
00596:  RLCF   03,F
00598:  RLCF   02,F
0059A:  RLCF   03,F
0059C:  RLCF   02,F
0059E:  RLCF   03,F
005A0:  MOVLW  E0
005A2:  ANDWF  02,F
005A4:  MOVF   00,W
005A6:  IORWF  x44,F
005A8:  MOVF   01,W
005AA:  IORWF  x45,F
005AC:  MOVF   02,W
005AE:  IORWF  x46,F
005B0:  MOVF   03,W
005B2:  IORWF  x47,F
....................  
....................    } 
....................    else { 
005B4:  BRA    065C
....................       ptr-=2;    //sidl 
005B6:  MOVLW  02
005B8:  SUBWF  x48,F
005BA:  MOVLW  00
005BC:  SUBWFB x49,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
005BE:  MOVFF  348,FE9
005C2:  MOVFF  349,FEA
005C6:  MOVF   FEF,W
005C8:  CLRF   x4D
005CA:  CLRF   x4C
005CC:  CLRF   x4B
005CE:  MOVWF  x4A
005D0:  MOVLW  E0
005D2:  ANDWF  x4A,F
005D4:  CLRF   x4B
005D6:  CLRF   x4C
005D8:  CLRF   x4D
005DA:  RRCF   x4D,W
005DC:  MOVWF  x47
005DE:  RRCF   x4C,W
005E0:  MOVWF  x46
005E2:  RRCF   x4B,W
005E4:  MOVWF  x45
005E6:  RRCF   x4A,W
005E8:  MOVWF  x44
005EA:  RRCF   x47,F
005EC:  RRCF   x46,F
005EE:  RRCF   x45,F
005F0:  RRCF   x44,F
005F2:  RRCF   x47,F
005F4:  RRCF   x46,F
005F6:  RRCF   x45,F
005F8:  RRCF   x44,F
005FA:  RRCF   x47,F
005FC:  RRCF   x46,F
005FE:  RRCF   x45,F
00600:  RRCF   x44,F
00602:  RRCF   x47,F
00604:  RRCF   x46,F
00606:  RRCF   x45,F
00608:  RRCF   x44,F
0060A:  MOVLW  07
0060C:  ANDWF  x47,F
....................  
....................       ptr--;     //sidh 
0060E:  MOVF   x48,W
00610:  BTFSC  FD8.2
00612:  DECF   x49,F
00614:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 3); 
00616:  MOVFF  348,FE9
0061A:  MOVFF  349,FEA
0061E:  MOVF   FEF,W
00620:  CLRF   x4D
00622:  CLRF   x4C
00624:  CLRF   x4B
00626:  MOVWF  x4A
00628:  RLCF   x4A,W
0062A:  MOVWF  00
0062C:  RLCF   x4B,W
0062E:  MOVWF  01
00630:  RLCF   x4C,W
00632:  MOVWF  02
00634:  RLCF   x4D,W
00636:  MOVWF  03
00638:  RLCF   00,F
0063A:  RLCF   01,F
0063C:  RLCF   02,F
0063E:  RLCF   03,F
00640:  RLCF   00,F
00642:  RLCF   01,F
00644:  RLCF   02,F
00646:  RLCF   03,F
00648:  MOVLW  F8
0064A:  ANDWF  00,F
0064C:  MOVF   00,W
0064E:  IORWF  x44,F
00650:  MOVF   01,W
00652:  IORWF  x45,F
00654:  MOVF   02,W
00656:  IORWF  x46,F
00658:  MOVF   03,W
0065A:  IORWF  x47,F
....................    } 
....................  
....................    return(ret); 
0065C:  MOVFF  344,00
00660:  MOVFF  345,01
00664:  MOVFF  346,02
00668:  MOVFF  347,03
.................... } 
0066C:  MOVLB  0
0066E:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
0130E:  MOVLW  0F
01310:  MOVLB  2
01312:  MOVWF  x80
01314:  MOVLW  66
01316:  MOVWF  x7F
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
01318:  MOVLB  F
0131A:  BTFSC  x40.3
0131C:  BRA    132E
....................       CANCON.win=CAN_WIN_TX0; 
0131E:  MOVLW  F1
01320:  ANDWF  F6F,W
01322:  IORLW  08
01324:  MOVWF  F6F
....................       port=0; 
01326:  MOVLB  2
01328:  CLRF   x81
....................    } 
....................    else if (!TXB1CON.txreq) { 
0132A:  BRA    1362
0132C:  MOVLB  F
0132E:  BTFSC  x30.3
01330:  BRA    1344
....................       CANCON.win=CAN_WIN_TX1; 
01332:  MOVLW  F1
01334:  ANDWF  F6F,W
01336:  IORLW  06
01338:  MOVWF  F6F
....................       port=1; 
0133A:  MOVLW  01
0133C:  MOVLB  2
0133E:  MOVWF  x81
....................    } 
....................    else if (!TXB2CON.txreq) { 
01340:  BRA    1362
01342:  MOVLB  F
01344:  BTFSC  x20.3
01346:  BRA    135A
....................       CANCON.win=CAN_WIN_TX2; 
01348:  MOVLW  F1
0134A:  ANDWF  F6F,W
0134C:  IORLW  04
0134E:  MOVWF  F6F
....................       port=2; 
01350:  MOVLW  02
01352:  MOVLB  2
01354:  MOVWF  x81
....................    } 
....................    else { 
01356:  BRA    1362
01358:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0135A:  MOVLW  00
0135C:  MOVWF  01
0135E:  BRA    13DA
01360:  MOVLB  2
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
01362:  MOVF   x7B,W
01364:  ANDLW  03
01366:  MOVWF  00
01368:  MOVLW  FC
0136A:  ANDWF  F60,W
0136C:  IORWF  00,W
0136E:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
01370:  MOVLW  0F
01372:  MOVWF  x83
01374:  MOVLW  64
01376:  MOVWF  x82
01378:  MOVFF  277,287
0137C:  MOVFF  276,286
01380:  MOVFF  275,285
01384:  MOVFF  274,284
01388:  MOVFF  27C,288
0138C:  MOVLB  0
0138E:  RCALL  0C26
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
01390:  MOVFF  27A,F65
....................    TXBaDLC.rtr=rtr; 
01394:  BCF    F65.6
01396:  MOVLB  2
01398:  BTFSC  x7D.0
0139A:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
0139C:  CLRF   x7E
0139E:  MOVF   x7A,W
013A0:  SUBWF  x7E,W
013A2:  BC    13CC
....................       *txd0=*data; 
013A4:  MOVFF  278,FE9
013A8:  MOVFF  279,FEA
013AC:  MOVFF  FEF,284
013B0:  MOVFF  280,FEA
013B4:  MOVFF  27F,FE9
013B8:  MOVFF  284,FEF
....................       txd0++; 
013BC:  INCF   x7F,F
013BE:  BTFSC  FD8.2
013C0:  INCF   x80,F
....................       data++; 
013C2:  INCF   x78,F
013C4:  BTFSC  FD8.2
013C6:  INCF   x79,F
....................     } 
013C8:  INCF   x7E,F
013CA:  BRA    139E
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
013CC:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
013CE:  MOVLW  F1
013D0:  ANDWF  F6F,W
013D2:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
013D4:  MOVLW  01
013D6:  MOVWF  01
013D8:  MOVLB  F
.................... } 
013DA:  MOVLB  0
013DC:  GOTO   141C (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
0067E:  BTFSS  F60.7
00680:  BRA    06B0
*
00830:  BTFSS  F60.7
00832:  BRA    0862
....................         CANCON.win=CAN_WIN_RX0; 
*
00682:  MOVLW  F1
00684:  ANDWF  F6F,W
00686:  MOVWF  F6F
*
00834:  MOVLW  F1
00836:  ANDWF  F6F,W
00838:  MOVWF  F6F
....................         stat.buffer=0; 
*
00688:  BCF    x34.4
*
0083A:  BCF    x34.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
0068A:  BCF    FA4.0
*
0083C:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
0068C:  BCF    x34.0
0068E:  BTFSC  F74.7
00690:  BSF    x34.0
*
0083E:  BCF    x34.0
00840:  BTFSC  F74.7
00842:  BSF    x34.0
....................         COMSTAT.rx0ovfl=0; 
*
00692:  BCF    F74.7
*
00844:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
00694:  BTFSS  F60.2
00696:  BRA    06AE
*
00846:  BTFSS  F60.2
00848:  BRA    0860
....................          stat.filthit=RXB0CON.filthit0; 
*
00698:  MOVLW  00
0069A:  BTFSC  F60.0
0069C:  MOVLW  01
0069E:  ANDLW  07
006A0:  MOVWF  00
006A2:  BCF    FD8.0
006A4:  RLCF   00,F
006A6:  MOVLW  F1
006A8:  ANDWF  x34,W
006AA:  IORWF  00,W
006AC:  MOVWF  x34
*
0084A:  MOVLW  00
0084C:  BTFSC  F60.0
0084E:  MOVLW  01
00850:  ANDLW  07
00852:  MOVWF  00
00854:  BCF    FD8.0
00856:  RLCF   00,F
00858:  MOVLW  F1
0085A:  ANDWF  x34,W
0085C:  IORWF  00,W
0085E:  MOVWF  x34
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
006AE:  BRA    06F0
006B0:  MOVLB  F
006B2:  BTFSS  x50.7
006B4:  BRA    06E8
*
00860:  BRA    08A2
00862:  MOVLB  F
00864:  BTFSS  x50.7
00866:  BRA    089A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
006B6:  MOVLW  F1
006B8:  ANDWF  F6F,W
006BA:  IORLW  0A
006BC:  MOVWF  F6F
*
00868:  MOVLW  F1
0086A:  ANDWF  F6F,W
0086C:  IORLW  0A
0086E:  MOVWF  F6F
....................         stat.buffer=1; 
*
006BE:  MOVLB  3
006C0:  BSF    x34.4
*
00870:  MOVLB  3
00872:  BSF    x34.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
006C2:  BCF    FA4.1
*
00874:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
006C4:  BCF    x34.0
006C6:  BTFSC  F74.6
006C8:  BSF    x34.0
*
00876:  BCF    x34.0
00878:  BTFSC  F74.6
0087A:  BSF    x34.0
....................         COMSTAT.rx1ovfl=0; 
*
006CA:  BCF    F74.6
*
0087C:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
006CC:  MOVLB  F
006CE:  MOVF   x50,W
006D0:  ANDLW  07
006D2:  ANDLW  07
006D4:  MOVWF  00
006D6:  BCF    FD8.0
006D8:  RLCF   00,F
006DA:  MOVLW  F1
006DC:  MOVLB  3
006DE:  ANDWF  x34,W
006E0:  IORWF  00,W
006E2:  MOVWF  x34
*
0087E:  MOVLB  F
00880:  MOVF   x50,W
00882:  ANDLW  07
00884:  ANDLW  07
00886:  MOVWF  00
00888:  BCF    FD8.0
0088A:  RLCF   00,F
0088C:  MOVLW  F1
0088E:  MOVLB  3
00890:  ANDWF  x34,W
00892:  IORWF  00,W
00894:  MOVWF  x34
....................     } 
....................     else { 
*
006E4:  BRA    06F0
006E6:  MOVLB  F
*
00896:  BRA    08A2
00898:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
006E8:  MOVLW  00
006EA:  MOVWF  01
006EC:  BRA    0786
006EE:  MOVLB  3
*
0089A:  MOVLW  00
0089C:  MOVWF  01
0089E:  BRA    0938
008A0:  MOVLB  3
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
006F0:  MOVF   F65,W
006F2:  ANDLW  0F
006F4:  MOVWF  x33
*
008A2:  MOVF   F65,W
008A4:  ANDLW  0F
008A6:  MOVWF  x33
....................     stat.rtr=RXBaDLC.rtr; 
*
006F6:  BCF    x34.5
006F8:  BTFSC  F65.6
006FA:  BSF    x34.5
*
008A8:  BCF    x34.5
008AA:  BTFSC  F65.6
008AC:  BSF    x34.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
006FC:  BCF    x34.6
006FE:  BTFSC  F62.3
00700:  BSF    x34.6
*
008AE:  BCF    x34.6
008B0:  BTFSC  F62.3
008B2:  BSF    x34.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
00702:  MOVLW  00
00704:  BTFSC  x34.6
00706:  MOVLW  01
00708:  MOVWF  x3A
0070A:  MOVLW  0F
0070C:  MOVWF  x42
0070E:  MOVLW  64
00710:  MOVWF  x41
00712:  MOVFF  33A,343
00716:  MOVLB  0
00718:  RCALL  0478
0071A:  MOVFF  03,332
0071E:  MOVFF  02,331
00722:  MOVFF  01,330
00726:  MOVFF  00,32F
*
008B4:  MOVLW  00
008B6:  BTFSC  x34.6
008B8:  MOVLW  01
008BA:  MOVWF  x3A
008BC:  MOVLW  0F
008BE:  MOVWF  x42
008C0:  MOVLW  64
008C2:  MOVWF  x41
008C4:  MOVFF  33A,343
008C8:  MOVLB  0
008CA:  RCALL  0478
008CC:  MOVFF  03,332
008D0:  MOVFF  02,331
008D4:  MOVFF  01,330
008D8:  MOVFF  00,32F
....................  
....................     ptr = &TXRXBaD0; 
*
0072A:  MOVLW  0F
0072C:  MOVLB  3
0072E:  MOVWF  x39
00730:  MOVLW  66
00732:  MOVWF  x38
*
008DC:  MOVLW  0F
008DE:  MOVLB  3
008E0:  MOVWF  x39
008E2:  MOVLW  66
008E4:  MOVWF  x38
....................     for ( i = 0; i < len; i++ ) { 
*
00734:  CLRF   x37
00736:  MOVF   x33,W
00738:  SUBWF  x37,W
0073A:  BC    0764
*
008E6:  CLRF   x37
008E8:  MOVF   x33,W
008EA:  SUBWF  x37,W
008EC:  BC    0916
....................         *data = *ptr; 
*
0073C:  MOVFF  338,FE9
00740:  MOVFF  339,FEA
00744:  MOVFF  FEF,33C
00748:  MOVFF  336,FEA
0074C:  MOVFF  335,FE9
00750:  MOVFF  33C,FEF
*
008EE:  MOVFF  338,FE9
008F2:  MOVFF  339,FEA
008F6:  MOVFF  FEF,33C
008FA:  MOVFF  336,FEA
008FE:  MOVFF  335,FE9
00902:  MOVFF  33C,FEF
....................         data++; 
*
00754:  INCF   x35,F
00756:  BTFSC  FD8.2
00758:  INCF   x36,F
*
00906:  INCF   x35,F
00908:  BTFSC  FD8.2
0090A:  INCF   x36,F
....................         ptr++; 
*
0075A:  INCF   x38,F
0075C:  BTFSC  FD8.2
0075E:  INCF   x39,F
*
0090C:  INCF   x38,F
0090E:  BTFSC  FD8.2
00910:  INCF   x39,F
....................     } 
*
00760:  INCF   x37,F
00762:  BRA    0736
*
00912:  INCF   x37,F
00914:  BRA    08E8
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
00764:  MOVLW  F1
00766:  ANDWF  F6F,W
00768:  MOVWF  F6F
*
00916:  MOVLW  F1
00918:  ANDWF  F6F,W
0091A:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
0076A:  BCF    x34.7
0076C:  BTFSC  FA4.7
0076E:  BSF    x34.7
*
0091C:  BCF    x34.7
0091E:  BTFSC  FA4.7
00920:  BSF    x34.7
....................     CAN_INT_IRXIF = 0; 
*
00770:  BCF    FA4.7
*
00922:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
00772:  BTFSS  x34.4
00774:  BRA    077E
*
00924:  BTFSS  x34.4
00926:  BRA    0930
....................       RXB1CON.rxful=0; 
*
00776:  MOVLB  F
00778:  BCF    x50.7
*
00928:  MOVLB  F
0092A:  BCF    x50.7
....................     } 
....................     else { 
*
0077A:  BRA    0782
0077C:  MOVLB  3
*
0092C:  BRA    0934
0092E:  MOVLB  3
....................       RXB0CON.rxful=0; 
*
0077E:  BCF    F60.7
00780:  MOVLB  F
*
00930:  BCF    F60.7
00932:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
00782:  MOVLW  01
00784:  MOVWF  01
*
00934:  MOVLW  01
00936:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include "uart_sci16is740.c" 
.................... /* register map for SCI16IS740 */ 
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode 
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode 
.................... #define UART_IER          0x01  // Interrupt Enable Register 
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode 
.................... #define UART_LCR          0x03  // Line Control Register 
.................... #define UART_MCR          0x04  // Modem Control Register 
.................... #define UART_LSR          0x05  // Line status Register 
.................... #define UART_MSR          0x06  // Modem Status Register 
.................... #define UART_SPR          0x07  // ScratchPad Register 
.................... #define UART_TCR          0x06  // Transmission Control Register 
.................... #define UART_TLR          0x07  // Trigger Level Register 
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register 
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register 
.................... #define UART_EFCR         0x0F  // Extra Features Control Register 
....................  
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00 
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01 
....................  
.................... #define UART_EFR          0x02  // Enhanced Function Register 
....................  
.................... #define UART_I2C_WRITE    0x00 
.................... #define UART_I2C_READ     0x01                                                
....................  
.................... /* A0 and A1 at VSS */ 
.................... #define UART_ADDR         0x9A 
....................  
.................... int8 uart_read(int8 regaddr) { 
.................... 	int8 data; 
....................  
.................... 	i2c_start(); 
*
01234:  BSF    F94.4
01236:  NOP   
01238:  BSF    F94.3
0123A:  NOP   
0123C:  BCF    F8B.4
0123E:  BCF    F94.4
01240:  NOP   
01242:  BCF    F8B.3
01244:  BCF    F94.3
.................... 	delay_us(15); 
01246:  MOVLW  09
01248:  MOVWF  00
0124A:  DECFSZ 00,F
0124C:  BRA    124A
0124E:  BRA    1250
.................... 	i2c_write(UART_ADDR); 
01250:  MOVLW  9A
01252:  MOVLB  2
01254:  MOVWF  x75
01256:  MOVLB  0
01258:  RCALL  0ACC
.................... 	i2c_write(regaddr<<3); 
0125A:  MOVLB  2
0125C:  RLCF   x6B,W
0125E:  MOVWF  x6D
01260:  RLCF   x6D,F
01262:  RLCF   x6D,F
01264:  MOVLW  F8
01266:  ANDWF  x6D,F
01268:  MOVFF  26D,275
0126C:  MOVLB  0
0126E:  RCALL  0ACC
.................... 	i2c_start(); 
01270:  BSF    F94.4
01272:  NOP   
01274:  BSF    F94.3
01276:  NOP   
01278:  BTFSS  F82.3
0127A:  BRA    1278
0127C:  BCF    F8B.4
0127E:  BCF    F94.4
01280:  NOP   
01282:  BCF    F8B.3
01284:  BCF    F94.3
.................... 	delay_us(15); 
01286:  MOVLW  09
01288:  MOVWF  00
0128A:  DECFSZ 00,F
0128C:  BRA    128A
0128E:  BRA    1290
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                  
01290:  MOVLW  9B
01292:  MOVLB  2
01294:  MOVWF  x75
01296:  MOVLB  0
01298:  RCALL  0ACC
.................... 	data=i2c_read(0); 
0129A:  CLRF   00
0129C:  BRA    11E6
0129E:  MOVFF  01,26C
.................... 	i2c_stop(); 
012A2:  BCF    F94.4
012A4:  NOP   
012A6:  BSF    F94.3
012A8:  BTFSS  F82.3
012AA:  BRA    12A8
012AC:  NOP   
012AE:  BRA    12B0
012B0:  NOP   
012B2:  BSF    F94.4
012B4:  NOP   
....................  
.................... 	return data; 
012B6:  MOVLB  2
012B8:  MOVFF  26C,01
.................... } 
012BC:  MOVLB  0
012BE:  RETURN 0
....................  
.................... void uart_write(int8 regaddr, int8 data ) {                                                                   
.................... 	i2c_start(); 
*
00B1E:  BSF    F94.4
00B20:  NOP   
00B22:  BSF    F94.3
00B24:  NOP   
00B26:  BCF    F8B.4
00B28:  BCF    F94.4
00B2A:  NOP   
00B2C:  BCF    F8B.3
00B2E:  BCF    F94.3
.................... 	delay_us(15);                                                  
00B30:  MOVLW  09
00B32:  MOVWF  00
00B34:  DECFSZ 00,F
00B36:  BRA    0B34
00B38:  BRA    0B3A
.................... 	i2c_write(UART_ADDR); // write cycle                        
00B3A:  MOVLW  9A
00B3C:  MOVLB  2
00B3E:  MOVWF  x75
00B40:  MOVLB  0
00B42:  RCALL  0ACC
.................... 	i2c_write(regaddr<< 3);  // write cycle          
00B44:  MOVLB  2
00B46:  RLCF   x72,W
00B48:  MOVWF  x74
00B4A:  RLCF   x74,F
00B4C:  RLCF   x74,F
00B4E:  MOVLW  F8
00B50:  ANDWF  x74,F
00B52:  MOVFF  274,275
00B56:  MOVLB  0
00B58:  RCALL  0ACC
.................... 	i2c_write(data); 
00B5A:  MOVFF  273,275
00B5E:  RCALL  0ACC
.................... 	i2c_stop(); 
00B60:  BCF    F94.4
00B62:  NOP   
00B64:  BSF    F94.3
00B66:  BTFSS  F82.3
00B68:  BRA    0B66
00B6A:  NOP   
00B6C:  BRA    0B6E
00B6E:  NOP   
00B70:  BSF    F94.4
00B72:  NOP   
.................... }  
00B74:  RETURN 0
....................  
.................... void uart_putc(int8 data ) { 
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register 
*
01664:  MOVLB  2
01666:  CLRF   x72
01668:  MOVFF  271,273
0166C:  MOVLB  0
0166E:  CALL   0B1E
.................... } 
01672:  GOTO   17BC (RETURN)
....................  
.................... int1 uart_kbhit(void) { 
.................... 	return (uart_read(UART_LSR) & 0x01); 
*
012C0:  MOVLW  05
012C2:  MOVLB  2
012C4:  MOVWF  x6B
012C6:  MOVLB  0
012C8:  RCALL  1234
012CA:  MOVF   01,W
012CC:  ANDLW  01
012CE:  MOVWF  01
.................... } 
012D0:  RETURN 0
....................  
.................... #inline 
.................... int8 uart_getc() { 
.................... 	return uart_read(UART_RHR); 
*
012DE:  MOVLB  2
012E0:  CLRF   x6B
012E2:  MOVLB  0
012E4:  RCALL  1234
012E6:  MOVF   01,W
.................... } 
....................  
.................... void uart_init(void) { 
.................... 	output_low(UART_RESET); 
*
00B76:  BCF    F93.1
00B78:  BCF    F8A.1
.................... 	delay_ms(10); 
00B7A:  MOVLW  0A
00B7C:  MOVLB  2
00B7E:  MOVWF  x6A
00B80:  MOVLB  0
00B82:  RCALL  0AA4
.................... 	output_high(UART_RESET); 
00B84:  BCF    F93.1
00B86:  BSF    F8A.1
.................... 	delay_ms(10); 
00B88:  MOVLW  0A
00B8A:  MOVLB  2
00B8C:  MOVWF  x6A
00B8E:  MOVLB  0
00B90:  RCALL  0AA4
....................  
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */ 
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor 
00B92:  MOVLW  03
00B94:  MOVLB  2
00B96:  MOVWF  x72
00B98:  MOVLW  80
00B9A:  MOVWF  x73
00B9C:  MOVLB  0
00B9E:  RCALL  0B1E
.................... 	uart_write(UART_DLL, 12);    // divide clock by 12 for 9600 baud when using 1.8432 crystal 
00BA0:  MOVLB  2
00BA2:  CLRF   x72
00BA4:  MOVLW  0C
00BA6:  MOVWF  x73
00BA8:  MOVLB  0
00BAA:  RCALL  0B1E
.................... 	uart_write(UART_DLH, 0); 
00BAC:  MOVLW  01
00BAE:  MOVLB  2
00BB0:  MOVWF  x72
00BB2:  CLRF   x73
00BB4:  MOVLB  0
00BB6:  RCALL  0B1E
....................  
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register 
00BB8:  MOVLW  03
00BBA:  MOVLB  2
00BBC:  MOVWF  x72
00BBE:  MOVLW  BF
00BC0:  MOVWF  x73
00BC2:  MOVLB  0
00BC4:  RCALL  0B1E
.................... 	uart_write(UART_EFR, 0x10); // enable enhanced registers 
00BC6:  MOVLW  02
00BC8:  MOVLB  2
00BCA:  MOVWF  x72
00BCC:  MOVLW  10
00BCE:  MOVWF  x73
00BD0:  MOVLB  0
00BD2:  RCALL  0B1E
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity 
00BD4:  MOVLW  03
00BD6:  MOVLB  2
00BD8:  MOVWF  x72
00BDA:  MOVWF  x73
00BDC:  MOVLB  0
00BDE:  RCALL  0B1E
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available 
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode 
00BE0:  MOVLW  02
00BE2:  MOVLB  2
00BE4:  MOVWF  x72
00BE6:  MOVLW  07
00BE8:  MOVWF  x73
00BEA:  MOVLB  0
00BEC:  RCALL  0B1E
.................... } 
00BEE:  GOTO   0E90 (RETURN)
....................  
....................  
.................... #include "live.c" 
.................... int16 crc_chk(int8 *data, int8 length) { 
*
01428:  MOVLB  3
0142A:  SETF   x24
0142C:  SETF   x23
.................... 	int8 j; 
.................... 	int16 reg_crc=0xFFFF; 
....................  
.................... 	while ( length-- ) { 
0142E:  MOVF   x21,W
01430:  DECF   x21,F
01432:  XORLW  00
01434:  BZ    1482
.................... 		reg_crc ^= *data++; 
01436:  MOVFF  320,03
0143A:  MOVF   x1F,W
0143C:  INCF   x1F,F
0143E:  BTFSC  FD8.2
01440:  INCF   x20,F
01442:  MOVWF  FE9
01444:  MOVFF  03,FEA
01448:  MOVF   FEF,W
0144A:  XORWF  x23,F
....................  
.................... 		for ( j=0 ; j<8 ; j++ ) { 
0144C:  CLRF   x22
0144E:  MOVF   x22,W
01450:  SUBLW  07
01452:  BNC   1480
.................... 			if ( reg_crc & 0x01 ) { 
01454:  MOVF   x23,W
01456:  ANDLW  01
01458:  MOVWF  00
0145A:  CLRF   03
0145C:  MOVF   00,W
0145E:  IORWF  03,W
01460:  BZ    1476
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001; 
01462:  BCF    FD8.0
01464:  RRCF   x24,W
01466:  MOVWF  x26
01468:  RRCF   x23,W
0146A:  XORLW  01
0146C:  MOVWF  x23
0146E:  MOVF   x26,W
01470:  XORLW  A0
01472:  MOVWF  x24
.................... 			} else { 
01474:  BRA    147C
.................... 				reg_crc=reg_crc>>1; 
01476:  BCF    FD8.0
01478:  RRCF   x24,F
0147A:  RRCF   x23,F
.................... 			} 
.................... 		}	 
0147C:  INCF   x22,F
0147E:  BRA    144E
.................... 	} 
01480:  BRA    142E
.................... 	 
.................... 	return reg_crc; 
01482:  MOVFF  323,01
01486:  MOVFF  324,02
.................... } 
0148A:  MOVLB  0
0148C:  RETURN 0
....................  
.................... /* send CAN registers in RSTap data format */ 
.................... void live_send_vcs(void) { 
.................... 	static int16 sequenceNumber=0; 
.................... 	int16 lCRC; 
.................... 	int8 i,j; 
.................... 	int8 buff[177]; 
....................  
.................... 	memset(buff,0,sizeof(buff)); 
*
01496:  MOVLW  02
01498:  MOVWF  FEA
0149A:  MOVLW  6E
0149C:  MOVWF  FE9
0149E:  CLRF   00
014A0:  CLRF   02
014A2:  MOVLW  B1
014A4:  MOVWF  01
014A6:  RCALL  0E4C
....................  
.................... 	buff[0]='#'; 
014A8:  MOVLW  23
014AA:  MOVLB  2
014AC:  MOVWF  x6E
.................... 	buff[1]=config.serial_prefix; 
014AE:  MOVFF  22,26F
.................... 	buff[2]=make8(config.serial_number,1); 
014B2:  MOVFF  24,270
.................... 	buff[3]=make8(config.serial_number,0);  
014B6:  MOVFF  23,271
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */ 
014BA:  SETF   x72
.................... 	buff[5]=18; /* packet type */ 
014BC:  MOVLW  12
014BE:  MOVWF  x73
.................... 	buff[6]=0; 
014C0:  CLRF   x74
.................... 	buff[7]=179; /* 17 bytes header + 160 bytes CAN data + 2 bytes CRC */ 
014C2:  MOVLW  B3
014C4:  MOVWF  x75
....................  
.................... 	buff[8]=make8(sequenceNumber,1); 
014C6:  MOVFF  15F,276
014CA:  MOVLB  2
.................... 	buff[9]=make8(sequenceNumber,0); 
014CC:  MOVFF  15E,277
014D0:  MOVLB  2
....................  
.................... 	/* device info */ 
.................... 	/* WorldData device type identifier (16-bit) .... 1600 for VCSTap */ 
.................... 	buff[10]=make8(1600,1); 
014D2:  MOVLW  06
014D4:  MOVWF  x78
.................... 	buff[11]=make8(1600,0); 
014D6:  MOVLW  40
014D8:  MOVWF  x79
.................... 	/* manufacturers serial number */ 
.................... 	buff[12]=0; 
014DA:  CLRF   x7A
.................... 	buff[13]=config.pair_serial_prefix; 
014DC:  MOVFF  25,27B
.................... 	buff[14]=make8(config.pair_serial_number,1); 
014E0:  MOVFF  27,27C
.................... 	buff[15]=make8(config.pair_serial_number,0); 
014E4:  MOVFF  26,27D
.................... 	/* status of the data read  .... no error */ 
.................... 	buff[16]=0; 
014E8:  CLRF   x7E
....................  
.................... 	/* shut down CAN reception and copy CAN registers over */ 
.................... 	disable_interrupts(INT_CANRX0); 
014EA:  BCF    FA3.0
.................... 	disable_interrupts(INT_CANRX1); 
014EC:  BCF    FA3.1
.................... 	/* do our endian swap one word at a time */ 
.................... 	for ( i=0 ; i<160 ; i+=4 ) { 
014EE:  CLRF   x6C
014F0:  MOVF   x6C,W
014F2:  SUBLW  9F
014F4:  BNC   15C6
.................... 		j=i + 17; 
014F6:  MOVLW  11
014F8:  ADDWF  x6C,W
014FA:  MOVWF  x6D
....................  
.................... 		buff[j+0]=timer.vcs_register[i+1]; 
014FC:  CLRF   03
014FE:  MOVF   x6D,W
01500:  ADDLW  6E
01502:  MOVWF  01
01504:  MOVLW  02
01506:  ADDWFC 03,F
01508:  MOVLW  01
0150A:  MOVLB  2
0150C:  ADDWF  x6C,W
0150E:  ADDLW  B3
01510:  MOVWF  FE9
01512:  CLRF   FEA
01514:  BTFSC  FD8.0
01516:  INCF   FEA,F
01518:  MOVFF  FEF,321
0151C:  MOVLB  3
0151E:  MOVFF  03,FEA
01522:  MOVFF  01,FE9
01526:  MOVFF  321,FEF
.................... 		buff[j+1]=timer.vcs_register[i+0]; 
0152A:  MOVLW  01
0152C:  MOVLB  2
0152E:  ADDWF  x6D,W
01530:  CLRF   03
01532:  ADDLW  6E
01534:  MOVWF  01
01536:  MOVLW  02
01538:  ADDWFC 03,F
0153A:  MOVLW  B3
0153C:  MOVLB  2
0153E:  ADDWF  x6C,W
01540:  MOVWF  FE9
01542:  CLRF   FEA
01544:  BTFSC  FD8.0
01546:  INCF   FEA,F
01548:  MOVFF  FEF,321
0154C:  MOVLB  3
0154E:  MOVFF  03,FEA
01552:  MOVFF  01,FE9
01556:  MOVFF  321,FEF
.................... 		buff[j+2]=timer.vcs_register[i+3]; 
0155A:  MOVLW  02
0155C:  MOVLB  2
0155E:  ADDWF  x6D,W
01560:  CLRF   03
01562:  ADDLW  6E
01564:  MOVWF  01
01566:  MOVLW  02
01568:  ADDWFC 03,F
0156A:  MOVLW  03
0156C:  MOVLB  2
0156E:  ADDWF  x6C,W
01570:  ADDLW  B3
01572:  MOVWF  FE9
01574:  CLRF   FEA
01576:  BTFSC  FD8.0
01578:  INCF   FEA,F
0157A:  MOVFF  FEF,321
0157E:  MOVLB  3
01580:  MOVFF  03,FEA
01584:  MOVFF  01,FE9
01588:  MOVFF  321,FEF
.................... 		buff[j+3]=timer.vcs_register[i+2]; 
0158C:  MOVLW  03
0158E:  MOVLB  2
01590:  ADDWF  x6D,W
01592:  CLRF   03
01594:  ADDLW  6E
01596:  MOVWF  01
01598:  MOVLW  02
0159A:  ADDWFC 03,F
0159C:  MOVLW  02
0159E:  MOVLB  2
015A0:  ADDWF  x6C,W
015A2:  ADDLW  B3
015A4:  MOVWF  FE9
015A6:  CLRF   FEA
015A8:  BTFSC  FD8.0
015AA:  INCF   FEA,F
015AC:  MOVFF  FEF,321
015B0:  MOVLB  3
015B2:  MOVFF  03,FEA
015B6:  MOVFF  01,FE9
015BA:  MOVFF  321,FEF
.................... 	} 
015BE:  MOVLW  04
015C0:  MOVLB  2
015C2:  ADDWF  x6C,F
015C4:  BRA    14F0
....................  
.................... 	/* set fault indicator LED */ 
....................  
.................... 	/* any fault */ 
.................... //	if ( timer.vcs_register[30*4] || timer.vcs_register[30*4+1] || timer.vcs_register[30*4+2] || timer.vcs_register[30*4+3] ) { 
.................... 	/* system state 6 (FAULT) */ 
.................... //	if ( 6==timer.vcs_register[19*4+3] || 6==timer.vcs_register[19*4+2] || 6==timer.vcs_register[19*4+1] || 6==timer.vcs_register[19*4+0] ) { 
.................... 	if (  
.................... 		(0==timer.vcs_register[19*4+3] && 0==timer.vcs_register[19*4+2] && 0==timer.vcs_register[19*4+1] && 6==timer.vcs_register[19*4+0]) 
.................... //		|| timer.vcs_last_data_age>12000 
.................... 	 ) { 
015C6:  MOVLB  1
015C8:  MOVF   x02,F
015CA:  BNZ   15EA
015CC:  MOVF   x01,F
015CE:  BNZ   15EA
015D0:  MOVF   x00,F
015D2:  BNZ   15EA
015D4:  MOVLB  0
015D6:  MOVF   xFF,W
015D8:  SUBLW  06
015DA:  BTFSC  FD8.2
015DC:  BRA    15E2
015DE:  MOVLB  1
015E0:  BRA    15EA
.................... 		output_low(RELAY_RED); 
015E2:  BCF    F93.5
015E4:  BCF    F8A.5
.................... 	} else { 
015E6:  BRA    15F0
015E8:  MOVLB  1
.................... 		output_high(RELAY_RED); 
015EA:  BCF    F93.5
015EC:  BSF    F8A.5
015EE:  MOVLB  0
.................... 	} 
....................  
.................... 	enable_interrupts(INT_CANRX0); 
015F0:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1); 
015F2:  BSF    FA3.1
....................  
.................... 	/* compute CRC on header and result data */ 
.................... 	lCRC=crc_chk(buff+1,sizeof(buff)-1); 
015F4:  MOVLW  02
015F6:  MOVLB  3
015F8:  MOVWF  x20
015FA:  MOVLW  6F
015FC:  MOVWF  x1F
015FE:  MOVLW  B0
01600:  MOVWF  x21
01602:  MOVLB  0
01604:  RCALL  1428
01606:  MOVFF  02,26B
0160A:  MOVFF  01,26A
....................  
.................... 	/* send buff, qbuff.rResult, CRC */ 
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) { 
0160E:  MOVLB  2
01610:  CLRF   x6C
01612:  MOVF   x6C,W
01614:  SUBLW  B0
01616:  BNC   1638
.................... 		fputc(buff[i],rs232); 
01618:  CLRF   03
0161A:  MOVF   x6C,W
0161C:  ADDLW  6E
0161E:  MOVWF  FE9
01620:  MOVLW  02
01622:  ADDWFC 03,W
01624:  MOVWF  FEA
01626:  MOVFF  FEF,31F
0162A:  MOVLB  3
0162C:  MOVF   x1F,W
0162E:  MOVLB  0
01630:  RCALL  148E
.................... 	}	 
01632:  MOVLB  2
01634:  INCF   x6C,F
01636:  BRA    1612
.................... 	fputc(make8(lCRC,1),rs232); 
01638:  MOVFF  26B,31F
0163C:  MOVLB  3
0163E:  MOVF   x1F,W
01640:  MOVLB  0
01642:  RCALL  148E
.................... 	fputc(make8(lCRC,0),rs232); 
01644:  MOVFF  26A,31F
01648:  MOVLB  3
0164A:  MOVF   x1F,W
0164C:  MOVLB  0
0164E:  RCALL  148E
....................  
.................... 	sequenceNumber++; 
01650:  MOVLB  1
01652:  INCF   x5E,F
01654:  BTFSC  FD8.2
01656:  INCF   x5F,F
....................  
.................... 	output_high(SYNC_OUT); 
01658:  BCF    F94.5
0165A:  BSF    F8B.5
....................  
.................... 	restart_wdt(); 
0165C:  CLRWDT
.................... } 
0165E:  MOVLB  0
01660:  GOTO   1994 (RETURN)
....................  
.................... /*		 
.................... '#'                 0  STX 
.................... UNIT ID PREFIX      1  First character (A-Z) for serial number 
.................... UNIT ID MSB         2  high byte of sending station ID 
.................... UNIT ID LSB         3  low byte of sending station ID 
.................... PACKET LENGTH       4  number of byte for packet including STX through CRC 
.................... PACKET TYPE         5  type of packet we are sending, 27 
.................... SEQUENCE MSB        6 
.................... SEQUENCE LSB        7 
....................  
.................... CRC MSB              high byte of CRC on everything after STX and before CRC 
.................... CRC LSB              low byte of CRC 
.................... */ 
....................  
....................  
.................... int1 live_send_xrw2g() { 
*
01676:  MOVLB  2
01678:  BSF    x6F.0
.................... 	int16 lCRC, rCRC; 
.................... 	int8 i; 
.................... 	int1 valid=1; 
....................  
.................... //	fprintf(rs232,"# (live) xrw2g_packet{=0x%02X, 0x%02X, 0x%02X}\r\n",timer.xrw2g_packet[1],timer.xrw2g_packet[2],timer.xrw2g_packet[3]); 
....................  
....................  
....................  
.................... 	/* if wireless sensors, we might have heard something else and gotten in here. In that case, we 
.................... 	 drop back out and try again*/ 
.................... 	if ( SENSOR_SOURCE_WIRELESS == config.sensor_source ) { 
0167A:  DECFSZ 28,W
0167C:  BRA    16D2
.................... 	    valid=0; 
0167E:  BCF    x6F.0
....................  
.................... 	    /* check packet type */ 
.................... 	    if ( 23==timer.xrw2g_packet[5] && timer.xrw2g_buff_pos>10 ) { 
01680:  MOVF   35,W
01682:  SUBLW  17
01684:  BNZ   16D2
01686:  MOVLB  0
01688:  MOVF   xB0,W
0168A:  SUBLW  0A
0168C:  BTFSS  FD8.0
0168E:  BRA    1694
01690:  MOVLB  2
01692:  BRA    16D2
.................... 			/* is XRW2G packet */ 
.................... 			if ( 0==config.pair_serial_prefix && 0==config.pair_serial_number ) { 
01694:  MOVF   25,F
01696:  BNZ   16A8
01698:  MOVF   26,F
0169A:  BNZ   16A8
0169C:  MOVF   27,F
0169E:  BNZ   16A8
.................... 			    /* valid packet from an XRW2G, and we don't care which one */ 
.................... 			    valid=1; 
016A0:  MOVLB  2
016A2:  BSF    x6F.0
.................... 			} else if ( timer.xrw2g_packet[1] == config.pair_serial_prefix && make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) == config.pair_serial_number ) { 
016A4:  BRA    16D2
016A6:  MOVLB  0
016A8:  MOVF   25,W
016AA:  SUBWF  31,W
016AC:  BNZ   16D4
016AE:  MOVFF  32,271
016B2:  MOVFF  33,270
016B6:  MOVF   26,W
016B8:  MOVLB  2
016BA:  SUBWF  33,W
016BC:  BTFSC  FD8.2
016BE:  BRA    16C4
016C0:  MOVLB  0
016C2:  BRA    16D4
016C4:  MOVF   27,W
016C6:  SUBWF  x71,W
016C8:  BTFSC  FD8.2
016CA:  BRA    16D0
016CC:  MOVLB  0
016CE:  BRA    16D4
.................... 			    valid=1; 
016D0:  BSF    x6F.0
016D2:  MOVLB  0
.................... 			} 
.................... 	    } 
.................... 	} 
....................  
.................... 	if ( 0 == valid ) { 
016D4:  MOVLB  2
016D6:  BTFSC  x6F.0
016D8:  BRA    16E4
.................... 	    /* clear buffer and we'll try again next time */ 
.................... 	    timer.xrw2g_buff_pos=0; 
016DA:  MOVLB  0
016DC:  CLRF   xB0
.................... 	    return false; 
016DE:  MOVLW  00
016E0:  MOVWF  01
016E2:  BRA    17CA
.................... 	} 
....................  
.................... /*		 
.................... '#'                   0  STX 
.................... UNIT ID PREFIX        1  First character (A-Z) for serial number 
.................... UNIT ID MSB           2  high byte of sending station ID 
.................... UNIT ID LSB           3  low byte of sending station ID 
.................... PACKET LENGTH         4  number of byte for packet including STX through CRC 
.................... PACKET TYPE           5  type of packet we are sending, 23 
.................... SEQUENCE MSB          6 
.................... SEQUENCE LSB          7 
.................... (snip) 
.................... CRC MSB               96 high byte of CRC on everything after STX and before CRC 
.................... CRC LSB               97 low byte of CRC 
.................... 	config.serial_prefix='Z'; 
.................... 	config.serial_number=9876; 
.................... */ 
.................... 	/* check for valid CRC */ 
.................... 	if ( timer.xrw2g_buff_pos>=98 ) { 
016E4:  MOVLB  0
016E6:  MOVF   xB0,W
016E8:  SUBLW  61
016EA:  BC    1724
.................... 		rCRC = make16(timer.xrw2g_packet[96],timer.xrw2g_packet[97]); 
016EC:  MOVFF  90,26D
016F0:  MOVFF  91,26C
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
016F4:  MOVLB  3
016F6:  CLRF   x20
016F8:  MOVLW  31
016FA:  MOVWF  x1F
016FC:  MOVLW  5F
016FE:  MOVWF  x21
01700:  MOVLB  0
01702:  RCALL  1428
01704:  MOVFF  02,26B
01708:  MOVFF  01,26A
....................  
.................... 		if ( lCRC != rCRC ) { 
0170C:  MOVLB  2
0170E:  MOVF   x6C,W
01710:  SUBWF  x6A,W
01712:  BNZ   171A
01714:  MOVF   x6D,W
01716:  SUBWF  x6B,W
01718:  BZ    1726
.................... 		    /* clear buffer and we'll try again next time */ 
.................... 		    timer.xrw2g_buff_pos=0; 
0171A:  MOVLB  0
0171C:  CLRF   xB0
.................... 		    return false; 
0171E:  MOVLW  00
01720:  MOVWF  01
01722:  BRA    17CA
01724:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
.................... //	fprintf(rs232,"@ (sp=%c) (sn=%lu) (buff_pos=%u) @\r\n",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]),timer.xrw2g_buff_pos); 
.................... 	/* check for default serial number */ 
.................... 	if ( 'Z' == timer.xrw2g_packet[1] && 9876 == make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) && timer.xrw2g_buff_pos>=98 ) { 
01726:  MOVF   31,W
01728:  SUBLW  5A
0172A:  BNZ   177C
0172C:  MOVFF  32,03
01730:  MOVF   33,W
01732:  SUBLW  94
01734:  BNZ   177C
01736:  MOVF   03,W
01738:  SUBLW  26
0173A:  BNZ   177C
0173C:  MOVLB  0
0173E:  MOVF   xB0,W
01740:  SUBLW  61
01742:  BTFSS  FD8.0
01744:  BRA    174A
01746:  MOVLB  2
01748:  BRA    177C
.................... 		/* valid XRW2G packet with default serial number ... now we overwrite with our serial number */ 
.................... 		timer.xrw2g_packet[1]=config.serial_prefix; 
0174A:  MOVFF  22,31
.................... 		timer.xrw2g_packet[2]=make8(config.serial_number,1); 
0174E:  MOVFF  24,32
.................... 		timer.xrw2g_packet[3]=make8(config.serial_number,0); 
01752:  MOVFF  23,33
....................  
.................... 		/* and re-calculate and replace CRC */ 
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
01756:  MOVLB  3
01758:  CLRF   x20
0175A:  MOVLW  31
0175C:  MOVWF  x1F
0175E:  MOVLW  5F
01760:  MOVWF  x21
01762:  MOVLB  0
01764:  RCALL  1428
01766:  MOVFF  02,26B
0176A:  MOVFF  01,26A
.................... 		timer.xrw2g_packet[96]=make8(lCRC,1);		timer.xrw2g_packet[97]=make8(lCRC,0); 
0176E:  MOVFF  26B,90
01772:  MOVLB  2
01774:  MOVFF  26A,91
01778:  MOVLB  0
0177A:  MOVLB  2
.................... 	} 
....................  
....................  
....................  
.................... 	for ( i=0 ; i<98 ; i++ ) { 
0177C:  CLRF   x6E
0177E:  MOVF   x6E,W
01780:  SUBLW  61
01782:  BNC   17C2
.................... 	    if ( config.world_to_xport ) 
01784:  MOVF   2A,F
01786:  BZ    17A0
.................... 			fputc(timer.xrw2g_packet[i],rs232); 
01788:  MOVLW  30
0178A:  ADDWF  x6E,W
0178C:  MOVWF  FE9
0178E:  CLRF   FEA
01790:  BTFSC  FD8.0
01792:  INCF   FEA,F
01794:  MOVFF  FEF,270
01798:  MOVF   x70,W
0179A:  MOVLB  0
0179C:  RCALL  148E
0179E:  MOVLB  2
.................... 	    if ( config.world_to_xbee ) 
017A0:  MOVF   29,F
017A2:  BZ    17BE
.................... 			uart_putc(timer.xrw2g_packet[i]); 
017A4:  MOVLW  30
017A6:  ADDWF  x6E,W
017A8:  MOVWF  FE9
017AA:  CLRF   FEA
017AC:  BTFSC  FD8.0
017AE:  INCF   FEA,F
017B0:  MOVFF  FEF,270
017B4:  MOVFF  270,271
017B8:  MOVLB  0
017BA:  BRA    1664
017BC:  MOVLB  2
.................... 	} 
017BE:  INCF   x6E,F
017C0:  BRA    177E
....................  
.................... 	timer.xrw2g_buff_pos=0; 
017C2:  MOVLB  0
017C4:  CLRF   xB0
.................... 	return true; 
017C6:  MOVLW  01
017C8:  MOVWF  01
.................... } 
017CA:  GOTO   19AE (RETURN)
....................  
....................  
.................... #include "modbus_slave_vcstap.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE 88888 
.................... #define MODBUS_INT_RDA2 66666 
....................  
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_INT_SOURCE   MODBUS_INT_RDA    // Select between external interrupt 
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us 
....................  
.................... #inline  
.................... void rcv_off(void) { 
.................... 	disable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
....................  
.................... #byte TXSTA=0xfad // PIC18F24J11 TXSTA for UART1 */ 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #inline 
.................... void wait_for_hw_buffer(void) { 
.................... 	while ( ! TRMT ) 
.................... 		; 
.................... } 
....................  
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while(kbhit(rs232)) { 
.................... 		fgetc(rs232); 
.................... 	}   
.................... 	 
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
....................  
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); 
.................... 	enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0030A:  BCF    FF2.5
.................... 	if (enable) { 
0030C:  MOVLB  3
0030E:  MOVF   x28,F
00310:  BZ    031A
.................... 		set_timer0(0); 
00312:  CLRF   FD7
00314:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00316:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00318:  BSF    FF2.5
.................... 	} 
.................... } 
0031A:  MOVLB  0
0031C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... //#int_timer2 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0031E:  MOVLB  1
00320:  MOVF   x61,W
00322:  SUBLW  02
00324:  BNZ   033A
00326:  MOVF   x62,F
00328:  BNZ   033A
0032A:  MOVF   x63,F
0032C:  BNZ   033A
0032E:  BTFSC  x60.0
00330:  BRA    033A
....................    { 
....................       modbus_rx.len-=2; 
00332:  MOVLW  02
00334:  SUBWF  x65,F
....................       modbus_serial_new=TRUE; 
00336:  BSF    x60.0
....................    } 
....................    else 
00338:  BRA    033C
....................       modbus_serial_new=FALSE; 
0033A:  BCF    x60.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0033C:  SETF   x63
0033E:  SETF   x62
....................    modbus_serial_state=MODBUS_GETADDY; 
00340:  CLRF   x61
....................    modbus_enable_timeout(FALSE); 
00342:  MOVLB  3
00344:  CLRF   x28
00346:  MOVLB  0
00348:  RCALL  030A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0034A:  BCF    FF2.2
0034C:  GOTO   009C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
003D4:  MOVLB  1
003D6:  MOVF   x63,W
003D8:  MOVLB  3
003DA:  XORWF  x28,W
003DC:  MOVWF  x29
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
003DE:  CLRF   03
003E0:  MOVF   x29,W
003E2:  MOVLB  0
003E4:  RCALL  00EA
003E6:  MOVWF  01
003E8:  MOVLB  1
003EA:  MOVF   x62,W
003EC:  XORWF  01,W
003EE:  MOVWF  x63
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
003F0:  CLRF   03
003F2:  MOVLB  3
003F4:  MOVF   x29,W
003F6:  MOVLB  0
003F8:  RCALL  01FA
003FA:  MOVFF  FE8,162
.................... } 
003FE:  GOTO   0460 (RETURN)
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, rs232); 
.................... 	modbus_calc_crc(c); 
.................... 	delay_us(53); 
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
....................    modbus_serial_new=FALSE; 
....................  
....................    RCV_OFF(); 
....................     
....................  
....................  
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    modbus_serial_putc(to); 
....................    modbus_serial_putc(func); 
.................... } 
....................  
.................... void modbus_serial_send_stop() { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
....................    crc_low=modbus_serial_crc.b[0]; 
....................  
....................    modbus_serial_putc(crc_high); 
....................    modbus_serial_putc(crc_low); 
....................  
....................    WAIT_FOR_HW_BUFFER(); 
....................      
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    RCV_ON(); 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
....................       return FALSE; 
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
....................       modbus_rx.len = 1; 
....................    } 
....................    modbus_serial_new=FALSE; 
....................    return TRUE; 
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "interrupt.c" 
.................... #int_timer2 
.................... void isr_1ms(void) { 
.................... 	static int16 telem_count=0; 
.................... 	output_high(TP_RED); 
*
00350:  BCF    F93.6
00352:  BSF    F8A.6
.................... 	 
.................... 	if ( timer.vcs_query_age < 65535 ) 
00354:  MOVLB  1
00356:  INCFSZ x53,W
00358:  BRA    0360
0035A:  INCFSZ x54,W
0035C:  BRA    0360
0035E:  BRA    0366
.................... 		timer.vcs_query_age++; 
00360:  INCF   x53,F
00362:  BTFSC  FD8.2
00364:  INCF   x54,F
....................  
.................... 	if ( timer.vcs_last_data_age < 65535 ) 
00366:  INCFSZ x56,W
00368:  BRA    0370
0036A:  INCFSZ x57,W
0036C:  BRA    0370
0036E:  BRA    0376
.................... 		timer.vcs_last_data_age++; 
00370:  INCF   x56,F
00372:  BTFSC  FD8.2
00374:  INCF   x57,F
....................  
....................  
.................... 	/* data ages */ 
.................... 	if ( timer.xrw2g_age < 65535 ) 
00376:  MOVLB  0
00378:  INCFSZ xB1,W
0037A:  BRA    0382
0037C:  INCFSZ xB2,W
0037E:  BRA    0382
00380:  BRA    0388
.................... 		timer.xrw2g_age++; 
00382:  INCF   xB1,F
00384:  BTFSC  FD8.2
00386:  INCF   xB2,F
....................  
....................  
.................... 	if ( telem_count < 10000 ) { 
00388:  MOVLB  2
0038A:  MOVF   x68,W
0038C:  SUBLW  27
0038E:  BNC   03A0
00390:  BNZ   0398
00392:  MOVF   x67,W
00394:  SUBLW  0F
00396:  BNC   03A0
.................... 		telem_count++; 
00398:  INCF   x67,F
0039A:  BTFSC  FD8.2
0039C:  INCF   x68,F
.................... 	} else { 
0039E:  BRA    03AC
.................... 		timer.now_telem=1; 
003A0:  MOVLW  01
003A2:  MOVLB  1
003A4:  MOVWF  x5D
.................... 		telem_count=0; 
003A6:  MOVLB  2
003A8:  CLRF   x68
003AA:  CLRF   x67
.................... 	} 
....................  
.................... 	output_toggle(LED_GREEN); 
003AC:  BCF    F93.4
003AE:  BTG    F8A.4
....................  
.................... #if 0 
.................... 	/* LED Green */ 
.................... 	if ( 0==timer.led_on_green ) { 
.................... 		output_low(LED_GREEN); 
.................... 	} else { 
.................... 		output_high(LED_GREEN); 
.................... 		timer.led_on_green--; 
.................... 	} 
.................... #endif 
....................  
.................... #if 0 
.................... 	/* LED Red */ 
.................... 	if ( 0==timer.led_on_red ) { 
.................... 		output_low(LED_RED); 
.................... 	} else { 
.................... 		output_high(LED_RED); 
.................... 		timer.led_on_red--; 
.................... 	} 
.................... #endif 
....................  
.................... 	output_low(TP_RED); 
003B0:  BCF    F93.6
003B2:  BCF    F8A.6
.................... } 
....................  
003B4:  BCF    F9E.1
003B6:  MOVLB  0
003B8:  GOTO   009C
.................... #int_rda 
.................... void isr_serial_inverter(void) { 
.................... 	int8 c; 
.................... 	output_high(TP_ORANGE); 
*
00402:  BCF    F93.7
00404:  BSF    F8A.7
....................  
.................... 	c=fgetc(rs232); 
00406:  BRA    03BC
00408:  MOVFF  01,327
....................  
.................... 	if ( timer.modbus_enable )  { 
0040C:  MOVF   2B,F
0040E:  BZ    046A
.................... 		if ( ! modbus_serial_new) { 
00410:  MOVLB  1
00412:  BTFSC  x60.0
00414:  BRA    046C
.................... 			if ( modbus_serial_state == MODBUS_GETADDY) { 
00416:  MOVF   x61,F
00418:  BNZ   042A
.................... 				modbus_serial_crc.d = 0xFFFF; 
0041A:  SETF   x63
0041C:  SETF   x62
.................... 				modbus_rx.address = c; 
0041E:  MOVFF  327,164
.................... 				modbus_serial_state++; 
00422:  INCF   x61,F
.................... 				modbus_rx.len = 0; 
00424:  CLRF   x65
.................... 				modbus_rx.error=0; 
00426:  CLRF   x67
.................... 			} else if ( modbus_serial_state == MODBUS_GETFUNC) { 
00428:  BRA    0458
0042A:  DECFSZ x61,W
0042C:  BRA    0436
.................... 				modbus_rx.func = c; 
0042E:  MOVFF  327,166
.................... 				modbus_serial_state++; 
00432:  INCF   x61,F
.................... 			} else if(modbus_serial_state == MODBUS_GETDATA) { 
00434:  BRA    0458
00436:  MOVF   x61,W
00438:  SUBLW  02
0043A:  BNZ   0458
.................... 				if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
0043C:  INCFSZ x65,W
0043E:  BRA    0444
.................... 					modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00440:  MOVLW  FE
00442:  MOVWF  x65
.................... 				} 
.................... 				modbus_rx.data[modbus_rx.len]=c; 
00444:  MOVLW  68
00446:  ADDWF  x65,W
00448:  MOVWF  FE9
0044A:  MOVLW  01
0044C:  MOVWF  FEA
0044E:  BTFSC  FD8.0
00450:  INCF   FEA,F
00452:  MOVFF  327,FEF
.................... 				modbus_rx.len++; 
00456:  INCF   x65,F
.................... 			} 
.................... 	 
.................... 			modbus_calc_crc(c); 
00458:  MOVFF  327,328
0045C:  MOVLB  0
0045E:  BRA    03D4
.................... 			modbus_enable_timeout(TRUE); 
00460:  MOVLW  01
00462:  MOVLB  3
00464:  MOVWF  x28
00466:  MOVLB  0
00468:  RCALL  030A
0046A:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	 
.................... 	output_low(TP_ORANGE); 
0046C:  BCF    F93.7
0046E:  BCF    F8A.7
.................... } 
....................  
....................  
....................  
00470:  BCF    F9E.5
00472:  MOVLB  0
00474:  GOTO   009C
.................... #inline 
.................... void can_receive(void) { 
.................... 	int8 buffer[8]; 
.................... 	int32 rx_id; 
.................... 	int8 rx_len; 
.................... 	struct rx_stat rx; 
....................  
....................  
.................... 	if ( can_getd(rx_id,&buffer,rx_len,rx) ) { 
*
00674:  MOVLW  03
00676:  MOVLB  3
00678:  MOVWF  x36
0067A:  MOVLW  27
0067C:  MOVWF  x35
*
00786:  MOVF   01,F
00788:  BZ    0814
*
00826:  MOVLW  03
00828:  MOVLB  3
0082A:  MOVWF  x36
0082C:  MOVLW  27
0082E:  MOVWF  x35
*
00938:  MOVF   01,F
0093A:  BZ    09C6
.................... 		/* got something! */ 
.................... 		timer.led_on_green=50; 
*
0078A:  MOVLB  1
0078C:  CLRF   x5B
0078E:  MOVLW  32
00790:  MOVWF  x5A
*
0093C:  MOVLB  1
0093E:  CLRF   x5B
00940:  MOVLW  32
00942:  MOVWF  x5A
....................  
.................... 		/* VCS is ID ... ignore everything else */ 
.................... 		if ( 3 != rx_id ) 
*
00792:  MOVLB  3
00794:  MOVF   x2F,W
00796:  SUBLW  03
00798:  BNZ   07A6
0079A:  MOVF   x30,F
0079C:  BNZ   07A6
0079E:  MOVF   x31,F
007A0:  BNZ   07A6
007A2:  MOVF   x32,F
007A4:  BZ    07A8
*
00944:  MOVLB  3
00946:  MOVF   x2F,W
00948:  SUBLW  03
0094A:  BNZ   0958
0094C:  MOVF   x30,F
0094E:  BNZ   0958
00950:  MOVF   x31,F
00952:  BNZ   0958
00954:  MOVF   x32,F
00956:  BZ    095A
.................... 			return; 
*
007A6:  BRA    0816
*
00958:  BRA    09C8
....................  
.................... 		if ( 8 != rx_len ) 
*
007A8:  MOVF   x33,W
007AA:  SUBLW  08
007AC:  BZ    07B0
*
0095A:  MOVF   x33,W
0095C:  SUBLW  08
0095E:  BZ    0962
.................... 			return; 
*
007AE:  BRA    0816
*
00960:  BRA    09C8
....................  
.................... 		/* make sure register number is in range */ 
.................... 		if ( buffer[0] >= VCS_N_REGISTERS )  
*
007B0:  MOVF   x27,W
007B2:  SUBLW  27
007B4:  BC    07B8
*
00962:  MOVF   x27,W
00964:  SUBLW  27
00966:  BC    096A
.................... 			return; 
*
007B6:  BRA    0816
*
00968:  BRA    09C8
....................  
.................... 		timer.dump_register=buffer[0]; 
*
007B8:  MOVFF  327,15C
*
0096A:  MOVFF  327,15C
....................  
.................... 		/* re-use rx_len */ 
.................... 		rx_len = buffer[0]<<2; 
*
007BC:  RLCF   x27,W
007BE:  MOVWF  x33
007C0:  RLCF   x33,F
007C2:  MOVLW  FC
007C4:  ANDWF  x33,F
*
0096E:  RLCF   x27,W
00970:  MOVWF  x33
00972:  RLCF   x33,F
00974:  MOVLW  FC
00976:  ANDWF  x33,F
....................  
.................... 		/* copy CAN data into appropriate register */ 
.................... 		timer.vcs_register[rx_len + 0]=buffer[4]; 
*
007C6:  MOVLW  B3
007C8:  ADDWF  x33,W
007CA:  MOVWF  FE9
007CC:  CLRF   FEA
007CE:  BTFSC  FD8.0
007D0:  INCF   FEA,F
007D2:  MOVFF  32B,FEF
*
00978:  MOVLW  B3
0097A:  ADDWF  x33,W
0097C:  MOVWF  FE9
0097E:  CLRF   FEA
00980:  BTFSC  FD8.0
00982:  INCF   FEA,F
00984:  MOVFF  32B,FEF
.................... 		timer.vcs_register[rx_len + 1]=buffer[5]; 
*
007D6:  MOVLW  01
007D8:  ADDWF  x33,W
007DA:  ADDLW  B3
007DC:  MOVWF  FE9
007DE:  CLRF   FEA
007E0:  BTFSC  FD8.0
007E2:  INCF   FEA,F
007E4:  MOVFF  32C,FEF
*
00988:  MOVLW  01
0098A:  ADDWF  x33,W
0098C:  ADDLW  B3
0098E:  MOVWF  FE9
00990:  CLRF   FEA
00992:  BTFSC  FD8.0
00994:  INCF   FEA,F
00996:  MOVFF  32C,FEF
.................... 		timer.vcs_register[rx_len + 2]=buffer[6]; 
*
007E8:  MOVLW  02
007EA:  ADDWF  x33,W
007EC:  ADDLW  B3
007EE:  MOVWF  FE9
007F0:  CLRF   FEA
007F2:  BTFSC  FD8.0
007F4:  INCF   FEA,F
007F6:  MOVFF  32D,FEF
*
0099A:  MOVLW  02
0099C:  ADDWF  x33,W
0099E:  ADDLW  B3
009A0:  MOVWF  FE9
009A2:  CLRF   FEA
009A4:  BTFSC  FD8.0
009A6:  INCF   FEA,F
009A8:  MOVFF  32D,FEF
.................... 		timer.vcs_register[rx_len + 3]=buffer[7]; 
*
007FA:  MOVLW  03
007FC:  ADDWF  x33,W
007FE:  ADDLW  B3
00800:  MOVWF  FE9
00802:  CLRF   FEA
00804:  BTFSC  FD8.0
00806:  INCF   FEA,F
00808:  MOVFF  32E,FEF
*
009AC:  MOVLW  03
009AE:  ADDWF  x33,W
009B0:  ADDLW  B3
009B2:  MOVWF  FE9
009B4:  CLRF   FEA
009B6:  BTFSC  FD8.0
009B8:  INCF   FEA,F
009BA:  MOVFF  32E,FEF
....................  
.................... 		/* reset last data received timer */ 
.................... 		timer.vcs_last_data_age=0; 
*
0080C:  MOVLB  1
0080E:  CLRF   x57
00810:  CLRF   x56
00812:  MOVLB  F
00814:  MOVLB  3
*
009BE:  MOVLB  1
009C0:  CLRF   x57
009C2:  CLRF   x56
009C4:  MOVLB  F
009C6:  MOVLB  3
.................... 	} 
.................... } 
....................  
....................  
.................... #INT_CANRX0 
.................... void isr_can_rx0(void) { 
.................... 	output_high(TP_ORANGE); 
*
00670:  BCF    F93.7
00672:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
00816:  BCF    F93.7
00818:  BCF    F8A.7
.................... } 
....................  
0081A:  BCF    FA4.0
0081C:  MOVLB  0
0081E:  GOTO   009C
.................... #INT_CANRX1 
.................... void isr_can_rx1(void) { 
.................... 	output_high(TP_ORANGE); 
00822:  BCF    F93.7
00824:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
009C8:  BCF    F93.7
009CA:  BCF    F8A.7
.................... } 
....................  
....................  
009CC:  BCF    FA4.1
009CE:  MOVLB  0
009D0:  GOTO   009C
.................... #INT_CANIRX 
.................... /* CAN packet error lights up RED led for two seconds */ 
.................... void isr_canirx() { 
.................... 	clear_interrupt(INT_CANIRX); 
*
00000:  BCF    FA4.7
.................... //	timer.led_on_red=2000; 
.................... } 
....................  
.................... #include "param.c" 
00002:  BCF    FA4.7
00004:  GOTO   009C
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00F52:  MOVF   x76,W
00F54:  XORWF  x77,W
00F56:  MOVWF  01
*
00FA4:  MOVF   x76,W
00FA6:  XORWF  x77,W
00FA8:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00EE2:  MOVLB  2
00EE4:  CLRF   x73
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00EE6:  MOVFF  272,03
00EEA:  MOVF   x71,W
00EEC:  BTFSC  FD8.2
00EEE:  DECF   x72,F
00EF0:  DECF   x71,F
00EF2:  MOVWF  x74
00EF4:  MOVFF  03,275
00EF8:  MOVF   x74,F
00EFA:  BNZ   0F00
00EFC:  MOVF   x75,F
00EFE:  BZ    0F64
.................... 		*data = read_eeprom( address++ ); 
00F00:  MOVFF  270,03
00F04:  MOVF   x6F,W
00F06:  MOVWF  FE9
00F08:  MOVFF  03,FEA
00F0C:  MOVF   x6E,W
00F0E:  MOVWF  03
00F10:  MOVF   x6D,W
00F12:  INCF   x6D,F
00F14:  BTFSC  FD8.2
00F16:  INCF   x6E,F
00F18:  MOVWF  x76
00F1A:  MOVFF  03,277
00F1E:  MOVFF  FF2,278
00F22:  BCF    FF2.7
00F24:  MOVFF  277,FAA
00F28:  MOVFF  276,FA9
00F2C:  BCF    FA6.6
00F2E:  BCF    FA6.7
00F30:  BSF    FA6.0
00F32:  MOVF   FA8,W
00F34:  BTFSC  x78.7
00F36:  BSF    FF2.7
00F38:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00F3A:  MOVFF  270,03
00F3E:  MOVF   x6F,W
00F40:  MOVWF  FE9
00F42:  MOVFF  03,FEA
00F46:  MOVFF  FEF,274
00F4A:  MOVFF  273,276
00F4E:  MOVFF  274,277
*
00F58:  MOVFF  01,273
.................... 		data++; 
00F5C:  INCF   x6F,F
00F5E:  BTFSC  FD8.2
00F60:  INCF   x70,F
.................... 	} 
00F62:  BRA    0EE6
.................... 	return crc; 
00F64:  MOVFF  273,01
.................... } 
00F68:  MOVLB  0
00F6A:  GOTO   10B6 (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00F6E:  MOVLB  2
00F70:  CLRF   x74
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00F72:  MOVFF  273,03
00F76:  MOVF   x72,W
00F78:  BTFSC  FD8.2
00F7A:  DECF   x73,F
00F7C:  DECF   x72,F
00F7E:  MOVWF  x75
00F80:  MOVFF  03,276
00F84:  MOVF   x75,F
00F86:  BNZ   0F8C
00F88:  MOVF   x76,F
00F8A:  BZ    1008
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00F8C:  MOVFF  271,03
00F90:  MOVF   x70,W
00F92:  MOVWF  FE9
00F94:  MOVFF  03,FEA
00F98:  MOVFF  FEF,275
00F9C:  MOVFF  274,276
00FA0:  MOVFF  275,277
*
00FAA:  MOVFF  01,274
.................... 		write_eeprom( address++, *data++ ); 
00FAE:  MOVF   x6F,W
00FB0:  MOVWF  03
00FB2:  MOVF   x6E,W
00FB4:  INCF   x6E,F
00FB6:  BTFSC  FD8.2
00FB8:  INCF   x6F,F
00FBA:  MOVWF  x75
00FBC:  MOVFF  03,276
00FC0:  MOVF   x71,W
00FC2:  MOVWF  03
00FC4:  MOVF   x70,W
00FC6:  INCF   x70,F
00FC8:  BTFSC  FD8.2
00FCA:  INCF   x71,F
00FCC:  MOVWF  FE9
00FCE:  MOVFF  03,FEA
00FD2:  MOVFF  FEF,277
00FD6:  MOVFF  276,FAA
00FDA:  MOVFF  275,FA9
00FDE:  MOVFF  277,FA8
00FE2:  BCF    FA6.6
00FE4:  BCF    FA6.7
00FE6:  BSF    FA6.2
00FE8:  MOVF   FF2,W
00FEA:  MOVWF  00
00FEC:  BCF    FF2.7
00FEE:  MOVLB  F
00FF0:  MOVLW  55
00FF2:  MOVWF  FA7
00FF4:  MOVLW  AA
00FF6:  MOVWF  FA7
00FF8:  BSF    FA6.1
00FFA:  BTFSC  FA6.1
00FFC:  BRA    0FFA
00FFE:  BCF    FA6.2
01000:  MOVF   00,W
01002:  IORWF  FF2,F
.................... 	} 
01004:  MOVLB  2
01006:  BRA    0F72
....................  
.................... 	return crc; 
01008:  MOVFF  274,01
.................... } 
0100C:  MOVLB  0
0100E:  GOTO   1032 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
01012:  MOVLB  2
01014:  CLRF   x6D
01016:  MOVLW  20
01018:  MOVWF  x6C
0101A:  CLRF   x6F
0101C:  MOVLW  01
0101E:  MOVWF  x6E
01020:  MOVFF  26D,271
01024:  MOVFF  26C,270
01028:  CLRF   x73
0102A:  MOVLW  0B
0102C:  MOVWF  x72
0102E:  MOVLB  0
01030:  BRA    0F6E
01032:  MOVFF  01,26B
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
01036:  CLRF   FAA
01038:  CLRF   FA9
0103A:  MOVFF  26B,FA8
0103E:  BCF    FA6.6
01040:  BCF    FA6.7
01042:  BSF    FA6.2
01044:  MOVF   FF2,W
01046:  MOVWF  00
01048:  BCF    FF2.7
0104A:  MOVLB  F
0104C:  MOVLW  55
0104E:  MOVWF  FA7
01050:  MOVLW  AA
01052:  MOVWF  FA7
01054:  BSF    FA6.1
01056:  BTFSC  FA6.1
01058:  BRA    1056
0105A:  BCF    FA6.2
0105C:  MOVF   00,W
0105E:  IORWF  FF2,F
....................  
.................... } 
01060:  MOVLB  0
01062:  GOTO   1094 (RETURN)
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timer.led_on_red=150; 
01066:  MOVLB  1
01068:  CLRF   x59
0106A:  MOVLW  96
0106C:  MOVWF  x58
.................... //	fprintf(world,"# writing default parameters\r\n"); 
....................  
.................... 	config.revision='a'; 
0106E:  MOVLW  61
01070:  MOVWF  20
....................  
.................... 	config.serial_prefix='A'; //SERIAL_PREFIX_DEFAULT; 
01072:  MOVLW  41
01074:  MOVWF  22
.................... 	config.serial_number=4745; //SERIAL_NUMBER_DEFAULT; 
01076:  MOVLW  12
01078:  MOVWF  24
0107A:  MOVLW  89
0107C:  MOVWF  23
....................  
....................  
.................... 	config.sensor_source=SENSOR_SOURCE_ONBOARD; 
0107E:  CLRF   28
....................  
.................... 	config.world_to_xbee=0; 
01080:  CLRF   29
.................... 	config.world_to_xport=1; 
01082:  MOVLW  01
01084:  MOVWF  2A
....................  
.................... 	config.pair_serial_prefix=0; 
01086:  CLRF   25
.................... 	config.pair_serial_number=0; 
01088:  CLRF   27
0108A:  CLRF   26
....................  
.................... 	config.modbus_address=29; 
0108C:  MOVLW  1D
0108E:  MOVWF  21
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
01090:  MOVLB  0
01092:  BRA    1012
....................  
.................... } 
01094:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
01096:  MOVLB  2
01098:  CLRF   x6C
0109A:  MOVLW  20
0109C:  MOVWF  x6B
0109E:  CLRF   x6E
010A0:  MOVLW  01
010A2:  MOVWF  x6D
010A4:  MOVFF  26C,270
010A8:  MOVFF  26B,26F
010AC:  CLRF   x72
010AE:  MOVLW  0B
010B0:  MOVWF  x71
010B2:  MOVLB  0
010B4:  BRA    0EE2
010B6:  MOVFF  01,26A
....................  
.................... //	fprintf(modem,"# read_param_file()\r\n"); 
.................... //	print_param_file(); 
....................  
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) { 
010BA:  MOVFF  FF2,26B
010BE:  BCF    FF2.7
010C0:  CLRF   FAA
010C2:  CLRF   FA9
010C4:  BCF    FA6.6
010C6:  BCF    FA6.7
010C8:  BSF    FA6.0
010CA:  MOVF   FA8,W
010CC:  MOVLB  2
010CE:  BTFSC  x6B.7
010D0:  BSF    FF2.7
010D2:  SUBWF  x6A,W
010D4:  BNZ   10E2
010D6:  MOVF   20,W
010D8:  SUBLW  60
010DA:  BC    10E2
010DC:  MOVF   20,W
010DE:  SUBLW  7A
010E0:  BC    10E8
.................... 		write_default_param_file(); 
010E2:  MOVLB  0
010E4:  RCALL  1066
010E6:  MOVLB  2
.................... 	} 
....................  
.................... } 
010E8:  MOVLB  0
010EA:  GOTO   1820 (RETURN)
....................  
....................  
.................... #include "modbus_handler_vcstap.c" 
.................... #define MAX_DATA_REGISTER   100 
....................  
.................... #define MIN_CONFIG_REGISTER 1000 
.................... #define MAX_CONFIG_REGISTER 1011 
....................  
....................  
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	int16 val; 
.................... 	int8 i; 
....................  
.................... 	/* VCS registers */ 
.................... 	if ( addr >= 3 && addr <= 83 ) { 
.................... 		addr -= 3; 
....................  
.................... 		i=addr % 2; 
.................... 		if ( 1 == i ) 
.................... 			addr -= 1; 
....................  
.................... 		addr = addr >> 1; 
....................  
.................... 		timer.vcs_read_lock=1; 
.................... 		 
....................  
.................... 		return 0; 
.................... 	} 
....................  
.................... 	/* XRW2G data */ 
....................  
.................... 	switch ( addr ) { 
.................... 		 
.................... 		/* data */ 
.................... 		case   0: return 0; /* VCS control register ... always reads as 0 */ 
.................... 		case   1: return timer.vcs_query_age; 
.................... 		case   2: return timer.xrw2g_age; 
....................  
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return config.serial_prefix; 
.................... 		case 1001: return config.serial_number; 
.................... 		case 1002: return 'V'; 
.................... 		case 1003: return 'C'; 
.................... 		case 1004: return 'S'; 
.................... 		case 1005: return  0; 
.................... 		case 1006: return config.modbus_address; 
.................... 		case 1007: return config.sensor_source; 
.................... 		case 1008: return config.pair_serial_prefix; 
.................... 		case 1009: return config.pair_serial_number; 
.................... 		case 1010: return config.world_to_xbee; 
.................... 		case 1011: return config.world_to_xport; 
....................  
.................... 	    
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return 65535; 
.................... 	} 
....................  
.................... } 
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( start <= MAX_DATA_REGISTER && end <= MAX_DATA_REGISTER+1 )  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	/* factory unlock */ 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	/* write eeprom */ 
.................... 	if ( start >= 1998 && end <= 2000+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
.................... 	modbus_serial_putc(register_count*2); 
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
.................... 		l=map_modbus(start_address+i); 
.................... 		modbus_serial_putc(make8(l,1)); 
....................   		modbus_serial_putc(make8(l,0)); 
.................... 	} 
....................  
.................... 	modbus_serial_send_stop(); 
.................... } 
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( timer.factory_unlocked ) { 
.................... 		if ( 1000 == address ) { 
.................... 			config.serial_prefix=value; 
.................... 			return 0; 
.................... 		} else if ( 1001 == address ) { 
.................... 			config.serial_number=value; 
.................... 			return 0; 
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.modbus_address=value; 
.................... 			break; 
....................                 case 1007: 
....................                         if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
....................                         config.sensor_source=value; 
....................                         break; 
....................                 case 1008: 
....................                         if ( value > 255 ) return ILLEGAL_DATA_VALUE; 
....................                         config.pair_serial_prefix=value; 
....................                         break; 
....................                 case 1009: 
....................                         config.pair_serial_number=value; 
....................                         break; 
.................... 		case 1010: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xbee=value; 
.................... 			break; 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xport=value; 
.................... 			break; 
.................... 		case 1997: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			reset_cpu(); 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_default_param_file(); 
.................... 			break; 
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_param_file(); 
.................... 			break; 
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
.................... 				timer.factory_unlocked=0; 
.................... 				return ILLEGAL_DATA_VALUE; 
.................... 			} 
.................... 			timer.factory_unlocked=1; 
.................... 			/* green LED for 2 seconds */ 
.................... 			timer.led_on_green=200; 
.................... 			timer.led_on_red=0; 
.................... 			break; 
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
.................... 		/* check if it is addressed to us */ 
.................... 		if ( modbus_rx.address==config.modbus_address ) {	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=0; 
....................  
.................... 			switch(modbus_rx.func) { 
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
.................... 						timer.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					} else { 
.................... 						modbus_read_register_response(config.modbus_address,start_addr,num_registers); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
....................  
.................... 					if ( result ) { 
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 						timer.modbus_last_error=result; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					}  else { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(config.modbus_address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
....................  
.................... 						if ( result ) { 
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 							timer.modbus_last_error=result; 
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timer.led_on_red=100; 
.................... 							timer.led_on_green=0; 
.................... 			 
.................... 							break; 
.................... 						} 
.................... 					} 
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers); 
.................... 					} 
....................  
.................... 					break;   
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION); 
.................... 					timer.modbus_last_error=ILLEGAL_FUNCTION; 
....................  
.................... 					/* red led for 1 second */ 
.................... 					timer.led_on_red=100; 
.................... 					timer.led_on_green=0; 
.................... 			} 
.................... 		} else { 
.................... 			/* MODBUS packet for somebody else */ 
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=20; 
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void init() { 
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
00E66:  MOVLW  72
00E68:  MOVWF  FD3
00E6A:  MOVF   FD3,W
.................... 	restart_wdt(); 
00E6C:  CLRWDT
.................... 	setup_wdt(WDT_ON); 
00E6E:  BSF    FD1.0
.................... 	setup_adc(ADC_OFF); 
00E70:  BCF    FC2.0
.................... 	/*  
.................... 	setup_adc_ports(NO_ANALOGS); doesn't seem to work.  
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital 
.................... 	*/ 
.................... //	ANCON0=0xff; 
.................... //	ANCON1=0x1f; 
.................... 	 
.................... 	 
.................... //	setup_comparator(NC_NC_NC_NC); 
....................  
.................... 	setup_timer_2(T2_DIV_BY_16,61,2); // set 1 millisecond period with 8 MHz oscillator 
00E72:  MOVLW  08
00E74:  IORLW  06
00E76:  MOVWF  FCA
00E78:  MOVLW  3D
00E7A:  MOVWF  FCB
....................  
.................... 	port_b_pullups(TRUE); 
00E7C:  BCF    FF1.7
.................... 	delay_ms(10); 
00E7E:  MOVLW  0A
00E80:  MOVLB  2
00E82:  MOVWF  x6A
00E84:  MOVLB  0
00E86:  RCALL  0AA4
.................... 	 
.................... 	output_low(SYNC_OUT); 
00E88:  BCF    F94.5
00E8A:  BCF    F8B.5
....................  
....................  
.................... 	timer.modbus_enable=FALSE; 
00E8C:  CLRF   2B
....................  
....................  
.................... 	/* xrw2g uart */ 
.................... 	uart_init(); 
00E8E:  BRA    0B76
....................  
.................... 	/* CAN interface to VCS */ 
.................... 	can_init(); 
00E90:  RCALL  0D5A
....................  
.................... 	/* receive and receiver error interrupts */ 
.................... 	enable_interrupts(INT_CANRX0);  
00E92:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1);  
00E94:  BSF    FA3.1
.................... 	enable_interrupts(INT_CANIRX); 
00E96:  BSF    FA3.7
....................  
....................  
....................  
.................... 	/* global structures */ 
.................... 	timer.factory_unlocked=0; 
00E98:  CLRF   2D
.................... 	timer.telem_age=0; 
00E9A:  CLRF   2F
00E9C:  CLRF   2E
....................  
.................... 	timer.xrw2g_age=65535; 
00E9E:  SETF   xB2
00EA0:  SETF   xB1
.................... 	timer.xrw2g_buff_pos=0; 
00EA2:  CLRF   xB0
.................... 	memset(timer.xrw2g_packet, 0, sizeof(timer.xrw2g_packet)); 
00EA4:  CLRF   FEA
00EA6:  MOVLW  30
00EA8:  MOVWF  FE9
00EAA:  CLRF   00
00EAC:  CLRF   02
00EAE:  MOVLW  80
00EB0:  MOVWF  01
00EB2:  RCALL  0E4C
....................  
.................... 	timer.vcs_read_lock=0; 
00EB4:  MOVLB  1
00EB6:  CLRF   x55
.................... 	timer.vcs_query_age=0; 
00EB8:  CLRF   x54
00EBA:  CLRF   x53
.................... 	timer.vcs_last_data_age=65535; 
00EBC:  SETF   x57
00EBE:  SETF   x56
.................... 	memset(timer.vcs_register, 0, sizeof(timer.vcs_register)); 
00EC0:  CLRF   FEA
00EC2:  MOVLW  B3
00EC4:  MOVWF  FE9
00EC6:  CLRF   00
00EC8:  CLRF   02
00ECA:  MOVLW  A0
00ECC:  MOVWF  01
00ECE:  MOVLB  0
00ED0:  RCALL  0E4C
....................  
.................... 	timer.dump_register=255;  
00ED2:  MOVLB  1
00ED4:  SETF   x5C
.................... 	timer.now_telem=0; 
00ED6:  CLRF   x5D
....................  
.................... 	/* receive data from serial ports */ 
.................... 	enable_interrupts(INT_RDA);  /* inverter */ 
00ED8:  BSF    F9D.5
.................... //	enable_interrupts(INT_RDA2); /* world (ethernet or xbee */ 
....................  
.................... 	/* timer0 is used for modbus handler */ 
....................  
.................... 	/* 1 millisecond timer */ 
.................... 	enable_interrupts(INT_TIMER2); 
00EDA:  BSF    F9D.1
....................  
....................  
.................... } 
00EDC:  MOVLB  0
00EDE:  GOTO   181E (RETURN)
....................  
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... void read_data_xrw2g(void) { 
.................... 	int8 c; 
....................  
.................... 	if ( uart_kbhit() ) { 
*
012D2:  RCALL  12C0
012D4:  MOVF   01,F
012D6:  BZ    130A
.................... 		while ( uart_kbhit() ) { 
012D8:  RCALL  12C0
012DA:  MOVF   01,F
012DC:  BZ    130A
.................... //			output_high(TP_ORANGE); 
.................... 			c=uart_getc(); 
*
012E8:  MOVFF  01,26A
.................... //			output_low(TP_ORANGE); 
.................... 			timer.xrw2g_age=0; 
012EC:  CLRF   xB2
012EE:  CLRF   xB1
....................  
.................... 			if ( timer.xrw2g_buff_pos < sizeof(timer.xrw2g_packet) ) { 
012F0:  MOVF   xB0,W
012F2:  SUBLW  7F
012F4:  BNC   1308
.................... 				timer.xrw2g_packet[timer.xrw2g_buff_pos++]=c; 
012F6:  MOVF   xB0,W
012F8:  INCF   xB0,F
012FA:  ADDLW  30
012FC:  MOVWF  FE9
012FE:  CLRF   FEA
01300:  BTFSC  FD8.0
01302:  INCF   FEA,F
01304:  MOVFF  26A,FEF
.................... 			} 
.................... 		} 
01308:  BRA    12D8
.................... 	} 
.................... } 
0130A:  GOTO   194C (RETURN)
....................  
....................  
.................... void send_can_query(int8 queryRegister) { 
.................... 	unsigned int32 can_id; 
.................... 	unsigned int8 data[4]; 
....................  
.................... 	/* message ID 3 is query */ 
.................... 	can_id=(int32) 3; 
*
013E0:  MOVLB  2
013E2:  CLRF   x6F
013E4:  CLRF   x6E
013E6:  CLRF   x6D
013E8:  MOVLW  03
013EA:  MOVWF  x6C
....................  
.................... 	data[0]=queryRegister; 
013EC:  MOVFF  26B,270
.................... 	data[1]=0x00; 
013F0:  CLRF   x71
.................... 	data[2]=0x00; 
013F2:  CLRF   x72
.................... 	data[3]=0x00;  
013F4:  CLRF   x73
....................  
.................... 	if ( 0 == can_putd(can_id,data,4,0,FALSE,FALSE) ) { 
013F6:  MOVFF  26F,277
013FA:  MOVFF  26E,276
013FE:  MOVFF  26D,275
01402:  MOVFF  26C,274
01406:  MOVLW  02
01408:  MOVWF  x79
0140A:  MOVLW  70
0140C:  MOVWF  x78
0140E:  MOVLW  04
01410:  MOVWF  x7A
01412:  CLRF   x7B
01414:  CLRF   x7C
01416:  CLRF   x7D
01418:  MOVLB  0
0141A:  BRA    130E
0141C:  MOVF   01,F
0141E:  BNZ   1424
.................... 		/* on error */ 
.................... 		can_abort(); 
01420:  BSF    F6F.4
.................... 		can_init(); 
01422:  RCALL  0D5A
.................... //		timer.led_on_red=50; 
.................... 	} 
....................  
.................... } 
01424:  GOTO   1982 (RETURN)
....................  
....................  
.................... /* this is started after the bootloader is done loading or times out */ 
.................... void main(void) { 
*
017CE:  CLRF   FF8
017D0:  BCF    FD0.7
017D2:  BSF    07.7
017D4:  CLRF   FEA
017D6:  CLRF   FE9
017D8:  CLRF   1F
017DA:  BCF    FB8.3
017DC:  MOVLW  0C
017DE:  MOVWF  FAF
017E0:  MOVLW  A2
017E2:  MOVWF  FAC
017E4:  MOVLW  90
017E6:  MOVWF  FAB
017E8:  MOVLB  1
017EA:  CLRF   x5F
017EC:  CLRF   x5E
017EE:  BCF    x60.0
017F0:  CLRF   x61
017F2:  MOVLB  2
017F4:  CLRF   x68
017F6:  CLRF   x67
017F8:  MOVF   FC1,W
017FA:  ANDLW  C0
017FC:  IORLW  0F
017FE:  MOVWF  FC1
01800:  CLRF   19
01802:  CLRF   1A
.................... 	int8 last; 
....................  
.................... 	last=restart_cause(); 
01804:  MOVF   FD0,W
01806:  ANDLW  0F
01808:  BTFSS  FD0.4
0180A:  MOVLW  00
0180C:  BSF    FD0.0
0180E:  BSF    FD0.1
01810:  BSF    FD0.4
01812:  BSF    FD8.3
01814:  BSF    FD8.4
01816:  MOVWF  x69
....................  
.................... 	/* normal device startup */ 
.................... 	init(); 
01818:  MOVLB  0
0181A:  GOTO   0E66
.................... 	read_param_file(); 
0181E:  BRA    1096
.................... 	 
.................... 	write_default_param_file(); 
01820:  RCALL  1066
....................  
.................... 	/* initial watchdog restart. Subsequently only restart in live send */ 
.................... 	restart_wdt(); 
01822:  CLRWDT
....................  
.................... 	/* set relay to be initially off (indicating fault). vcs live send then controls there after */ 
.................... 	output_low(RELAY_RED); 
01824:  BCF    F93.5
01826:  BCF    F8A.5
....................  
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	modbus_init(); 
....................  
.................... 	enable_interrupts(GLOBAL); 
01828:  MOVLW  C0
0182A:  IORWF  FF2,F
....................  
.................... 	fprintf(rs232,"# (world) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
0182C:  MOVLW  D4
0182E:  MOVWF  FF6
01830:  MOVLW  09
01832:  MOVWF  FF7
01834:  MOVLW  13
01836:  MOVLB  2
01838:  MOVWF  x6A
0183A:  MOVLB  0
0183C:  RCALL  10EE
0183E:  MOVLW  FE
01840:  MOVWF  FF6
01842:  MOVLW  09
01844:  MOVWF  FF7
01846:  RCALL  1118
01848:  MOVLW  E9
0184A:  MOVWF  FF6
0184C:  MOVLW  09
0184E:  MOVWF  FF7
01850:  MOVLW  0D
01852:  MOVLB  2
01854:  MOVWF  x6A
01856:  MOVLB  0
01858:  RCALL  10EE
0185A:  MOVF   22,W
0185C:  BTFSS  F9E.4
0185E:  BRA    185C
01860:  MOVWF  FAD
01862:  MOVLW  10
01864:  MOVWF  FE9
01866:  MOVFF  24,26B
0186A:  MOVFF  23,26A
0186E:  BRA    113A
01870:  MOVLW  0D
01872:  BTFSS  F9E.4
01874:  BRA    1872
01876:  MOVWF  FAD
01878:  MOVLW  0A
0187A:  BTFSS  F9E.4
0187C:  BRA    187A
0187E:  MOVWF  FAD
.................... 	switch ( last ) { 
01880:  MOVLB  2
01882:  MOVF   x69,W
01884:  XORLW  07
01886:  MOVLB  0
01888:  BZ    18A4
0188A:  XORLW  0C
0188C:  BZ    18B0
0188E:  XORLW  04
01890:  BZ    18BC
01892:  XORLW  03
01894:  BZ    18C8
01896:  XORLW  02
01898:  BZ    18D4
0189A:  XORLW  0D
0189C:  BZ    18E0
0189E:  XORLW  03
018A0:  BZ    18EC
018A2:  BRA    18F8
.................... 		case WDT_TIMEOUT:       fprintf(rs232,"# WDT_TIMEOUT\r\n"); break; 
018A4:  MOVLW  08
018A6:  MOVWF  FF6
018A8:  MOVLW  0A
018AA:  MOVWF  FF7
018AC:  RCALL  1118
018AE:  BRA    1902
.................... 		case MCLR_FROM_SLEEP:   fprintf(rs232,"# MCLR_FROM_SLEEP\r\n"); break; 
018B0:  MOVLW  18
018B2:  MOVWF  FF6
018B4:  MOVLW  0A
018B6:  MOVWF  FF7
018B8:  RCALL  1118
018BA:  BRA    1902
.................... 		case MCLR_FROM_RUN:     fprintf(rs232,"# MCLR_FROM_RUN\r\n"); break; 
018BC:  MOVLW  2C
018BE:  MOVWF  FF6
018C0:  MOVLW  0A
018C2:  MOVWF  FF7
018C4:  RCALL  1118
018C6:  BRA    1902
.................... 		case NORMAL_POWER_UP:   fprintf(rs232,"# NORMAL_POWER_UP\r\n"); break; 
018C8:  MOVLW  3E
018CA:  MOVWF  FF6
018CC:  MOVLW  0A
018CE:  MOVWF  FF7
018D0:  RCALL  1118
018D2:  BRA    1902
.................... 		case BROWNOUT_RESTART:  fprintf(rs232,"# BROWNOUT_RESTART\r\n"); break; 
018D4:  MOVLW  52
018D6:  MOVWF  FF6
018D8:  MOVLW  0A
018DA:  MOVWF  FF7
018DC:  RCALL  1118
018DE:  BRA    1902
.................... 		case WDT_FROM_SLEEP:    fprintf(rs232,"# WDT_FROM_SLEEP\r\n"); break; 
018E0:  MOVLW  68
018E2:  MOVWF  FF6
018E4:  MOVLW  0A
018E6:  MOVWF  FF7
018E8:  RCALL  1118
018EA:  BRA    1902
.................... 		case RESET_INSTRUCTION: fprintf(rs232,"# RESET_INSTRUCTION\r\n"); break; 
018EC:  MOVLW  7C
018EE:  MOVWF  FF6
018F0:  MOVLW  0A
018F2:  MOVWF  FF7
018F4:  RCALL  1118
018F6:  BRA    1902
.................... 		default:                fprintf(rs232,"# UNKNOWN CAUSE\r\n"); 
018F8:  MOVLW  92
018FA:  MOVWF  FF6
018FC:  MOVLW  0A
018FE:  MOVWF  FF7
01900:  RCALL  1118
.................... 	} 
.................... 		 
....................  
.................... //	fprintf(rs232,"# (rs232) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
....................  
.................... 	/* fast red, yellow, green */ 
.................... 	timer.led_on_red  =200; 
01902:  MOVLB  1
01904:  CLRF   x59
01906:  MOVLW  C8
01908:  MOVWF  x58
.................... 	delay_ms(160); 
0190A:  MOVLW  A0
0190C:  MOVLB  2
0190E:  MOVWF  x6A
01910:  MOVLB  0
01912:  CALL   0AA4
.................... 	timer.led_on_green=400; 
01916:  MOVLW  01
01918:  MOVLB  1
0191A:  MOVWF  x5B
0191C:  MOVLW  90
0191E:  MOVWF  x5A
.................... 	delay_ms(160); 
01920:  MOVLW  A0
01922:  MOVLB  2
01924:  MOVWF  x6A
01926:  MOVLB  0
01928:  CALL   0AA4
.................... 	timer.led_on_red=0; 
0192C:  MOVLB  1
0192E:  CLRF   x59
01930:  CLRF   x58
.................... 	delay_ms(160); 
01932:  MOVLW  A0
01934:  MOVLB  2
01936:  MOVWF  x6A
01938:  MOVLB  0
0193A:  CALL   0AA4
.................... 	timer.led_on_green=0; 
0193E:  MOVLB  1
01940:  CLRF   x5B
01942:  CLRF   x5A
....................  
....................  
.................... 	last=0; 
01944:  MOVLB  2
01946:  CLRF   x69
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... //		restart_wdt(); 
....................  
.................... 		/* read data from our different sources */ 
.................... 		read_data_xrw2g(); 
01948:  MOVLB  0
0194A:  BRA    12D2
.................... 		 
.................... 		/* transmit buffer empty */ 
.................... 		if ( can_tbe() && timer.vcs_query_age>=25 ) { 
0194C:  MOVLB  F
0194E:  BTFSS  x40.3
01950:  BRA    195A
01952:  BTFSS  x30.3
01954:  BRA    195A
01956:  BTFSC  x20.3
01958:  BRA    1988
0195A:  MOVLB  1
0195C:  MOVF   x54,F
0195E:  BNZ   196C
01960:  MOVF   x53,W
01962:  SUBLW  18
01964:  BTFSS  FD8.0
01966:  BRA    196C
01968:  MOVLB  F
0196A:  BRA    1988
.................... 			/* loop through our list of registers */ 
.................... 			if ( last == VCS_N_REGISTERS ) 
0196C:  MOVLB  2
0196E:  MOVF   x69,W
01970:  SUBLW  28
01972:  BNZ   1976
.................... 				last=0; 
01974:  CLRF   x69
....................  
.................... 			send_can_query(last++); 
01976:  MOVF   x69,W
01978:  INCF   x69,F
0197A:  MOVWF  x6A
0197C:  MOVWF  x6B
0197E:  MOVLB  0
01980:  BRA    13E0
.................... 			timer.vcs_query_age=0; 
01982:  MOVLB  1
01984:  CLRF   x54
01986:  CLRF   x53
.................... 		} 
....................  
....................  
.................... 	    /* 
.................... 	     * every 10 seconds we send a sync pulse which should trigger another packet from XRW2G 
.................... 	     */ 
.................... 	    if ( timer.now_telem ) { 
01988:  MOVLB  1
0198A:  MOVF   x5D,F
0198C:  BZ    1998
.................... 			timer.now_telem=0; 
0198E:  CLRF   x5D
.................... //			output_high(SYNC_OUT); 
.................... 			live_send_vcs(); 
01990:  MOVLB  0
01992:  BRA    1496
.................... //			output_high(TP_ORANGE); 
.................... 	    } else { 
01994:  BRA    199E
01996:  MOVLB  1
.................... 			output_low(SYNC_OUT); 
01998:  BCF    F94.5
0199A:  BCF    F8B.5
0199C:  MOVLB  0
.................... //			output_low(TP_ORANGE); 
.................... 	    } 
....................  
....................  
.................... 		/* we have XRW2G data, and we haven't gotten any more in last 50 miliseconds */ 
.................... 		if ( 0 != timer.xrw2g_buff_pos && timer.xrw2g_age > 50 ) { 
0199E:  MOVF   xB0,F
019A0:  BZ    19AE
019A2:  MOVF   xB2,F
019A4:  BNZ   19AC
019A6:  MOVF   xB1,W
019A8:  SUBLW  32
019AA:  BC    19AE
.................... #if 1 
.................... 			live_send_xrw2g(); 
019AC:  BRA    1676
.................... #else 
.................... 			fprintf(rs232,"# XRW2G %c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			if ( 0 == live_send_xrw2g() ) { 
.................... 				fprintf(rs232,"error-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} else { 
.................... 				fprintf(rs232,"success-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} 
.................... 			timer.telem_age=0; 
.................... #endif 
.................... 		} 
....................  
.................... 	} 
019AE:  BRA    194A
.................... } 
....................  
019B0:  BRA    19B0

Configuration Fuses:
   Word  1: 4F00   FCMEN NOIESO
   Word  2: 1A19   NOPUT NOBROWNOUT BORV21 NOWDT WDT8192
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
