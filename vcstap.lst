CCS PCH C Compiler, Version 4.135, 4375               29-Aug-16 15:19

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\vcstap\vcstap.lst

               ROM used: 6332 bytes (10%)
                         Largest free fragment is 58628
               RAM used: 619 (19%) at main() level
                         847 (26%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   031E
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   0350
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   041A
00078:  BTFSS  FA3.7
0007A:  GOTO   0084
0007E:  BTFSC  FA4.7
00080:  GOTO   0000
00084:  BTFSS  FA3.1
00086:  GOTO   0090
0008A:  BTFSC  FA4.1
0008C:  GOTO   083A
00090:  BTFSS  FA3.0
00092:  GOTO   009C
00096:  BTFSC  FA4.0
00098:  GOTO   0688
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVF   04,W
000E0:  MOVFF  06,FE0
000E4:  MOVFF  05,FD8
000E8:  RETFIE 0
*
0FDBC:  GOTO   176C
.................... #include "vcstap.h" 
.................... #include <18F2680.h> 
.................... //////// Standard Header file for the PIC18F2680 device //////////////// 
.................... #device PIC18F2680 
.................... #list 
....................  
.................... #device ADC=10 
.................... #device *=16 
....................  
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */ 
.................... #build(reset=0xfdbc:0xfdbf) 
.................... #org 0xfdc0,0xffff {} 
....................  
....................  
.................... /* 
.................... 		#define		BLPLP		9			;bootloader placement, pages from end 
.................... 		#define		BLSIZEP		9			;bootloader size [pages], used by bootloader protection	 
.................... */ 
....................  
....................  
.................... /* EEPROM locations */ 
.................... #define PARAM_CRC_ADDRESS 0x00 
.................... #define PARAM_ADDRESS     0x01 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#FUSES INTRC_IO,NOPROTECT,WDT8192, NOIESO, NODEBUG 
.................... #use delay(clock=8000000, restart_wdt) 
*
00A20:  MOVLW  02
00A22:  MOVWF  FEA
00A24:  MOVLW  6A
00A26:  MOVWF  FE9
00A28:  MOVF   FEF,W
00A2A:  BZ    0A4E
00A2C:  MOVLW  02
00A2E:  MOVWF  01
00A30:  MOVLW  BF
00A32:  MOVWF  00
00A34:  CLRWDT
00A36:  DECFSZ 00,F
00A38:  BRA    0A34
00A3A:  DECFSZ 01,F
00A3C:  BRA    0A30
00A3E:  MOVLW  96
00A40:  MOVWF  00
00A42:  DECFSZ 00,F
00A44:  BRA    0A42
00A46:  BRA    0A48
00A48:  CLRWDT
00A4A:  DECFSZ FEF,F
00A4C:  BRA    0A2C
00A4E:  RETURN 0
....................  
.................... /* 
....................  Sensors  WorldData R33 R34 R35 R36 XBee | UART1    | UART2 | SCI_UART                  | STATUS 
....................  on-board Ethernet  DNS DNS DNS DNS DNS  | inverter | world | (onboard XRW2G)           | done 
....................  802.15.4 Ethernet  0   DNS DNS DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  802.15.4 802.15.4  0   0   0   DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  on-board 802.15.4  DNS 0   0   DNS YES  | inverter | world | (onboard XRW2G)           | done 
....................  */ 
....................  
....................  
....................  
.................... #use rs232(UART1,stream=rs232,baud=9600,xmit=PIN_C6,rcv=PIN_C7, errors)	 /* also connected to XPort transmit ... xport receive not connected */ 
*
003D4:  BTFSS  F9E.5
003D6:  BRA    03D4
003D8:  MOVFF  FAB,1F
003DC:  MOVFF  FAE,01
003E0:  BTFSS  1F.1
003E2:  BRA    03E8
003E4:  BCF    FAB.4
003E6:  BSF    FAB.4
003E8:  GOTO   0420 (RETURN)
*
0141A:  BTFSS  F9E.4
0141C:  BRA    141A
0141E:  MOVWF  FAD
01420:  RETURN 0
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST) 
*
00A50:  MOVLW  08
00A52:  MOVWF  01
00A54:  NOP   
00A56:  BCF    F8B.3
00A58:  BCF    F94.3
00A5A:  NOP   
00A5C:  MOVLB  2
00A5E:  RLCF   x75,F
00A60:  BCF    F8B.4
00A62:  BTFSC  FD8.0
00A64:  BSF    F94.4
00A66:  BTFSS  FD8.0
00A68:  BCF    F94.4
00A6A:  BSF    F94.3
00A6C:  BTFSS  F82.3
00A6E:  BRA    0A6C
00A70:  DECFSZ 01,F
00A72:  BRA    0A76
00A74:  BRA    0A7A
00A76:  MOVLB  0
00A78:  BRA    0A54
00A7A:  NOP   
00A7C:  BCF    F8B.3
00A7E:  BCF    F94.3
00A80:  NOP   
00A82:  BSF    F94.4
00A84:  NOP   
00A86:  NOP   
00A88:  BSF    F94.3
00A8A:  BTFSS  F82.3
00A8C:  BRA    0A8A
00A8E:  CLRF   01
00A90:  NOP   
00A92:  BTFSC  F82.4
00A94:  BSF    01.0
00A96:  BCF    F8B.3
00A98:  BCF    F94.3
00A9A:  BCF    F8B.4
00A9C:  BCF    F94.4
00A9E:  MOVLB  0
00AA0:  RETURN 0
*
0116E:  MOVLW  08
01170:  MOVLB  2
01172:  MOVWF  x6E
01174:  MOVFF  00,26F
01178:  BSF    F94.4
0117A:  NOP   
0117C:  BSF    F94.3
0117E:  BTFSS  F82.3
01180:  BRA    117E
01182:  BTFSC  F82.4
01184:  BSF    FD8.0
01186:  BTFSS  F82.4
01188:  BCF    FD8.0
0118A:  RLCF   01,F
0118C:  NOP   
0118E:  BCF    F94.3
01190:  BCF    F8B.3
01192:  DECFSZ x6E,F
01194:  BRA    1178
01196:  BSF    F94.4
01198:  NOP   
0119A:  BCF    F8B.4
0119C:  MOVF   x6F,W
0119E:  BTFSS  FD8.2
011A0:  BCF    F94.4
011A2:  NOP   
011A4:  BSF    F94.3
011A6:  BTFSS  F82.3
011A8:  BRA    11A6
011AA:  NOP   
011AC:  BCF    F8B.3
011AE:  BCF    F94.3
011B0:  NOP   
011B2:  BCF    F8B.4
011B4:  BCF    F94.4
011B6:  MOVLB  0
011B8:  GOTO   122A (RETURN)
....................  
....................  
....................  
....................  
.................... #use standard_io(A) 
.................... #use standard_io(B) 
.................... #use standard_io(C) 
....................  
.................... #define LED_GREEN                  PIN_B4 
.................... // #define LED_RED                    PIN_B5 repurposed as relay 
.................... #define RELAY_RED                  PIN_B5 
....................  
.................... #define XBEE_SLEEP                 PIN_A0 
.................... #define XBEE_NRTS                  PIN_A1 
.................... #define XBEE_NCTS                  PIN_A2 
....................  
.................... #define SYNC_OUT                   PIN_C5 /* really labeled sync in */ 
....................  
.................... #define UART_IRQ                   PIN_B0 
.................... #define UART_RESET                 PIN_B1 
....................  
.................... #define TP14                       PIN_B3 
.................... #define TP15                       PIN_B2 
....................  
....................  
.................... #define TP_RED     PIN_B6 
.................... #define TP_ORANGE  PIN_B7 
....................  
....................  
.................... //#byte ANCON0=GETENV("SFR:ancon0") 
.................... //#byte ANCON1=GETENV("SFR:ancon1") 
....................  
....................  
....................  
.................... #define SERIAL_PREFIX_DEFAULT      'Z' 
.................... #define SERIAL_NUMBER_DEFAULT      6543 
....................  
.................... #define SENSOR_SOURCE_ONBOARD  0 
.................... #define SENSOR_SOURCE_WIRELESS 1 
....................  
....................  
.................... /* can baud rate registers */ 
.................... //#byte BRGCON1=GETENV("SFR:brgcon1") 
.................... //#byte BRGCON2=GETENV("SFR:brgcon2") 
.................... //#byte BRGCON3=GETENV("SFR:brgcon3") 
....................  
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 revision; 
....................  
.................... 	int8 modbus_address; 
....................  
.................... 	int8  serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int8  pair_serial_prefix; 
.................... 	int16 pair_serial_number; 
....................  
.................... 	int8  sensor_source; 
.................... 	int8  world_to_xbee; 
.................... 	int8  world_to_xport; 
.................... } struct_config; 
....................  
.................... #define VCS_N_REGISTERS 40 
....................  
.................... typedef struct { 
.................... 	int8  modbus_enable; 
.................... 	int8  modbus_last_error; 
.................... 	int8  factory_unlocked; 
.................... 	int16 telem_age; 
....................  
.................... 	int8  xrw2g_packet[128]; 
.................... 	int8  xrw2g_buff_pos; 
.................... 	int16 xrw2g_age; 
....................  
.................... 	/* VCS data as updated by the CAN bus */ 
.................... 	int8 vcs_register     [VCS_N_REGISTERS*4]; /* 40 32-bit registers */ 
.................... 	int16 vcs_query_age; 
.................... 	int8 vcs_read_lock; /* 1 means nobody can modify the data */ 
.................... 	int16 vcs_last_data_age; 
....................  
.................... 	int16 led_on_red; 
.................... 	int16 led_on_green; 
....................  
.................... 	int8 dump_register; 
....................  
.................... 	int8 now_telem; 
.................... } struct_timer; 
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_timer  timer; 
....................  
.................... #include "can.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "can.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define CAN_DO_DEBUG                FALSE 
....................  
.................... #define CAN_USE_EXTENDED_ID         FALSE 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH    0  //synchronized jump width (def: 1 x Tq) 
.................... #define CAN_BRG_PRESCALAR           4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #define CAN_BRG_SEG_2_PHASE_TS      TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #define CAN_BRG_SAM                 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #define CAN_BRG_PHASE_SEGMENT_1     5 //phase segment 1 (def: 6 x Tq) 
.................... #define CAN_BRG_PROPAGATION_TIME    2 //propagation time select (def: 3 x Tq) 
.................... #define CAN_BRG_WAKE_FILTER         FALSE   //selects can bus line filter for wake up bit 
.................... #define CAN_BRG_PHASE_SEGMENT_2     5 //phase segment 2 time select (def: 6 x Tq) 
.................... #define CAN_USE_RX_DOUBLE_BUFFER    TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #define CAN_ENABLE_DRIVE_HIGH       1      // required by CTIW CAN / VCSTAP 
.................... #define CAN_ENABLE_CAN_CAPTURE      0 
.................... #define CAN_ENABLE_CANTX2           0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #define CAN_CANTX2_SOURCE           0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
....................  
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
00CE0:  MOVLW  04
00CE2:  MOVLB  2
00CE4:  MOVWF  x74
00CE6:  MOVLB  0
00CE8:  RCALL  0B78
....................    can_set_baud(); 
00CEA:  BRA    0B9E
....................  
....................    RXB0CON=0; 
00CEC:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
00CEE:  MOVLW  9F
00CF0:  ANDWF  F60,W
00CF2:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
00CF4:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
00CF6:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
00CFA:  BSF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
00CFC:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
00CFE:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
00D00:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
00D02:  MOVLW  0F
00D04:  MOVLB  2
00D06:  MOVWF  x83
00D08:  MOVLW  1B
00D0A:  MOVWF  x82
00D0C:  CLRF   x87
00D0E:  CLRF   x86
00D10:  CLRF   x85
00D12:  CLRF   x84
00D14:  CLRF   x88
00D16:  MOVLB  0
00D18:  RCALL  0BAC
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
00D1A:  MOVLW  0F
00D1C:  MOVLB  2
00D1E:  MOVWF  x83
00D20:  MOVLW  03
00D22:  MOVWF  x82
00D24:  CLRF   x87
00D26:  CLRF   x86
00D28:  CLRF   x85
00D2A:  CLRF   x84
00D2C:  CLRF   x88
00D2E:  MOVLB  0
00D30:  RCALL  0BAC
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
00D32:  MOVLW  0F
00D34:  MOVLB  2
00D36:  MOVWF  x83
00D38:  MOVLW  07
00D3A:  MOVWF  x82
00D3C:  CLRF   x87
00D3E:  CLRF   x86
00D40:  CLRF   x85
00D42:  CLRF   x84
00D44:  CLRF   x88
00D46:  MOVLB  0
00D48:  RCALL  0BAC
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
00D4A:  MOVLW  0F
00D4C:  MOVLB  2
00D4E:  MOVWF  x83
00D50:  MOVLW  1F
00D52:  MOVWF  x82
00D54:  CLRF   x87
00D56:  CLRF   x86
00D58:  CLRF   x85
00D5A:  CLRF   x84
00D5C:  CLRF   x88
00D5E:  MOVLB  0
00D60:  RCALL  0BAC
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
00D62:  MOVLW  0F
00D64:  MOVLB  2
00D66:  MOVWF  x83
00D68:  MOVLW  0B
00D6A:  MOVWF  x82
00D6C:  CLRF   x87
00D6E:  CLRF   x86
00D70:  CLRF   x85
00D72:  CLRF   x84
00D74:  CLRF   x88
00D76:  MOVLB  0
00D78:  RCALL  0BAC
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
00D7A:  MOVLW  0F
00D7C:  MOVLB  2
00D7E:  MOVWF  x83
00D80:  MOVWF  x82
00D82:  CLRF   x87
00D84:  CLRF   x86
00D86:  CLRF   x85
00D88:  CLRF   x84
00D8A:  CLRF   x88
00D8C:  MOVLB  0
00D8E:  RCALL  0BAC
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
00D90:  MOVLW  0F
00D92:  MOVLB  2
00D94:  MOVWF  x83
00D96:  MOVLW  13
00D98:  MOVWF  x82
00D9A:  CLRF   x87
00D9C:  CLRF   x86
00D9E:  CLRF   x85
00DA0:  CLRF   x84
00DA2:  CLRF   x88
00DA4:  MOVLB  0
00DA6:  RCALL  0BAC
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
00DA8:  MOVLW  0F
00DAA:  MOVLB  2
00DAC:  MOVWF  x83
00DAE:  MOVLW  17
00DB0:  MOVWF  x82
00DB2:  CLRF   x87
00DB4:  CLRF   x86
00DB6:  CLRF   x85
00DB8:  CLRF   x84
00DBA:  CLRF   x88
00DBC:  MOVLB  0
00DBE:  RCALL  0BAC
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
00DC0:  MOVF   F93,W
00DC2:  ANDLW  FB
00DC4:  IORLW  08
00DC6:  MOVLB  2
00DC8:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
00DCA:  CLRF   x74
00DCC:  MOVLB  0
00DCE:  RCALL  0B78
.................... } 
00DD0:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
.................... /* 250 kbps from 8 MHz oscillator */ 
.................... 	BRGCON1=0x00; 
*
00B9E:  CLRF   F70
.................... 	BRGCON2=0xB8; 
00BA0:  MOVLW  B8
00BA2:  MOVWF  F71
.................... 	BRGCON3=0x05; 
00BA4:  MOVLW  05
00BA6:  MOVWF  F72
.................... #if 0 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
....................    BRGCON2.sam=CAN_BRG_SAM; 
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
.................... #endif 
.................... } 
00BA8:  GOTO   0CEC (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
00B78:  MOVLB  2
00B7A:  SWAPF  x74,W
00B7C:  ANDLW  70
00B7E:  MOVWF  00
00B80:  BCF    FD8.0
00B82:  RLCF   00,F
00B84:  MOVLW  1F
00B86:  ANDWF  F6F,W
00B88:  IORWF  00,W
00B8A:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
00B8C:  MOVFF  F6E,00
00B90:  SWAPF  00,F
00B92:  RRCF   00,W
00B94:  ANDLW  07
00B96:  SUBWF  x74,W
00B98:  BNZ   0B8C
.................... } 
00B9A:  MOVLB  0
00B9C:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
00BAC:  MOVFF  283,28A
00BB0:  MOVFF  282,289
....................  
....................    if (ext) {  //extended 
00BB4:  MOVLB  2
00BB6:  MOVF   x88,F
00BB8:  BZ    0C5E
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
00BBA:  MOVFF  289,FE9
00BBE:  MOVFF  28A,FEA
00BC2:  MOVFF  284,FEF
....................  
....................       //eidh 
....................       ptr--; 
00BC6:  MOVF   x89,W
00BC8:  BTFSC  FD8.2
00BCA:  DECF   x8A,F
00BCC:  DECF   x89,F
....................       *ptr=make8(id,1); //8:15 
00BCE:  MOVFF  289,FE9
00BD2:  MOVFF  28A,FEA
00BD6:  MOVFF  285,FEF
....................  
....................       //sidl 
....................       ptr--; 
00BDA:  MOVF   x89,W
00BDC:  BTFSC  FD8.2
00BDE:  DECF   x8A,F
00BE0:  DECF   x89,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
00BE2:  MOVFF  289,FE9
00BE6:  MOVFF  28A,FEA
00BEA:  MOVF   x86,W
00BEC:  ANDLW  03
00BEE:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
00BF0:  MOVFF  289,FE9
00BF4:  MOVFF  28A,FEA
00BF8:  MOVFF  286,00
00BFC:  RLCF   00,F
00BFE:  RLCF   00,F
00C00:  RLCF   00,F
00C02:  MOVLW  F8
00C04:  ANDWF  00,F
00C06:  MOVF   00,W
00C08:  ANDLW  E0
00C0A:  IORWF  FEF,W
00C0C:  MOVWF  FEF
....................       *ptr|=0x08; 
00C0E:  MOVFF  289,FE9
00C12:  MOVFF  28A,FEA
00C16:  MOVF   FEF,W
00C18:  IORLW  08
00C1A:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
00C1C:  MOVF   x89,W
00C1E:  BTFSC  FD8.2
00C20:  DECF   x8A,F
00C22:  DECF   x89,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
00C24:  MOVFF  289,FE9
00C28:  MOVFF  28A,FEA
00C2C:  MOVFF  286,00
00C30:  SWAPF  00,F
00C32:  RRCF   00,F
00C34:  MOVLW  07
00C36:  ANDWF  00,F
00C38:  MOVF   00,W
00C3A:  ANDLW  07
00C3C:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
00C3E:  MOVFF  289,FE9
00C42:  MOVFF  28A,FEA
00C46:  MOVFF  287,00
00C4A:  RLCF   00,F
00C4C:  RLCF   00,F
00C4E:  RLCF   00,F
00C50:  MOVLW  F8
00C52:  ANDWF  00,F
00C54:  MOVF   00,W
00C56:  ANDLW  F8
00C58:  IORWF  FEF,W
00C5A:  MOVWF  FEF
....................    } 
....................    else {   //standard 
00C5C:  BRA    0CDC
....................       //eidl 
....................       *ptr=0; 
00C5E:  MOVFF  289,FE9
00C62:  MOVFF  28A,FEA
00C66:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
00C68:  MOVF   x89,W
00C6A:  BTFSC  FD8.2
00C6C:  DECF   x8A,F
00C6E:  DECF   x89,F
....................       *ptr=0; 
00C70:  MOVFF  289,FE9
00C74:  MOVFF  28A,FEA
00C78:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
00C7A:  MOVF   x89,W
00C7C:  BTFSC  FD8.2
00C7E:  DECF   x8A,F
00C80:  DECF   x89,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
00C82:  MOVFF  289,FE9
00C86:  MOVFF  28A,FEA
00C8A:  MOVFF  284,00
00C8E:  SWAPF  00,F
00C90:  RLCF   00,F
00C92:  MOVLW  E0
00C94:  ANDWF  00,F
00C96:  MOVF   00,W
00C98:  ANDLW  E0
00C9A:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
00C9C:  MOVF   x89,W
00C9E:  BTFSC  FD8.2
00CA0:  DECF   x8A,F
00CA2:  DECF   x89,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
00CA4:  MOVFF  289,FE9
00CA8:  MOVFF  28A,FEA
00CAC:  MOVFF  284,00
00CB0:  RRCF   00,F
00CB2:  RRCF   00,F
00CB4:  RRCF   00,F
00CB6:  MOVLW  1F
00CB8:  ANDWF  00,F
00CBA:  MOVF   00,W
00CBC:  ANDLW  1F
00CBE:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
00CC0:  MOVFF  289,FE9
00CC4:  MOVFF  28A,FEA
00CC8:  MOVFF  285,00
00CCC:  SWAPF  00,F
00CCE:  RLCF   00,F
00CD0:  MOVLW  E0
00CD2:  ANDWF  00,F
00CD4:  MOVF   00,W
00CD6:  ANDLW  E0
00CD8:  IORWF  FEF,W
00CDA:  MOVWF  FEF
....................    } 
.................... } 
00CDC:  MOVLB  0
00CDE:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
00490:  MOVLB  3
00492:  CLRF   x47
00494:  CLRF   x46
00496:  CLRF   x45
00498:  CLRF   x44
....................    ptr=addr; 
0049A:  MOVFF  342,349
0049E:  MOVFF  341,348
....................  
....................    if (ext) { 
004A2:  MOVF   x43,F
004A4:  BTFSC  FD8.2
004A6:  BRA    05CE
....................       ret=*ptr;  //eidl 
004A8:  MOVFF  349,03
004AC:  MOVFF  348,FE9
004B0:  MOVFF  349,FEA
004B4:  MOVFF  FEF,00
004B8:  CLRF   01
004BA:  CLRF   02
004BC:  CLRF   03
004BE:  MOVFF  03,347
004C2:  MOVFF  02,346
004C6:  MOVFF  01,345
004CA:  MOVFF  00,344
....................  
....................       ptr--;     //eidh 
004CE:  MOVF   x48,W
004D0:  BTFSC  FD8.2
004D2:  DECF   x49,F
004D4:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 8); 
004D6:  MOVFF  348,FE9
004DA:  MOVFF  349,FEA
004DE:  MOVF   FEF,W
004E0:  CLRF   x4C
004E2:  CLRF   x4B
004E4:  MOVWF  x4A
004E6:  CLRF   00
004E8:  MOVF   00,W
004EA:  IORWF  x44,F
004EC:  MOVF   x4A,W
004EE:  IORWF  x45,F
004F0:  MOVF   x4B,W
004F2:  IORWF  x46,F
004F4:  MOVF   x4C,W
004F6:  IORWF  x47,F
....................  
....................       ptr--;     //sidl 
004F8:  MOVF   x48,W
004FA:  BTFSC  FD8.2
004FC:  DECF   x49,F
004FE:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
00500:  MOVFF  348,FE9
00504:  MOVFF  349,FEA
00508:  MOVF   FEF,W
0050A:  CLRF   x4D
0050C:  CLRF   x4C
0050E:  CLRF   x4B
00510:  MOVWF  x4A
00512:  MOVLW  03
00514:  ANDWF  x4A,F
00516:  CLRF   x4B
00518:  CLRF   x4C
0051A:  CLRF   x4D
0051C:  CLRF   00
0051E:  CLRF   01
00520:  MOVF   00,W
00522:  IORWF  x44,F
00524:  MOVF   01,W
00526:  IORWF  x45,F
00528:  MOVF   x4A,W
0052A:  IORWF  x46,F
0052C:  MOVF   x4B,W
0052E:  IORWF  x47,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
00530:  MOVFF  348,FE9
00534:  MOVFF  349,FEA
00538:  MOVF   FEF,W
0053A:  CLRF   x4D
0053C:  CLRF   x4C
0053E:  CLRF   x4B
00540:  MOVWF  x4A
00542:  MOVLW  E0
00544:  ANDWF  x4A,F
00546:  CLRF   x4B
00548:  CLRF   x4C
0054A:  CLRF   x4D
0054C:  CLRF   00
0054E:  RLCF   x4A,W
00550:  MOVWF  01
00552:  RLCF   x4B,W
00554:  MOVWF  02
00556:  RLCF   x4C,W
00558:  MOVWF  03
0055A:  RLCF   01,F
0055C:  RLCF   02,F
0055E:  RLCF   03,F
00560:  RLCF   01,F
00562:  RLCF   02,F
00564:  RLCF   03,F
00566:  RLCF   01,F
00568:  RLCF   02,F
0056A:  RLCF   03,F
0056C:  RLCF   01,F
0056E:  RLCF   02,F
00570:  RLCF   03,F
00572:  MOVLW  E0
00574:  ANDWF  01,F
00576:  MOVF   00,W
00578:  IORWF  x44,F
0057A:  MOVF   01,W
0057C:  IORWF  x45,F
0057E:  MOVF   02,W
00580:  IORWF  x46,F
00582:  MOVF   03,W
00584:  IORWF  x47,F
....................  
....................       ptr--;     //sidh 
00586:  MOVF   x48,W
00588:  BTFSC  FD8.2
0058A:  DECF   x49,F
0058C:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 21); 
0058E:  MOVFF  348,FE9
00592:  MOVFF  349,FEA
00596:  MOVF   FEF,W
00598:  CLRF   x4B
0059A:  MOVWF  x4A
0059C:  CLRF   00
0059E:  CLRF   01
005A0:  RLCF   x4A,W
005A2:  MOVWF  02
005A4:  RLCF   x4B,W
005A6:  MOVWF  03
005A8:  RLCF   02,F
005AA:  RLCF   03,F
005AC:  RLCF   02,F
005AE:  RLCF   03,F
005B0:  RLCF   02,F
005B2:  RLCF   03,F
005B4:  RLCF   02,F
005B6:  RLCF   03,F
005B8:  MOVLW  E0
005BA:  ANDWF  02,F
005BC:  MOVF   00,W
005BE:  IORWF  x44,F
005C0:  MOVF   01,W
005C2:  IORWF  x45,F
005C4:  MOVF   02,W
005C6:  IORWF  x46,F
005C8:  MOVF   03,W
005CA:  IORWF  x47,F
....................  
....................    } 
....................    else { 
005CC:  BRA    0674
....................       ptr-=2;    //sidl 
005CE:  MOVLW  02
005D0:  SUBWF  x48,F
005D2:  MOVLW  00
005D4:  SUBWFB x49,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
005D6:  MOVFF  348,FE9
005DA:  MOVFF  349,FEA
005DE:  MOVF   FEF,W
005E0:  CLRF   x4D
005E2:  CLRF   x4C
005E4:  CLRF   x4B
005E6:  MOVWF  x4A
005E8:  MOVLW  E0
005EA:  ANDWF  x4A,F
005EC:  CLRF   x4B
005EE:  CLRF   x4C
005F0:  CLRF   x4D
005F2:  RRCF   x4D,W
005F4:  MOVWF  x47
005F6:  RRCF   x4C,W
005F8:  MOVWF  x46
005FA:  RRCF   x4B,W
005FC:  MOVWF  x45
005FE:  RRCF   x4A,W
00600:  MOVWF  x44
00602:  RRCF   x47,F
00604:  RRCF   x46,F
00606:  RRCF   x45,F
00608:  RRCF   x44,F
0060A:  RRCF   x47,F
0060C:  RRCF   x46,F
0060E:  RRCF   x45,F
00610:  RRCF   x44,F
00612:  RRCF   x47,F
00614:  RRCF   x46,F
00616:  RRCF   x45,F
00618:  RRCF   x44,F
0061A:  RRCF   x47,F
0061C:  RRCF   x46,F
0061E:  RRCF   x45,F
00620:  RRCF   x44,F
00622:  MOVLW  07
00624:  ANDWF  x47,F
....................  
....................       ptr--;     //sidh 
00626:  MOVF   x48,W
00628:  BTFSC  FD8.2
0062A:  DECF   x49,F
0062C:  DECF   x48,F
....................       ret|=((unsigned int32)*ptr << 3); 
0062E:  MOVFF  348,FE9
00632:  MOVFF  349,FEA
00636:  MOVF   FEF,W
00638:  CLRF   x4D
0063A:  CLRF   x4C
0063C:  CLRF   x4B
0063E:  MOVWF  x4A
00640:  RLCF   x4A,W
00642:  MOVWF  00
00644:  RLCF   x4B,W
00646:  MOVWF  01
00648:  RLCF   x4C,W
0064A:  MOVWF  02
0064C:  RLCF   x4D,W
0064E:  MOVWF  03
00650:  RLCF   00,F
00652:  RLCF   01,F
00654:  RLCF   02,F
00656:  RLCF   03,F
00658:  RLCF   00,F
0065A:  RLCF   01,F
0065C:  RLCF   02,F
0065E:  RLCF   03,F
00660:  MOVLW  F8
00662:  ANDWF  00,F
00664:  MOVF   00,W
00666:  IORWF  x44,F
00668:  MOVF   01,W
0066A:  IORWF  x45,F
0066C:  MOVF   02,W
0066E:  IORWF  x46,F
00670:  MOVF   03,W
00672:  IORWF  x47,F
....................    } 
....................  
....................    return(ret); 
00674:  MOVFF  344,00
00678:  MOVFF  345,01
0067C:  MOVFF  346,02
00680:  MOVFF  347,03
.................... } 
00684:  MOVLB  0
00686:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
0129A:  MOVLW  0F
0129C:  MOVLB  2
0129E:  MOVWF  x80
012A0:  MOVLW  66
012A2:  MOVWF  x7F
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
012A4:  MOVLB  F
012A6:  BTFSC  x40.3
012A8:  BRA    12BA
....................       CANCON.win=CAN_WIN_TX0; 
012AA:  MOVLW  F1
012AC:  ANDWF  F6F,W
012AE:  IORLW  08
012B0:  MOVWF  F6F
....................       port=0; 
012B2:  MOVLB  2
012B4:  CLRF   x81
....................    } 
....................    else if (!TXB1CON.txreq) { 
012B6:  BRA    12EE
012B8:  MOVLB  F
012BA:  BTFSC  x30.3
012BC:  BRA    12D0
....................       CANCON.win=CAN_WIN_TX1; 
012BE:  MOVLW  F1
012C0:  ANDWF  F6F,W
012C2:  IORLW  06
012C4:  MOVWF  F6F
....................       port=1; 
012C6:  MOVLW  01
012C8:  MOVLB  2
012CA:  MOVWF  x81
....................    } 
....................    else if (!TXB2CON.txreq) { 
012CC:  BRA    12EE
012CE:  MOVLB  F
012D0:  BTFSC  x20.3
012D2:  BRA    12E6
....................       CANCON.win=CAN_WIN_TX2; 
012D4:  MOVLW  F1
012D6:  ANDWF  F6F,W
012D8:  IORLW  04
012DA:  MOVWF  F6F
....................       port=2; 
012DC:  MOVLW  02
012DE:  MOVLB  2
012E0:  MOVWF  x81
....................    } 
....................    else { 
012E2:  BRA    12EE
012E4:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
012E6:  MOVLW  00
012E8:  MOVWF  01
012EA:  BRA    1366
012EC:  MOVLB  2
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
012EE:  MOVF   x7B,W
012F0:  ANDLW  03
012F2:  MOVWF  00
012F4:  MOVLW  FC
012F6:  ANDWF  F60,W
012F8:  IORWF  00,W
012FA:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
012FC:  MOVLW  0F
012FE:  MOVWF  x83
01300:  MOVLW  64
01302:  MOVWF  x82
01304:  MOVFF  277,287
01308:  MOVFF  276,286
0130C:  MOVFF  275,285
01310:  MOVFF  274,284
01314:  MOVFF  27C,288
01318:  MOVLB  0
0131A:  RCALL  0BAC
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
0131C:  MOVFF  27A,F65
....................    TXBaDLC.rtr=rtr; 
01320:  BCF    F65.6
01322:  MOVLB  2
01324:  BTFSC  x7D.0
01326:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01328:  CLRF   x7E
0132A:  MOVF   x7A,W
0132C:  SUBWF  x7E,W
0132E:  BC    1358
....................       *txd0=*data; 
01330:  MOVFF  278,FE9
01334:  MOVFF  279,FEA
01338:  MOVFF  FEF,284
0133C:  MOVFF  280,FEA
01340:  MOVFF  27F,FE9
01344:  MOVFF  284,FEF
....................       txd0++; 
01348:  INCF   x7F,F
0134A:  BTFSC  FD8.2
0134C:  INCF   x80,F
....................       data++; 
0134E:  INCF   x78,F
01350:  BTFSC  FD8.2
01352:  INCF   x79,F
....................     } 
01354:  INCF   x7E,F
01356:  BRA    132A
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01358:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
0135A:  MOVLW  F1
0135C:  ANDWF  F6F,W
0135E:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
01360:  MOVLW  01
01362:  MOVWF  01
01364:  MOVLB  F
.................... } 
01366:  MOVLB  0
01368:  GOTO   13A8 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
00696:  BTFSS  F60.7
00698:  BRA    06C8
*
00848:  BTFSS  F60.7
0084A:  BRA    087A
....................         CANCON.win=CAN_WIN_RX0; 
*
0069A:  MOVLW  F1
0069C:  ANDWF  F6F,W
0069E:  MOVWF  F6F
*
0084C:  MOVLW  F1
0084E:  ANDWF  F6F,W
00850:  MOVWF  F6F
....................         stat.buffer=0; 
*
006A0:  BCF    x34.4
*
00852:  BCF    x34.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
006A2:  BCF    FA4.0
*
00854:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
006A4:  BCF    x34.0
006A6:  BTFSC  F74.7
006A8:  BSF    x34.0
*
00856:  BCF    x34.0
00858:  BTFSC  F74.7
0085A:  BSF    x34.0
....................         COMSTAT.rx0ovfl=0; 
*
006AA:  BCF    F74.7
*
0085C:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
006AC:  BTFSS  F60.2
006AE:  BRA    06C6
*
0085E:  BTFSS  F60.2
00860:  BRA    0878
....................          stat.filthit=RXB0CON.filthit0; 
*
006B0:  MOVLW  00
006B2:  BTFSC  F60.0
006B4:  MOVLW  01
006B6:  ANDLW  07
006B8:  MOVWF  00
006BA:  BCF    FD8.0
006BC:  RLCF   00,F
006BE:  MOVLW  F1
006C0:  ANDWF  x34,W
006C2:  IORWF  00,W
006C4:  MOVWF  x34
*
00862:  MOVLW  00
00864:  BTFSC  F60.0
00866:  MOVLW  01
00868:  ANDLW  07
0086A:  MOVWF  00
0086C:  BCF    FD8.0
0086E:  RLCF   00,F
00870:  MOVLW  F1
00872:  ANDWF  x34,W
00874:  IORWF  00,W
00876:  MOVWF  x34
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
006C6:  BRA    0708
006C8:  MOVLB  F
006CA:  BTFSS  x50.7
006CC:  BRA    0700
*
00878:  BRA    08BA
0087A:  MOVLB  F
0087C:  BTFSS  x50.7
0087E:  BRA    08B2
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
006CE:  MOVLW  F1
006D0:  ANDWF  F6F,W
006D2:  IORLW  0A
006D4:  MOVWF  F6F
*
00880:  MOVLW  F1
00882:  ANDWF  F6F,W
00884:  IORLW  0A
00886:  MOVWF  F6F
....................         stat.buffer=1; 
*
006D6:  MOVLB  3
006D8:  BSF    x34.4
*
00888:  MOVLB  3
0088A:  BSF    x34.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
006DA:  BCF    FA4.1
*
0088C:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
006DC:  BCF    x34.0
006DE:  BTFSC  F74.6
006E0:  BSF    x34.0
*
0088E:  BCF    x34.0
00890:  BTFSC  F74.6
00892:  BSF    x34.0
....................         COMSTAT.rx1ovfl=0; 
*
006E2:  BCF    F74.6
*
00894:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
006E4:  MOVLB  F
006E6:  MOVF   x50,W
006E8:  ANDLW  07
006EA:  ANDLW  07
006EC:  MOVWF  00
006EE:  BCF    FD8.0
006F0:  RLCF   00,F
006F2:  MOVLW  F1
006F4:  MOVLB  3
006F6:  ANDWF  x34,W
006F8:  IORWF  00,W
006FA:  MOVWF  x34
*
00896:  MOVLB  F
00898:  MOVF   x50,W
0089A:  ANDLW  07
0089C:  ANDLW  07
0089E:  MOVWF  00
008A0:  BCF    FD8.0
008A2:  RLCF   00,F
008A4:  MOVLW  F1
008A6:  MOVLB  3
008A8:  ANDWF  x34,W
008AA:  IORWF  00,W
008AC:  MOVWF  x34
....................     } 
....................     else { 
*
006FC:  BRA    0708
006FE:  MOVLB  F
*
008AE:  BRA    08BA
008B0:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
00700:  MOVLW  00
00702:  MOVWF  01
00704:  BRA    079E
00706:  MOVLB  3
*
008B2:  MOVLW  00
008B4:  MOVWF  01
008B6:  BRA    0950
008B8:  MOVLB  3
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
00708:  MOVF   F65,W
0070A:  ANDLW  0F
0070C:  MOVWF  x33
*
008BA:  MOVF   F65,W
008BC:  ANDLW  0F
008BE:  MOVWF  x33
....................     stat.rtr=RXBaDLC.rtr; 
*
0070E:  BCF    x34.5
00710:  BTFSC  F65.6
00712:  BSF    x34.5
*
008C0:  BCF    x34.5
008C2:  BTFSC  F65.6
008C4:  BSF    x34.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
00714:  BCF    x34.6
00716:  BTFSC  F62.3
00718:  BSF    x34.6
*
008C6:  BCF    x34.6
008C8:  BTFSC  F62.3
008CA:  BSF    x34.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
0071A:  MOVLW  00
0071C:  BTFSC  x34.6
0071E:  MOVLW  01
00720:  MOVWF  x3A
00722:  MOVLW  0F
00724:  MOVWF  x42
00726:  MOVLW  64
00728:  MOVWF  x41
0072A:  MOVFF  33A,343
0072E:  MOVLB  0
00730:  RCALL  0490
00732:  MOVFF  03,332
00736:  MOVFF  02,331
0073A:  MOVFF  01,330
0073E:  MOVFF  00,32F
*
008CC:  MOVLW  00
008CE:  BTFSC  x34.6
008D0:  MOVLW  01
008D2:  MOVWF  x3A
008D4:  MOVLW  0F
008D6:  MOVWF  x42
008D8:  MOVLW  64
008DA:  MOVWF  x41
008DC:  MOVFF  33A,343
008E0:  MOVLB  0
008E2:  RCALL  0490
008E4:  MOVFF  03,332
008E8:  MOVFF  02,331
008EC:  MOVFF  01,330
008F0:  MOVFF  00,32F
....................  
....................     ptr = &TXRXBaD0; 
*
00742:  MOVLW  0F
00744:  MOVLB  3
00746:  MOVWF  x39
00748:  MOVLW  66
0074A:  MOVWF  x38
*
008F4:  MOVLW  0F
008F6:  MOVLB  3
008F8:  MOVWF  x39
008FA:  MOVLW  66
008FC:  MOVWF  x38
....................     for ( i = 0; i < len; i++ ) { 
*
0074C:  CLRF   x37
0074E:  MOVF   x33,W
00750:  SUBWF  x37,W
00752:  BC    077C
*
008FE:  CLRF   x37
00900:  MOVF   x33,W
00902:  SUBWF  x37,W
00904:  BC    092E
....................         *data = *ptr; 
*
00754:  MOVFF  338,FE9
00758:  MOVFF  339,FEA
0075C:  MOVFF  FEF,33C
00760:  MOVFF  336,FEA
00764:  MOVFF  335,FE9
00768:  MOVFF  33C,FEF
*
00906:  MOVFF  338,FE9
0090A:  MOVFF  339,FEA
0090E:  MOVFF  FEF,33C
00912:  MOVFF  336,FEA
00916:  MOVFF  335,FE9
0091A:  MOVFF  33C,FEF
....................         data++; 
*
0076C:  INCF   x35,F
0076E:  BTFSC  FD8.2
00770:  INCF   x36,F
*
0091E:  INCF   x35,F
00920:  BTFSC  FD8.2
00922:  INCF   x36,F
....................         ptr++; 
*
00772:  INCF   x38,F
00774:  BTFSC  FD8.2
00776:  INCF   x39,F
*
00924:  INCF   x38,F
00926:  BTFSC  FD8.2
00928:  INCF   x39,F
....................     } 
*
00778:  INCF   x37,F
0077A:  BRA    074E
*
0092A:  INCF   x37,F
0092C:  BRA    0900
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
0077C:  MOVLW  F1
0077E:  ANDWF  F6F,W
00780:  MOVWF  F6F
*
0092E:  MOVLW  F1
00930:  ANDWF  F6F,W
00932:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
00782:  BCF    x34.7
00784:  BTFSC  FA4.7
00786:  BSF    x34.7
*
00934:  BCF    x34.7
00936:  BTFSC  FA4.7
00938:  BSF    x34.7
....................     CAN_INT_IRXIF = 0; 
*
00788:  BCF    FA4.7
*
0093A:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
0078A:  BTFSS  x34.4
0078C:  BRA    0796
*
0093C:  BTFSS  x34.4
0093E:  BRA    0948
....................       RXB1CON.rxful=0; 
*
0078E:  MOVLB  F
00790:  BCF    x50.7
*
00940:  MOVLB  F
00942:  BCF    x50.7
....................     } 
....................     else { 
*
00792:  BRA    079A
00794:  MOVLB  3
*
00944:  BRA    094C
00946:  MOVLB  3
....................       RXB0CON.rxful=0; 
*
00796:  BCF    F60.7
00798:  MOVLB  F
*
00948:  BCF    F60.7
0094A:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
0079A:  MOVLW  01
0079C:  MOVWF  01
*
0094C:  MOVLW  01
0094E:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include "uart_sci16is740.c" 
.................... /* register map for SCI16IS740 */ 
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode 
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode 
.................... #define UART_IER          0x01  // Interrupt Enable Register 
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode 
.................... #define UART_LCR          0x03  // Line Control Register 
.................... #define UART_MCR          0x04  // Modem Control Register 
.................... #define UART_LSR          0x05  // Line status Register 
.................... #define UART_MSR          0x06  // Modem Status Register 
.................... #define UART_SPR          0x07  // ScratchPad Register 
.................... #define UART_TCR          0x06  // Transmission Control Register 
.................... #define UART_TLR          0x07  // Trigger Level Register 
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register 
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register 
.................... #define UART_EFCR         0x0F  // Extra Features Control Register 
....................  
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00 
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01 
....................  
.................... #define UART_EFR          0x02  // Enhanced Function Register 
....................  
.................... #define UART_I2C_WRITE    0x00 
.................... #define UART_I2C_READ     0x01                                                
....................  
.................... /* A0 and A1 at VSS */ 
.................... #define UART_ADDR         0x9A 
....................  
.................... int8 uart_read(int8 regaddr) { 
.................... 	int8 data; 
....................  
.................... 	i2c_start(); 
*
011BC:  BSF    F94.4
011BE:  NOP   
011C0:  BSF    F94.3
011C2:  NOP   
011C4:  BCF    F8B.4
011C6:  BCF    F94.4
011C8:  NOP   
011CA:  BCF    F8B.3
011CC:  BCF    F94.3
.................... 	delay_us(15); 
011CE:  CLRWDT
011D0:  MOVLW  09
011D2:  MOVWF  00
011D4:  DECFSZ 00,F
011D6:  BRA    11D4
011D8:  NOP   
.................... 	i2c_write(UART_ADDR); 
011DA:  MOVLW  9A
011DC:  MOVLB  2
011DE:  MOVWF  x75
011E0:  MOVLB  0
011E2:  RCALL  0A50
.................... 	i2c_write(regaddr<<3); 
011E4:  MOVLB  2
011E6:  RLCF   x6B,W
011E8:  MOVWF  x6D
011EA:  RLCF   x6D,F
011EC:  RLCF   x6D,F
011EE:  MOVLW  F8
011F0:  ANDWF  x6D,F
011F2:  MOVFF  26D,275
011F6:  MOVLB  0
011F8:  RCALL  0A50
.................... 	i2c_start(); 
011FA:  BSF    F94.4
011FC:  NOP   
011FE:  BSF    F94.3
01200:  NOP   
01202:  BTFSS  F82.3
01204:  BRA    1202
01206:  BCF    F8B.4
01208:  BCF    F94.4
0120A:  NOP   
0120C:  BCF    F8B.3
0120E:  BCF    F94.3
.................... 	delay_us(15); 
01210:  CLRWDT
01212:  MOVLW  09
01214:  MOVWF  00
01216:  DECFSZ 00,F
01218:  BRA    1216
0121A:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                  
0121C:  MOVLW  9B
0121E:  MOVLB  2
01220:  MOVWF  x75
01222:  MOVLB  0
01224:  RCALL  0A50
.................... 	data=i2c_read(0); 
01226:  CLRF   00
01228:  BRA    116E
0122A:  MOVFF  01,26C
.................... 	i2c_stop(); 
0122E:  BCF    F94.4
01230:  NOP   
01232:  BSF    F94.3
01234:  BTFSS  F82.3
01236:  BRA    1234
01238:  NOP   
0123A:  BRA    123C
0123C:  NOP   
0123E:  BSF    F94.4
01240:  NOP   
....................  
.................... 	return data; 
01242:  MOVLB  2
01244:  MOVFF  26C,01
.................... } 
01248:  MOVLB  0
0124A:  RETURN 0
....................  
.................... void uart_write(int8 regaddr, int8 data ) {                                                                   
.................... 	i2c_start(); 
*
00AA2:  BSF    F94.4
00AA4:  NOP   
00AA6:  BSF    F94.3
00AA8:  NOP   
00AAA:  BCF    F8B.4
00AAC:  BCF    F94.4
00AAE:  NOP   
00AB0:  BCF    F8B.3
00AB2:  BCF    F94.3
.................... 	delay_us(15);                                                  
00AB4:  CLRWDT
00AB6:  MOVLW  09
00AB8:  MOVWF  00
00ABA:  DECFSZ 00,F
00ABC:  BRA    0ABA
00ABE:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                        
00AC0:  MOVLW  9A
00AC2:  MOVLB  2
00AC4:  MOVWF  x75
00AC6:  MOVLB  0
00AC8:  RCALL  0A50
.................... 	i2c_write(regaddr<< 3);  // write cycle          
00ACA:  MOVLB  2
00ACC:  RLCF   x72,W
00ACE:  MOVWF  x74
00AD0:  RLCF   x74,F
00AD2:  RLCF   x74,F
00AD4:  MOVLW  F8
00AD6:  ANDWF  x74,F
00AD8:  MOVFF  274,275
00ADC:  MOVLB  0
00ADE:  RCALL  0A50
.................... 	i2c_write(data); 
00AE0:  MOVFF  273,275
00AE4:  RCALL  0A50
.................... 	i2c_stop(); 
00AE6:  BCF    F94.4
00AE8:  NOP   
00AEA:  BSF    F94.3
00AEC:  BTFSS  F82.3
00AEE:  BRA    0AEC
00AF0:  NOP   
00AF2:  BRA    0AF4
00AF4:  NOP   
00AF6:  BSF    F94.4
00AF8:  NOP   
.................... }  
00AFA:  RETURN 0
....................  
.................... void uart_putc(int8 data ) { 
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register 
*
01602:  MOVLB  2
01604:  CLRF   x72
01606:  MOVFF  271,273
0160A:  MOVLB  0
0160C:  CALL   0AA2
.................... } 
01610:  GOTO   175A (RETURN)
....................  
.................... int1 uart_kbhit(void) { 
.................... 	return (uart_read(UART_LSR) & 0x01); 
*
0124C:  MOVLW  05
0124E:  MOVLB  2
01250:  MOVWF  x6B
01252:  MOVLB  0
01254:  RCALL  11BC
01256:  MOVF   01,W
01258:  ANDLW  01
0125A:  MOVWF  01
.................... } 
0125C:  RETURN 0
....................  
.................... #inline 
.................... int8 uart_getc() { 
.................... 	return uart_read(UART_RHR); 
*
0126A:  MOVLB  2
0126C:  CLRF   x6B
0126E:  MOVLB  0
01270:  RCALL  11BC
01272:  MOVF   01,W
.................... } 
....................  
.................... void uart_init(void) { 
.................... 	output_low(UART_RESET); 
*
00AFC:  BCF    F93.1
00AFE:  BCF    F8A.1
.................... 	delay_ms(10); 
00B00:  MOVLW  0A
00B02:  MOVLB  2
00B04:  MOVWF  x6A
00B06:  MOVLB  0
00B08:  RCALL  0A20
.................... 	output_high(UART_RESET); 
00B0A:  BCF    F93.1
00B0C:  BSF    F8A.1
.................... 	delay_ms(10); 
00B0E:  MOVLW  0A
00B10:  MOVLB  2
00B12:  MOVWF  x6A
00B14:  MOVLB  0
00B16:  RCALL  0A20
....................  
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */ 
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor 
00B18:  MOVLW  03
00B1A:  MOVLB  2
00B1C:  MOVWF  x72
00B1E:  MOVLW  80
00B20:  MOVWF  x73
00B22:  MOVLB  0
00B24:  RCALL  0AA2
.................... 	uart_write(UART_DLL, 12);    // divide clock by 12 for 9600 baud when using 1.8432 crystal 
00B26:  MOVLB  2
00B28:  CLRF   x72
00B2A:  MOVLW  0C
00B2C:  MOVWF  x73
00B2E:  MOVLB  0
00B30:  RCALL  0AA2
.................... 	uart_write(UART_DLH, 0); 
00B32:  MOVLW  01
00B34:  MOVLB  2
00B36:  MOVWF  x72
00B38:  CLRF   x73
00B3A:  MOVLB  0
00B3C:  RCALL  0AA2
....................  
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register 
00B3E:  MOVLW  03
00B40:  MOVLB  2
00B42:  MOVWF  x72
00B44:  MOVLW  BF
00B46:  MOVWF  x73
00B48:  MOVLB  0
00B4A:  RCALL  0AA2
.................... 	uart_write(UART_EFR, 0x10); // enable enhanced registers 
00B4C:  MOVLW  02
00B4E:  MOVLB  2
00B50:  MOVWF  x72
00B52:  MOVLW  10
00B54:  MOVWF  x73
00B56:  MOVLB  0
00B58:  RCALL  0AA2
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity 
00B5A:  MOVLW  03
00B5C:  MOVLB  2
00B5E:  MOVWF  x72
00B60:  MOVWF  x73
00B62:  MOVLB  0
00B64:  RCALL  0AA2
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available 
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode 
00B66:  MOVLW  02
00B68:  MOVLB  2
00B6A:  MOVWF  x72
00B6C:  MOVLW  07
00B6E:  MOVWF  x73
00B70:  MOVLB  0
00B72:  RCALL  0AA2
.................... } 
00B74:  GOTO   0E12 (RETURN)
....................  
....................  
.................... #include "live.c" 
.................... int16 crc_chk(int8 *data, int8 length) { 
*
013B4:  MOVLB  3
013B6:  SETF   x24
013B8:  SETF   x23
.................... 	int8 j; 
.................... 	int16 reg_crc=0xFFFF; 
....................  
.................... 	while ( length-- ) { 
013BA:  MOVF   x21,W
013BC:  DECF   x21,F
013BE:  XORLW  00
013C0:  BZ    140E
.................... 		reg_crc ^= *data++; 
013C2:  MOVFF  320,03
013C6:  MOVF   x1F,W
013C8:  INCF   x1F,F
013CA:  BTFSC  FD8.2
013CC:  INCF   x20,F
013CE:  MOVWF  FE9
013D0:  MOVFF  03,FEA
013D4:  MOVF   FEF,W
013D6:  XORWF  x23,F
....................  
.................... 		for ( j=0 ; j<8 ; j++ ) { 
013D8:  CLRF   x22
013DA:  MOVF   x22,W
013DC:  SUBLW  07
013DE:  BNC   140C
.................... 			if ( reg_crc & 0x01 ) { 
013E0:  MOVF   x23,W
013E2:  ANDLW  01
013E4:  MOVWF  00
013E6:  CLRF   03
013E8:  MOVF   00,W
013EA:  IORWF  03,W
013EC:  BZ    1402
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001; 
013EE:  BCF    FD8.0
013F0:  RRCF   x24,W
013F2:  MOVWF  x26
013F4:  RRCF   x23,W
013F6:  XORLW  01
013F8:  MOVWF  x23
013FA:  MOVF   x26,W
013FC:  XORLW  A0
013FE:  MOVWF  x24
.................... 			} else { 
01400:  BRA    1408
.................... 				reg_crc=reg_crc>>1; 
01402:  BCF    FD8.0
01404:  RRCF   x24,F
01406:  RRCF   x23,F
.................... 			} 
.................... 		}	 
01408:  INCF   x22,F
0140A:  BRA    13DA
.................... 	} 
0140C:  BRA    13BA
.................... 	 
.................... 	return reg_crc; 
0140E:  MOVFF  323,01
01412:  MOVFF  324,02
.................... } 
01416:  MOVLB  0
01418:  RETURN 0
....................  
.................... /* send CAN registers in RSTap data format */ 
.................... void live_send_vcs(void) { 
.................... 	static int16 sequenceNumber=0; 
.................... 	int16 lCRC; 
.................... 	int8 i,j; 
.................... 	int8 buff[177]; 
....................  
.................... 	memset(buff,0,sizeof(buff)); 
*
01422:  MOVLW  02
01424:  MOVWF  FEA
01426:  MOVLW  6E
01428:  MOVWF  FE9
0142A:  CLRF   00
0142C:  CLRF   02
0142E:  MOVLW  B1
01430:  MOVWF  01
01432:  RCALL  0DD2
....................  
.................... 	buff[0]='#'; 
01434:  MOVLW  23
01436:  MOVLB  2
01438:  MOVWF  x6E
.................... 	buff[1]=config.serial_prefix; 
0143A:  MOVFF  22,26F
.................... 	buff[2]=make8(config.serial_number,1); 
0143E:  MOVFF  24,270
.................... 	buff[3]=make8(config.serial_number,0);  
01442:  MOVFF  23,271
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */ 
01446:  SETF   x72
.................... 	buff[5]=18; /* packet type */ 
01448:  MOVLW  12
0144A:  MOVWF  x73
.................... 	buff[6]=0; 
0144C:  CLRF   x74
.................... 	buff[7]=179; /* 17 bytes header + 160 bytes CAN data + 2 bytes CRC */ 
0144E:  MOVLW  B3
01450:  MOVWF  x75
....................  
.................... 	buff[8]=make8(sequenceNumber,1); 
01452:  MOVFF  15F,276
01456:  MOVLB  2
.................... 	buff[9]=make8(sequenceNumber,0); 
01458:  MOVFF  15E,277
0145C:  MOVLB  2
....................  
.................... 	/* device info */ 
.................... 	/* WorldData device type identifier (16-bit) .... 1600 for VCSTap */ 
.................... 	buff[10]=make8(1600,1); 
0145E:  MOVLW  06
01460:  MOVWF  x78
.................... 	buff[11]=make8(1600,0); 
01462:  MOVLW  40
01464:  MOVWF  x79
.................... 	/* manufacturers serial number */ 
.................... 	buff[12]=0; 
01466:  CLRF   x7A
.................... 	buff[13]=config.pair_serial_prefix; 
01468:  MOVFF  25,27B
.................... 	buff[14]=make8(config.pair_serial_number,1); 
0146C:  MOVFF  27,27C
.................... 	buff[15]=make8(config.pair_serial_number,0); 
01470:  MOVFF  26,27D
.................... 	/* status of the data read  .... no error */ 
.................... 	buff[16]=0; 
01474:  CLRF   x7E
....................  
.................... 	/* shut down CAN reception and copy CAN registers over */ 
.................... 	disable_interrupts(INT_CANRX0); 
01476:  BCF    FA3.0
.................... 	disable_interrupts(INT_CANRX1); 
01478:  BCF    FA3.1
.................... 	/* do our endian swap one word at a time */ 
.................... 	for ( i=0 ; i<160 ; i+=4 ) { 
0147A:  CLRF   x6C
0147C:  MOVF   x6C,W
0147E:  SUBLW  9F
01480:  BNC   1552
.................... 		j=i + 17; 
01482:  MOVLW  11
01484:  ADDWF  x6C,W
01486:  MOVWF  x6D
....................  
.................... 		buff[j+0]=timer.vcs_register[i+1]; 
01488:  CLRF   03
0148A:  MOVF   x6D,W
0148C:  ADDLW  6E
0148E:  MOVWF  01
01490:  MOVLW  02
01492:  ADDWFC 03,F
01494:  MOVLW  01
01496:  MOVLB  2
01498:  ADDWF  x6C,W
0149A:  ADDLW  B3
0149C:  MOVWF  FE9
0149E:  CLRF   FEA
014A0:  BTFSC  FD8.0
014A2:  INCF   FEA,F
014A4:  MOVFF  FEF,321
014A8:  MOVLB  3
014AA:  MOVFF  03,FEA
014AE:  MOVFF  01,FE9
014B2:  MOVFF  321,FEF
.................... 		buff[j+1]=timer.vcs_register[i+0]; 
014B6:  MOVLW  01
014B8:  MOVLB  2
014BA:  ADDWF  x6D,W
014BC:  CLRF   03
014BE:  ADDLW  6E
014C0:  MOVWF  01
014C2:  MOVLW  02
014C4:  ADDWFC 03,F
014C6:  MOVLW  B3
014C8:  MOVLB  2
014CA:  ADDWF  x6C,W
014CC:  MOVWF  FE9
014CE:  CLRF   FEA
014D0:  BTFSC  FD8.0
014D2:  INCF   FEA,F
014D4:  MOVFF  FEF,321
014D8:  MOVLB  3
014DA:  MOVFF  03,FEA
014DE:  MOVFF  01,FE9
014E2:  MOVFF  321,FEF
.................... 		buff[j+2]=timer.vcs_register[i+3]; 
014E6:  MOVLW  02
014E8:  MOVLB  2
014EA:  ADDWF  x6D,W
014EC:  CLRF   03
014EE:  ADDLW  6E
014F0:  MOVWF  01
014F2:  MOVLW  02
014F4:  ADDWFC 03,F
014F6:  MOVLW  03
014F8:  MOVLB  2
014FA:  ADDWF  x6C,W
014FC:  ADDLW  B3
014FE:  MOVWF  FE9
01500:  CLRF   FEA
01502:  BTFSC  FD8.0
01504:  INCF   FEA,F
01506:  MOVFF  FEF,321
0150A:  MOVLB  3
0150C:  MOVFF  03,FEA
01510:  MOVFF  01,FE9
01514:  MOVFF  321,FEF
.................... 		buff[j+3]=timer.vcs_register[i+2]; 
01518:  MOVLW  03
0151A:  MOVLB  2
0151C:  ADDWF  x6D,W
0151E:  CLRF   03
01520:  ADDLW  6E
01522:  MOVWF  01
01524:  MOVLW  02
01526:  ADDWFC 03,F
01528:  MOVLW  02
0152A:  MOVLB  2
0152C:  ADDWF  x6C,W
0152E:  ADDLW  B3
01530:  MOVWF  FE9
01532:  CLRF   FEA
01534:  BTFSC  FD8.0
01536:  INCF   FEA,F
01538:  MOVFF  FEF,321
0153C:  MOVLB  3
0153E:  MOVFF  03,FEA
01542:  MOVFF  01,FE9
01546:  MOVFF  321,FEF
.................... 	} 
0154A:  MOVLW  04
0154C:  MOVLB  2
0154E:  ADDWF  x6C,F
01550:  BRA    147C
....................  
.................... 	/* set fault indicator LED */ 
....................  
.................... 	/* any fault */ 
.................... //	if ( timer.vcs_register[30*4] || timer.vcs_register[30*4+1] || timer.vcs_register[30*4+2] || timer.vcs_register[30*4+3] ) { 
.................... 	/* system state 6 (FAULT) */ 
.................... //	if ( 6==timer.vcs_register[19*4+3] || 6==timer.vcs_register[19*4+2] || 6==timer.vcs_register[19*4+1] || 6==timer.vcs_register[19*4+0] ) { 
.................... 	if (  
.................... 		(0==timer.vcs_register[19*4+3] && 0==timer.vcs_register[19*4+2] && 0==timer.vcs_register[19*4+1] && 6==timer.vcs_register[19*4+0]) 
.................... 		|| timer.vcs_last_data_age>12000 
.................... 	 ) { 
01552:  MOVLB  1
01554:  MOVF   x02,F
01556:  BNZ   156A
01558:  MOVF   x01,F
0155A:  BNZ   156A
0155C:  MOVF   x00,F
0155E:  BNZ   156A
01560:  MOVLB  0
01562:  MOVF   xFF,W
01564:  SUBLW  06
01566:  BZ    1582
01568:  MOVLB  1
0156A:  MOVF   x57,W
0156C:  SUBLW  2D
0156E:  BC    158A
01570:  XORLW  FF
01572:  BTFSC  FD8.2
01574:  BRA    157A
01576:  MOVLB  0
01578:  BRA    1582
0157A:  MOVF   x56,W
0157C:  SUBLW  E0
0157E:  BC    158A
01580:  MOVLB  0
.................... 		output_high(RELAY_RED); 
01582:  BCF    F93.5
01584:  BSF    F8A.5
.................... 	} else { 
01586:  BRA    1590
01588:  MOVLB  1
.................... 		output_low(RELAY_RED); 
0158A:  BCF    F93.5
0158C:  BCF    F8A.5
0158E:  MOVLB  0
.................... 	} 
....................  
.................... 	enable_interrupts(INT_CANRX0); 
01590:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1); 
01592:  BSF    FA3.1
....................  
.................... 	/* compute CRC on header and result data */ 
.................... 	lCRC=crc_chk(buff+1,sizeof(buff)-1); 
01594:  MOVLW  02
01596:  MOVLB  3
01598:  MOVWF  x20
0159A:  MOVLW  6F
0159C:  MOVWF  x1F
0159E:  MOVLW  B0
015A0:  MOVWF  x21
015A2:  MOVLB  0
015A4:  RCALL  13B4
015A6:  MOVFF  02,26B
015AA:  MOVFF  01,26A
....................  
.................... 	/* send buff, qbuff.rResult, CRC */ 
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) { 
015AE:  MOVLB  2
015B0:  CLRF   x6C
015B2:  MOVF   x6C,W
015B4:  SUBLW  B0
015B6:  BNC   15D8
.................... 		fputc(buff[i],rs232); 
015B8:  CLRF   03
015BA:  MOVF   x6C,W
015BC:  ADDLW  6E
015BE:  MOVWF  FE9
015C0:  MOVLW  02
015C2:  ADDWFC 03,W
015C4:  MOVWF  FEA
015C6:  MOVFF  FEF,31F
015CA:  MOVLB  3
015CC:  MOVF   x1F,W
015CE:  MOVLB  0
015D0:  RCALL  141A
.................... 	}	 
015D2:  MOVLB  2
015D4:  INCF   x6C,F
015D6:  BRA    15B2
.................... 	fputc(make8(lCRC,1),rs232); 
015D8:  MOVFF  26B,31F
015DC:  MOVLB  3
015DE:  MOVF   x1F,W
015E0:  MOVLB  0
015E2:  RCALL  141A
.................... 	fputc(make8(lCRC,0),rs232); 
015E4:  MOVFF  26A,31F
015E8:  MOVLB  3
015EA:  MOVF   x1F,W
015EC:  MOVLB  0
015EE:  RCALL  141A
....................  
.................... 	sequenceNumber++; 
015F0:  MOVLB  1
015F2:  INCF   x5E,F
015F4:  BTFSC  FD8.2
015F6:  INCF   x5F,F
....................  
.................... 	output_high(SYNC_OUT); 
015F8:  BCF    F94.5
015FA:  BSF    F8B.5
.................... } 
015FC:  MOVLB  0
015FE:  GOTO   1898 (RETURN)
....................  
.................... /*		 
.................... '#'                 0  STX 
.................... UNIT ID PREFIX      1  First character (A-Z) for serial number 
.................... UNIT ID MSB         2  high byte of sending station ID 
.................... UNIT ID LSB         3  low byte of sending station ID 
.................... PACKET LENGTH       4  number of byte for packet including STX through CRC 
.................... PACKET TYPE         5  type of packet we are sending, 27 
.................... SEQUENCE MSB        6 
.................... SEQUENCE LSB        7 
....................  
.................... CRC MSB              high byte of CRC on everything after STX and before CRC 
.................... CRC LSB              low byte of CRC 
.................... */ 
....................  
....................  
.................... int1 live_send_xrw2g() { 
*
01614:  MOVLB  2
01616:  BSF    x6F.0
.................... 	int16 lCRC, rCRC; 
.................... 	int8 i; 
.................... 	int1 valid=1; 
....................  
.................... //	fprintf(rs232,"# (live) xrw2g_packet{=0x%02X, 0x%02X, 0x%02X}\r\n",timer.xrw2g_packet[1],timer.xrw2g_packet[2],timer.xrw2g_packet[3]); 
....................  
....................  
....................  
.................... 	/* if wireless sensors, we might have heard something else and gotten in here. In that case, we 
.................... 	 drop back out and try again*/ 
.................... 	if ( SENSOR_SOURCE_WIRELESS == config.sensor_source ) { 
01618:  DECFSZ 28,W
0161A:  BRA    1670
.................... 	    valid=0; 
0161C:  BCF    x6F.0
....................  
.................... 	    /* check packet type */ 
.................... 	    if ( 23==timer.xrw2g_packet[5] && timer.xrw2g_buff_pos>10 ) { 
0161E:  MOVF   35,W
01620:  SUBLW  17
01622:  BNZ   1670
01624:  MOVLB  0
01626:  MOVF   xB0,W
01628:  SUBLW  0A
0162A:  BTFSS  FD8.0
0162C:  BRA    1632
0162E:  MOVLB  2
01630:  BRA    1670
.................... 			/* is XRW2G packet */ 
.................... 			if ( 0==config.pair_serial_prefix && 0==config.pair_serial_number ) { 
01632:  MOVF   25,F
01634:  BNZ   1646
01636:  MOVF   26,F
01638:  BNZ   1646
0163A:  MOVF   27,F
0163C:  BNZ   1646
.................... 			    /* valid packet from an XRW2G, and we don't care which one */ 
.................... 			    valid=1; 
0163E:  MOVLB  2
01640:  BSF    x6F.0
.................... 			} else if ( timer.xrw2g_packet[1] == config.pair_serial_prefix && make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) == config.pair_serial_number ) { 
01642:  BRA    1670
01644:  MOVLB  0
01646:  MOVF   25,W
01648:  SUBWF  31,W
0164A:  BNZ   1672
0164C:  MOVFF  32,271
01650:  MOVFF  33,270
01654:  MOVF   26,W
01656:  MOVLB  2
01658:  SUBWF  33,W
0165A:  BTFSC  FD8.2
0165C:  BRA    1662
0165E:  MOVLB  0
01660:  BRA    1672
01662:  MOVF   27,W
01664:  SUBWF  x71,W
01666:  BTFSC  FD8.2
01668:  BRA    166E
0166A:  MOVLB  0
0166C:  BRA    1672
.................... 			    valid=1; 
0166E:  BSF    x6F.0
01670:  MOVLB  0
.................... 			} 
.................... 	    } 
.................... 	} 
....................  
.................... 	if ( 0 == valid ) { 
01672:  MOVLB  2
01674:  BTFSC  x6F.0
01676:  BRA    1682
.................... 	    /* clear buffer and we'll try again next time */ 
.................... 	    timer.xrw2g_buff_pos=0; 
01678:  MOVLB  0
0167A:  CLRF   xB0
.................... 	    return false; 
0167C:  MOVLW  00
0167E:  MOVWF  01
01680:  BRA    1768
.................... 	} 
....................  
.................... /*		 
.................... '#'                   0  STX 
.................... UNIT ID PREFIX        1  First character (A-Z) for serial number 
.................... UNIT ID MSB           2  high byte of sending station ID 
.................... UNIT ID LSB           3  low byte of sending station ID 
.................... PACKET LENGTH         4  number of byte for packet including STX through CRC 
.................... PACKET TYPE           5  type of packet we are sending, 23 
.................... SEQUENCE MSB          6 
.................... SEQUENCE LSB          7 
.................... (snip) 
.................... CRC MSB               96 high byte of CRC on everything after STX and before CRC 
.................... CRC LSB               97 low byte of CRC 
.................... 	config.serial_prefix='Z'; 
.................... 	config.serial_number=9876; 
.................... */ 
.................... 	/* check for valid CRC */ 
.................... 	if ( timer.xrw2g_buff_pos>=98 ) { 
01682:  MOVLB  0
01684:  MOVF   xB0,W
01686:  SUBLW  61
01688:  BC    16C2
.................... 		rCRC = make16(timer.xrw2g_packet[96],timer.xrw2g_packet[97]); 
0168A:  MOVFF  90,26D
0168E:  MOVFF  91,26C
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
01692:  MOVLB  3
01694:  CLRF   x20
01696:  MOVLW  31
01698:  MOVWF  x1F
0169A:  MOVLW  5F
0169C:  MOVWF  x21
0169E:  MOVLB  0
016A0:  RCALL  13B4
016A2:  MOVFF  02,26B
016A6:  MOVFF  01,26A
....................  
.................... 		if ( lCRC != rCRC ) { 
016AA:  MOVLB  2
016AC:  MOVF   x6C,W
016AE:  SUBWF  x6A,W
016B0:  BNZ   16B8
016B2:  MOVF   x6D,W
016B4:  SUBWF  x6B,W
016B6:  BZ    16C4
.................... 		    /* clear buffer and we'll try again next time */ 
.................... 		    timer.xrw2g_buff_pos=0; 
016B8:  MOVLB  0
016BA:  CLRF   xB0
.................... 		    return false; 
016BC:  MOVLW  00
016BE:  MOVWF  01
016C0:  BRA    1768
016C2:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
.................... //	fprintf(rs232,"@ (sp=%c) (sn=%lu) (buff_pos=%u) @\r\n",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]),timer.xrw2g_buff_pos); 
.................... 	/* check for default serial number */ 
.................... 	if ( 'Z' == timer.xrw2g_packet[1] && 9876 == make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) && timer.xrw2g_buff_pos>=98 ) { 
016C4:  MOVF   31,W
016C6:  SUBLW  5A
016C8:  BNZ   171A
016CA:  MOVFF  32,03
016CE:  MOVF   33,W
016D0:  SUBLW  94
016D2:  BNZ   171A
016D4:  MOVF   03,W
016D6:  SUBLW  26
016D8:  BNZ   171A
016DA:  MOVLB  0
016DC:  MOVF   xB0,W
016DE:  SUBLW  61
016E0:  BTFSS  FD8.0
016E2:  BRA    16E8
016E4:  MOVLB  2
016E6:  BRA    171A
.................... 		/* valid XRW2G packet with default serial number ... now we overwrite with our serial number */ 
.................... 		timer.xrw2g_packet[1]=config.serial_prefix; 
016E8:  MOVFF  22,31
.................... 		timer.xrw2g_packet[2]=make8(config.serial_number,1); 
016EC:  MOVFF  24,32
.................... 		timer.xrw2g_packet[3]=make8(config.serial_number,0); 
016F0:  MOVFF  23,33
....................  
.................... 		/* and re-calculate and replace CRC */ 
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
016F4:  MOVLB  3
016F6:  CLRF   x20
016F8:  MOVLW  31
016FA:  MOVWF  x1F
016FC:  MOVLW  5F
016FE:  MOVWF  x21
01700:  MOVLB  0
01702:  RCALL  13B4
01704:  MOVFF  02,26B
01708:  MOVFF  01,26A
.................... 		timer.xrw2g_packet[96]=make8(lCRC,1);		timer.xrw2g_packet[97]=make8(lCRC,0); 
0170C:  MOVFF  26B,90
01710:  MOVLB  2
01712:  MOVFF  26A,91
01716:  MOVLB  0
01718:  MOVLB  2
.................... 	} 
....................  
....................  
....................  
.................... 	for ( i=0 ; i<98 ; i++ ) { 
0171A:  CLRF   x6E
0171C:  MOVF   x6E,W
0171E:  SUBLW  61
01720:  BNC   1760
.................... 	    if ( config.world_to_xport ) 
01722:  MOVF   2A,F
01724:  BZ    173E
.................... 			fputc(timer.xrw2g_packet[i],rs232); 
01726:  MOVLW  30
01728:  ADDWF  x6E,W
0172A:  MOVWF  FE9
0172C:  CLRF   FEA
0172E:  BTFSC  FD8.0
01730:  INCF   FEA,F
01732:  MOVFF  FEF,270
01736:  MOVF   x70,W
01738:  MOVLB  0
0173A:  RCALL  141A
0173C:  MOVLB  2
.................... 	    if ( config.world_to_xbee ) 
0173E:  MOVF   29,F
01740:  BZ    175C
.................... 			uart_putc(timer.xrw2g_packet[i]); 
01742:  MOVLW  30
01744:  ADDWF  x6E,W
01746:  MOVWF  FE9
01748:  CLRF   FEA
0174A:  BTFSC  FD8.0
0174C:  INCF   FEA,F
0174E:  MOVFF  FEF,270
01752:  MOVFF  270,271
01756:  MOVLB  0
01758:  BRA    1602
0175A:  MOVLB  2
.................... 	} 
0175C:  INCF   x6E,F
0175E:  BRA    171C
....................  
.................... 	timer.xrw2g_buff_pos=0; 
01760:  MOVLB  0
01762:  CLRF   xB0
.................... 	return true; 
01764:  MOVLW  01
01766:  MOVWF  01
.................... } 
01768:  GOTO   18B2 (RETURN)
....................  
....................  
.................... #include "modbus_slave_vcstap.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE 88888 
.................... #define MODBUS_INT_RDA2 66666 
....................  
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_INT_SOURCE   MODBUS_INT_RDA    // Select between external interrupt 
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us 
....................  
.................... #inline  
.................... void rcv_off(void) { 
.................... 	disable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
....................  
.................... #byte TXSTA=0xfad // PIC18F24J11 TXSTA for UART1 */ 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #inline 
.................... void wait_for_hw_buffer(void) { 
.................... 	while ( ! TRMT ) 
.................... 		; 
.................... } 
....................  
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while(kbhit(rs232)) { 
.................... 		fgetc(rs232); 
.................... 	}   
.................... 	 
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
....................  
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); 
.................... 	enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0030A:  BCF    FF2.5
.................... 	if (enable) { 
0030C:  MOVLB  3
0030E:  MOVF   x28,F
00310:  BZ    031A
.................... 		set_timer0(0); 
00312:  CLRF   FD7
00314:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00316:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00318:  BSF    FF2.5
.................... 	} 
.................... } 
0031A:  MOVLB  0
0031C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... //#int_timer2 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0031E:  MOVLB  1
00320:  MOVF   x61,W
00322:  SUBLW  02
00324:  BNZ   033A
00326:  MOVF   x62,F
00328:  BNZ   033A
0032A:  MOVF   x63,F
0032C:  BNZ   033A
0032E:  BTFSC  x60.0
00330:  BRA    033A
....................    { 
....................       modbus_rx.len-=2; 
00332:  MOVLW  02
00334:  SUBWF  x65,F
....................       modbus_serial_new=TRUE; 
00336:  BSF    x60.0
....................    } 
....................    else 
00338:  BRA    033C
....................       modbus_serial_new=FALSE; 
0033A:  BCF    x60.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0033C:  SETF   x63
0033E:  SETF   x62
....................    modbus_serial_state=MODBUS_GETADDY; 
00340:  CLRF   x61
....................    modbus_enable_timeout(FALSE); 
00342:  MOVLB  3
00344:  CLRF   x28
00346:  MOVLB  0
00348:  RCALL  030A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0034A:  BCF    FF2.2
0034C:  GOTO   009C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
003EC:  MOVLB  1
003EE:  MOVF   x63,W
003F0:  MOVLB  3
003F2:  XORWF  x28,W
003F4:  MOVWF  x29
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
003F6:  CLRF   03
003F8:  MOVF   x29,W
003FA:  MOVLB  0
003FC:  RCALL  00EA
003FE:  MOVWF  01
00400:  MOVLB  1
00402:  MOVF   x62,W
00404:  XORWF  01,W
00406:  MOVWF  x63
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
00408:  CLRF   03
0040A:  MOVLB  3
0040C:  MOVF   x29,W
0040E:  MOVLB  0
00410:  RCALL  01FA
00412:  MOVFF  FE8,162
.................... } 
00416:  GOTO   0478 (RETURN)
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, rs232); 
.................... 	modbus_calc_crc(c); 
.................... 	delay_us(53); 
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
....................    modbus_serial_new=FALSE; 
....................  
....................    RCV_OFF(); 
....................     
....................  
....................  
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    modbus_serial_putc(to); 
....................    modbus_serial_putc(func); 
.................... } 
....................  
.................... void modbus_serial_send_stop() { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
....................    crc_low=modbus_serial_crc.b[0]; 
....................  
....................    modbus_serial_putc(crc_high); 
....................    modbus_serial_putc(crc_low); 
....................  
....................    WAIT_FOR_HW_BUFFER(); 
....................      
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    RCV_ON(); 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
....................       return FALSE; 
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
....................       modbus_rx.len = 1; 
....................    } 
....................    modbus_serial_new=FALSE; 
....................    return TRUE; 
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "interrupt.c" 
.................... #int_timer2 
.................... void isr_1ms(void) { 
.................... 	static int16 telem_count=0; 
.................... 	output_high(TP_RED); 
*
00350:  BCF    F93.6
00352:  BSF    F8A.6
.................... 	 
.................... 	if ( timer.vcs_query_age < 65535 ) 
00354:  MOVLB  1
00356:  INCFSZ x53,W
00358:  BRA    0360
0035A:  INCFSZ x54,W
0035C:  BRA    0360
0035E:  BRA    0366
.................... 		timer.vcs_query_age++; 
00360:  INCF   x53,F
00362:  BTFSC  FD8.2
00364:  INCF   x54,F
....................  
.................... 	if ( timer.vcs_last_data_age < 65535 ) 
00366:  INCFSZ x56,W
00368:  BRA    0370
0036A:  INCFSZ x57,W
0036C:  BRA    0370
0036E:  BRA    0376
.................... 		timer.vcs_last_data_age++; 
00370:  INCF   x56,F
00372:  BTFSC  FD8.2
00374:  INCF   x57,F
....................  
....................  
.................... 	/* data ages */ 
.................... 	if ( timer.xrw2g_age < 65535 ) 
00376:  MOVLB  0
00378:  INCFSZ xB1,W
0037A:  BRA    0382
0037C:  INCFSZ xB2,W
0037E:  BRA    0382
00380:  BRA    0388
.................... 		timer.xrw2g_age++; 
00382:  INCF   xB1,F
00384:  BTFSC  FD8.2
00386:  INCF   xB2,F
....................  
....................  
.................... 	if ( telem_count < 10000 ) { 
00388:  MOVLB  2
0038A:  MOVF   x68,W
0038C:  SUBLW  27
0038E:  BNC   03A0
00390:  BNZ   0398
00392:  MOVF   x67,W
00394:  SUBLW  0F
00396:  BNC   03A0
.................... 		telem_count++; 
00398:  INCF   x67,F
0039A:  BTFSC  FD8.2
0039C:  INCF   x68,F
.................... 	} else { 
0039E:  BRA    03AC
.................... 		timer.now_telem=1; 
003A0:  MOVLW  01
003A2:  MOVLB  1
003A4:  MOVWF  x5D
.................... 		telem_count=0; 
003A6:  MOVLB  2
003A8:  CLRF   x68
003AA:  CLRF   x67
.................... 	} 
....................  
....................  
.................... 	/* LED Green */ 
.................... 	if ( 0==timer.led_on_green ) { 
003AC:  MOVLB  1
003AE:  MOVF   x5A,F
003B0:  BNZ   03BC
003B2:  MOVF   x5B,F
003B4:  BNZ   03BC
.................... 		output_low(LED_GREEN); 
003B6:  BCF    F93.4
003B8:  BCF    F8A.4
.................... 	} else { 
003BA:  BRA    03C8
.................... 		output_high(LED_GREEN); 
003BC:  BCF    F93.4
003BE:  BSF    F8A.4
.................... 		timer.led_on_green--; 
003C0:  MOVF   x5A,W
003C2:  BTFSC  FD8.2
003C4:  DECF   x5B,F
003C6:  DECF   x5A,F
.................... 	} 
....................  
.................... #if 0 
.................... 	/* LED Red */ 
.................... 	if ( 0==timer.led_on_red ) { 
.................... 		output_low(LED_RED); 
.................... 	} else { 
.................... 		output_high(LED_RED); 
.................... 		timer.led_on_red--; 
.................... 	} 
.................... #endif 
....................  
.................... 	output_low(TP_RED); 
003C8:  BCF    F93.6
003CA:  BCF    F8A.6
.................... } 
....................  
003CC:  BCF    F9E.1
003CE:  MOVLB  0
003D0:  GOTO   009C
.................... #int_rda 
.................... void isr_serial_inverter(void) { 
.................... 	int8 c; 
.................... 	output_high(TP_ORANGE); 
*
0041A:  BCF    F93.7
0041C:  BSF    F8A.7
....................  
.................... 	c=fgetc(rs232); 
0041E:  BRA    03D4
00420:  MOVFF  01,327
....................  
.................... 	if ( timer.modbus_enable )  { 
00424:  MOVF   2B,F
00426:  BZ    0482
.................... 		if ( ! modbus_serial_new) { 
00428:  MOVLB  1
0042A:  BTFSC  x60.0
0042C:  BRA    0484
.................... 			if ( modbus_serial_state == MODBUS_GETADDY) { 
0042E:  MOVF   x61,F
00430:  BNZ   0442
.................... 				modbus_serial_crc.d = 0xFFFF; 
00432:  SETF   x63
00434:  SETF   x62
.................... 				modbus_rx.address = c; 
00436:  MOVFF  327,164
.................... 				modbus_serial_state++; 
0043A:  INCF   x61,F
.................... 				modbus_rx.len = 0; 
0043C:  CLRF   x65
.................... 				modbus_rx.error=0; 
0043E:  CLRF   x67
.................... 			} else if ( modbus_serial_state == MODBUS_GETFUNC) { 
00440:  BRA    0470
00442:  DECFSZ x61,W
00444:  BRA    044E
.................... 				modbus_rx.func = c; 
00446:  MOVFF  327,166
.................... 				modbus_serial_state++; 
0044A:  INCF   x61,F
.................... 			} else if(modbus_serial_state == MODBUS_GETDATA) { 
0044C:  BRA    0470
0044E:  MOVF   x61,W
00450:  SUBLW  02
00452:  BNZ   0470
.................... 				if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00454:  INCFSZ x65,W
00456:  BRA    045C
.................... 					modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00458:  MOVLW  FE
0045A:  MOVWF  x65
.................... 				} 
.................... 				modbus_rx.data[modbus_rx.len]=c; 
0045C:  MOVLW  68
0045E:  ADDWF  x65,W
00460:  MOVWF  FE9
00462:  MOVLW  01
00464:  MOVWF  FEA
00466:  BTFSC  FD8.0
00468:  INCF   FEA,F
0046A:  MOVFF  327,FEF
.................... 				modbus_rx.len++; 
0046E:  INCF   x65,F
.................... 			} 
.................... 	 
.................... 			modbus_calc_crc(c); 
00470:  MOVFF  327,328
00474:  MOVLB  0
00476:  BRA    03EC
.................... 			modbus_enable_timeout(TRUE); 
00478:  MOVLW  01
0047A:  MOVLB  3
0047C:  MOVWF  x28
0047E:  MOVLB  0
00480:  RCALL  030A
00482:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	 
.................... 	output_low(TP_ORANGE); 
00484:  BCF    F93.7
00486:  BCF    F8A.7
.................... } 
....................  
....................  
....................  
00488:  BCF    F9E.5
0048A:  MOVLB  0
0048C:  GOTO   009C
.................... #inline 
.................... void can_receive(void) { 
.................... 	int8 buffer[8]; 
.................... 	int32 rx_id; 
.................... 	int8 rx_len; 
.................... 	struct rx_stat rx; 
....................  
....................  
.................... 	if ( can_getd(rx_id,&buffer,rx_len,rx) ) { 
*
0068C:  MOVLW  03
0068E:  MOVLB  3
00690:  MOVWF  x36
00692:  MOVLW  27
00694:  MOVWF  x35
*
0079E:  MOVF   01,F
007A0:  BZ    082C
*
0083E:  MOVLW  03
00840:  MOVLB  3
00842:  MOVWF  x36
00844:  MOVLW  27
00846:  MOVWF  x35
*
00950:  MOVF   01,F
00952:  BZ    09DE
.................... 		/* got something! */ 
.................... 		timer.led_on_green=50; 
*
007A2:  MOVLB  1
007A4:  CLRF   x5B
007A6:  MOVLW  32
007A8:  MOVWF  x5A
*
00954:  MOVLB  1
00956:  CLRF   x5B
00958:  MOVLW  32
0095A:  MOVWF  x5A
....................  
.................... 		/* VCS is ID ... ignore everything else */ 
.................... 		if ( 3 != rx_id ) 
*
007AA:  MOVLB  3
007AC:  MOVF   x2F,W
007AE:  SUBLW  03
007B0:  BNZ   07BE
007B2:  MOVF   x30,F
007B4:  BNZ   07BE
007B6:  MOVF   x31,F
007B8:  BNZ   07BE
007BA:  MOVF   x32,F
007BC:  BZ    07C0
*
0095C:  MOVLB  3
0095E:  MOVF   x2F,W
00960:  SUBLW  03
00962:  BNZ   0970
00964:  MOVF   x30,F
00966:  BNZ   0970
00968:  MOVF   x31,F
0096A:  BNZ   0970
0096C:  MOVF   x32,F
0096E:  BZ    0972
.................... 			return; 
*
007BE:  BRA    082E
*
00970:  BRA    09E0
....................  
.................... 		if ( 8 != rx_len ) 
*
007C0:  MOVF   x33,W
007C2:  SUBLW  08
007C4:  BZ    07C8
*
00972:  MOVF   x33,W
00974:  SUBLW  08
00976:  BZ    097A
.................... 			return; 
*
007C6:  BRA    082E
*
00978:  BRA    09E0
....................  
.................... 		/* make sure register number is in range */ 
.................... 		if ( buffer[0] >= VCS_N_REGISTERS )  
*
007C8:  MOVF   x27,W
007CA:  SUBLW  27
007CC:  BC    07D0
*
0097A:  MOVF   x27,W
0097C:  SUBLW  27
0097E:  BC    0982
.................... 			return; 
*
007CE:  BRA    082E
*
00980:  BRA    09E0
....................  
.................... 		timer.dump_register=buffer[0]; 
*
007D0:  MOVFF  327,15C
*
00982:  MOVFF  327,15C
....................  
.................... 		/* re-use rx_len */ 
.................... 		rx_len = buffer[0]<<2; 
*
007D4:  RLCF   x27,W
007D6:  MOVWF  x33
007D8:  RLCF   x33,F
007DA:  MOVLW  FC
007DC:  ANDWF  x33,F
*
00986:  RLCF   x27,W
00988:  MOVWF  x33
0098A:  RLCF   x33,F
0098C:  MOVLW  FC
0098E:  ANDWF  x33,F
....................  
.................... 		/* copy CAN data into appropriate register */ 
.................... 		timer.vcs_register[rx_len + 0]=buffer[4]; 
*
007DE:  MOVLW  B3
007E0:  ADDWF  x33,W
007E2:  MOVWF  FE9
007E4:  CLRF   FEA
007E6:  BTFSC  FD8.0
007E8:  INCF   FEA,F
007EA:  MOVFF  32B,FEF
*
00990:  MOVLW  B3
00992:  ADDWF  x33,W
00994:  MOVWF  FE9
00996:  CLRF   FEA
00998:  BTFSC  FD8.0
0099A:  INCF   FEA,F
0099C:  MOVFF  32B,FEF
.................... 		timer.vcs_register[rx_len + 1]=buffer[5]; 
*
007EE:  MOVLW  01
007F0:  ADDWF  x33,W
007F2:  ADDLW  B3
007F4:  MOVWF  FE9
007F6:  CLRF   FEA
007F8:  BTFSC  FD8.0
007FA:  INCF   FEA,F
007FC:  MOVFF  32C,FEF
*
009A0:  MOVLW  01
009A2:  ADDWF  x33,W
009A4:  ADDLW  B3
009A6:  MOVWF  FE9
009A8:  CLRF   FEA
009AA:  BTFSC  FD8.0
009AC:  INCF   FEA,F
009AE:  MOVFF  32C,FEF
.................... 		timer.vcs_register[rx_len + 2]=buffer[6]; 
*
00800:  MOVLW  02
00802:  ADDWF  x33,W
00804:  ADDLW  B3
00806:  MOVWF  FE9
00808:  CLRF   FEA
0080A:  BTFSC  FD8.0
0080C:  INCF   FEA,F
0080E:  MOVFF  32D,FEF
*
009B2:  MOVLW  02
009B4:  ADDWF  x33,W
009B6:  ADDLW  B3
009B8:  MOVWF  FE9
009BA:  CLRF   FEA
009BC:  BTFSC  FD8.0
009BE:  INCF   FEA,F
009C0:  MOVFF  32D,FEF
.................... 		timer.vcs_register[rx_len + 3]=buffer[7]; 
*
00812:  MOVLW  03
00814:  ADDWF  x33,W
00816:  ADDLW  B3
00818:  MOVWF  FE9
0081A:  CLRF   FEA
0081C:  BTFSC  FD8.0
0081E:  INCF   FEA,F
00820:  MOVFF  32E,FEF
*
009C4:  MOVLW  03
009C6:  ADDWF  x33,W
009C8:  ADDLW  B3
009CA:  MOVWF  FE9
009CC:  CLRF   FEA
009CE:  BTFSC  FD8.0
009D0:  INCF   FEA,F
009D2:  MOVFF  32E,FEF
....................  
.................... 		/* reset last data received timer */ 
.................... 		timer.vcs_last_data_age=0; 
*
00824:  MOVLB  1
00826:  CLRF   x57
00828:  CLRF   x56
0082A:  MOVLB  F
0082C:  MOVLB  3
*
009D6:  MOVLB  1
009D8:  CLRF   x57
009DA:  CLRF   x56
009DC:  MOVLB  F
009DE:  MOVLB  3
.................... 	} 
.................... } 
....................  
....................  
.................... #INT_CANRX0 
.................... void isr_can_rx0(void) { 
.................... 	output_high(TP_ORANGE); 
*
00688:  BCF    F93.7
0068A:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
0082E:  BCF    F93.7
00830:  BCF    F8A.7
.................... } 
....................  
00832:  BCF    FA4.0
00834:  MOVLB  0
00836:  GOTO   009C
.................... #INT_CANRX1 
.................... void isr_can_rx1(void) { 
.................... 	output_high(TP_ORANGE); 
0083A:  BCF    F93.7
0083C:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
009E0:  BCF    F93.7
009E2:  BCF    F8A.7
.................... } 
....................  
....................  
009E4:  BCF    FA4.1
009E6:  MOVLB  0
009E8:  GOTO   009C
.................... #INT_CANIRX 
.................... /* CAN packet error lights up RED led for two seconds */ 
.................... void isr_canirx() { 
.................... 	clear_interrupt(INT_CANIRX); 
*
00000:  BCF    FA4.7
.................... //	timer.led_on_red=2000; 
.................... } 
....................  
.................... #include "param.c" 
00002:  BCF    FA4.7
00004:  GOTO   009C
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00ED4:  MOVF   x76,W
00ED6:  XORWF  x77,W
00ED8:  MOVWF  01
*
00F26:  MOVF   x76,W
00F28:  XORWF  x77,W
00F2A:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00E64:  MOVLB  2
00E66:  CLRF   x73
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00E68:  MOVFF  272,03
00E6C:  MOVF   x71,W
00E6E:  BTFSC  FD8.2
00E70:  DECF   x72,F
00E72:  DECF   x71,F
00E74:  MOVWF  x74
00E76:  MOVFF  03,275
00E7A:  MOVF   x74,F
00E7C:  BNZ   0E82
00E7E:  MOVF   x75,F
00E80:  BZ    0EE6
.................... 		*data = read_eeprom( address++ ); 
00E82:  MOVFF  270,03
00E86:  MOVF   x6F,W
00E88:  MOVWF  FE9
00E8A:  MOVFF  03,FEA
00E8E:  MOVF   x6E,W
00E90:  MOVWF  03
00E92:  MOVF   x6D,W
00E94:  INCF   x6D,F
00E96:  BTFSC  FD8.2
00E98:  INCF   x6E,F
00E9A:  MOVWF  x76
00E9C:  MOVFF  03,277
00EA0:  MOVFF  FF2,278
00EA4:  BCF    FF2.7
00EA6:  MOVFF  277,FAA
00EAA:  MOVFF  276,FA9
00EAE:  BCF    FA6.6
00EB0:  BCF    FA6.7
00EB2:  BSF    FA6.0
00EB4:  MOVF   FA8,W
00EB6:  BTFSC  x78.7
00EB8:  BSF    FF2.7
00EBA:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00EBC:  MOVFF  270,03
00EC0:  MOVF   x6F,W
00EC2:  MOVWF  FE9
00EC4:  MOVFF  03,FEA
00EC8:  MOVFF  FEF,274
00ECC:  MOVFF  273,276
00ED0:  MOVFF  274,277
*
00EDA:  MOVFF  01,273
.................... 		data++; 
00EDE:  INCF   x6F,F
00EE0:  BTFSC  FD8.2
00EE2:  INCF   x70,F
.................... 	} 
00EE4:  BRA    0E68
.................... 	return crc; 
00EE6:  MOVFF  273,01
.................... } 
00EEA:  MOVLB  0
00EEC:  GOTO   103C (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00EF0:  MOVLB  2
00EF2:  CLRF   x74
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00EF4:  MOVFF  273,03
00EF8:  MOVF   x72,W
00EFA:  BTFSC  FD8.2
00EFC:  DECF   x73,F
00EFE:  DECF   x72,F
00F00:  MOVWF  x75
00F02:  MOVFF  03,276
00F06:  MOVF   x75,F
00F08:  BNZ   0F0E
00F0A:  MOVF   x76,F
00F0C:  BZ    0F8A
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00F0E:  MOVFF  271,03
00F12:  MOVF   x70,W
00F14:  MOVWF  FE9
00F16:  MOVFF  03,FEA
00F1A:  MOVFF  FEF,275
00F1E:  MOVFF  274,276
00F22:  MOVFF  275,277
*
00F2C:  MOVFF  01,274
.................... 		write_eeprom( address++, *data++ ); 
00F30:  MOVF   x6F,W
00F32:  MOVWF  03
00F34:  MOVF   x6E,W
00F36:  INCF   x6E,F
00F38:  BTFSC  FD8.2
00F3A:  INCF   x6F,F
00F3C:  MOVWF  x75
00F3E:  MOVFF  03,276
00F42:  MOVF   x71,W
00F44:  MOVWF  03
00F46:  MOVF   x70,W
00F48:  INCF   x70,F
00F4A:  BTFSC  FD8.2
00F4C:  INCF   x71,F
00F4E:  MOVWF  FE9
00F50:  MOVFF  03,FEA
00F54:  MOVFF  FEF,277
00F58:  MOVFF  276,FAA
00F5C:  MOVFF  275,FA9
00F60:  MOVFF  277,FA8
00F64:  BCF    FA6.6
00F66:  BCF    FA6.7
00F68:  BSF    FA6.2
00F6A:  MOVF   FF2,W
00F6C:  MOVWF  00
00F6E:  BCF    FF2.7
00F70:  MOVLB  F
00F72:  MOVLW  55
00F74:  MOVWF  FA7
00F76:  MOVLW  AA
00F78:  MOVWF  FA7
00F7A:  BSF    FA6.1
00F7C:  BTFSC  FA6.1
00F7E:  BRA    0F7C
00F80:  BCF    FA6.2
00F82:  MOVF   00,W
00F84:  IORWF  FF2,F
.................... 	} 
00F86:  MOVLB  2
00F88:  BRA    0EF4
....................  
.................... 	return crc; 
00F8A:  MOVFF  274,01
.................... } 
00F8E:  MOVLB  0
00F90:  GOTO   0FB6 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	restart_wdt(); 
00F94:  CLRWDT
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00F96:  MOVLB  2
00F98:  CLRF   x6D
00F9A:  MOVLW  20
00F9C:  MOVWF  x6C
00F9E:  CLRF   x6F
00FA0:  MOVLW  01
00FA2:  MOVWF  x6E
00FA4:  MOVFF  26D,271
00FA8:  MOVFF  26C,270
00FAC:  CLRF   x73
00FAE:  MOVLW  0B
00FB0:  MOVWF  x72
00FB2:  MOVLB  0
00FB4:  BRA    0EF0
00FB6:  MOVFF  01,26B
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00FBA:  CLRF   FAA
00FBC:  CLRF   FA9
00FBE:  MOVFF  26B,FA8
00FC2:  BCF    FA6.6
00FC4:  BCF    FA6.7
00FC6:  BSF    FA6.2
00FC8:  MOVF   FF2,W
00FCA:  MOVWF  00
00FCC:  BCF    FF2.7
00FCE:  MOVLB  F
00FD0:  MOVLW  55
00FD2:  MOVWF  FA7
00FD4:  MOVLW  AA
00FD6:  MOVWF  FA7
00FD8:  BSF    FA6.1
00FDA:  BTFSC  FA6.1
00FDC:  BRA    0FDA
00FDE:  BCF    FA6.2
00FE0:  MOVF   00,W
00FE2:  IORWF  FF2,F
....................  
.................... 	restart_wdt(); 
00FE4:  CLRWDT
.................... } 
00FE6:  MOVLB  0
00FE8:  GOTO   101A (RETURN)
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timer.led_on_red=150; 
00FEC:  MOVLB  1
00FEE:  CLRF   x59
00FF0:  MOVLW  96
00FF2:  MOVWF  x58
.................... //	fprintf(world,"# writing default parameters\r\n"); 
....................  
.................... 	config.revision='a'; 
00FF4:  MOVLW  61
00FF6:  MOVWF  20
....................  
.................... 	config.serial_prefix='A'; //SERIAL_PREFIX_DEFAULT; 
00FF8:  MOVLW  41
00FFA:  MOVWF  22
.................... 	config.serial_number=4745; //SERIAL_NUMBER_DEFAULT; 
00FFC:  MOVLW  12
00FFE:  MOVWF  24
01000:  MOVLW  89
01002:  MOVWF  23
....................  
....................  
.................... 	config.sensor_source=SENSOR_SOURCE_ONBOARD; 
01004:  CLRF   28
....................  
.................... 	config.world_to_xbee=0; 
01006:  CLRF   29
.................... 	config.world_to_xport=1; 
01008:  MOVLW  01
0100A:  MOVWF  2A
....................  
.................... 	config.pair_serial_prefix=0; 
0100C:  CLRF   25
.................... 	config.pair_serial_number=0; 
0100E:  CLRF   27
01010:  CLRF   26
....................  
.................... 	config.modbus_address=29; 
01012:  MOVLW  1D
01014:  MOVWF  21
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
01016:  MOVLB  0
01018:  BRA    0F94
....................  
.................... } 
0101A:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
0101C:  MOVLB  2
0101E:  CLRF   x6C
01020:  MOVLW  20
01022:  MOVWF  x6B
01024:  CLRF   x6E
01026:  MOVLW  01
01028:  MOVWF  x6D
0102A:  MOVFF  26C,270
0102E:  MOVFF  26B,26F
01032:  CLRF   x72
01034:  MOVLW  0B
01036:  MOVWF  x71
01038:  MOVLB  0
0103A:  BRA    0E64
0103C:  MOVFF  01,26A
....................  
.................... //	fprintf(modem,"# read_param_file()\r\n"); 
.................... //	print_param_file(); 
....................  
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) { 
01040:  MOVFF  FF2,26B
01044:  BCF    FF2.7
01046:  CLRF   FAA
01048:  CLRF   FA9
0104A:  BCF    FA6.6
0104C:  BCF    FA6.7
0104E:  BSF    FA6.0
01050:  MOVF   FA8,W
01052:  MOVLB  2
01054:  BTFSC  x6B.7
01056:  BSF    FF2.7
01058:  SUBWF  x6A,W
0105A:  BNZ   1068
0105C:  MOVF   20,W
0105E:  SUBLW  60
01060:  BC    1068
01062:  MOVF   20,W
01064:  SUBLW  7A
01066:  BC    106E
.................... 		write_default_param_file(); 
01068:  MOVLB  0
0106A:  RCALL  0FEC
0106C:  MOVLB  2
.................... 	} 
....................  
.................... } 
0106E:  MOVLB  0
01070:  GOTO   17AA (RETURN)
....................  
....................  
.................... #include "modbus_handler_vcstap.c" 
.................... #define MAX_DATA_REGISTER   100 
....................  
.................... #define MIN_CONFIG_REGISTER 1000 
.................... #define MAX_CONFIG_REGISTER 1011 
....................  
....................  
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	int16 val; 
.................... 	int8 i; 
....................  
.................... 	/* VCS registers */ 
.................... 	if ( addr >= 3 && addr <= 83 ) { 
.................... 		addr -= 3; 
....................  
.................... 		i=addr % 2; 
.................... 		if ( 1 == i ) 
.................... 			addr -= 1; 
....................  
.................... 		addr = addr >> 1; 
....................  
.................... 		timer.vcs_read_lock=1; 
.................... 		 
....................  
.................... 		return 0; 
.................... 	} 
....................  
.................... 	/* XRW2G data */ 
....................  
.................... 	switch ( addr ) { 
.................... 		 
.................... 		/* data */ 
.................... 		case   0: return 0; /* VCS control register ... always reads as 0 */ 
.................... 		case   1: return timer.vcs_query_age; 
.................... 		case   2: return timer.xrw2g_age; 
....................  
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return config.serial_prefix; 
.................... 		case 1001: return config.serial_number; 
.................... 		case 1002: return 'V'; 
.................... 		case 1003: return 'C'; 
.................... 		case 1004: return 'S'; 
.................... 		case 1005: return  0; 
.................... 		case 1006: return config.modbus_address; 
.................... 		case 1007: return config.sensor_source; 
.................... 		case 1008: return config.pair_serial_prefix; 
.................... 		case 1009: return config.pair_serial_number; 
.................... 		case 1010: return config.world_to_xbee; 
.................... 		case 1011: return config.world_to_xport; 
....................  
.................... 	    
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return 65535; 
.................... 	} 
....................  
.................... } 
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( start <= MAX_DATA_REGISTER && end <= MAX_DATA_REGISTER+1 )  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	/* factory unlock */ 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	/* write eeprom */ 
.................... 	if ( start >= 1998 && end <= 2000+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
.................... 	modbus_serial_putc(register_count*2); 
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
.................... 		l=map_modbus(start_address+i); 
.................... 		modbus_serial_putc(make8(l,1)); 
....................   		modbus_serial_putc(make8(l,0)); 
.................... 	} 
....................  
.................... 	modbus_serial_send_stop(); 
.................... } 
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( timer.factory_unlocked ) { 
.................... 		if ( 1000 == address ) { 
.................... 			config.serial_prefix=value; 
.................... 			return 0; 
.................... 		} else if ( 1001 == address ) { 
.................... 			config.serial_number=value; 
.................... 			return 0; 
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.modbus_address=value; 
.................... 			break; 
....................                 case 1007: 
....................                         if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
....................                         config.sensor_source=value; 
....................                         break; 
....................                 case 1008: 
....................                         if ( value > 255 ) return ILLEGAL_DATA_VALUE; 
....................                         config.pair_serial_prefix=value; 
....................                         break; 
....................                 case 1009: 
....................                         config.pair_serial_number=value; 
....................                         break; 
.................... 		case 1010: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xbee=value; 
.................... 			break; 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xport=value; 
.................... 			break; 
.................... 		case 1997: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			reset_cpu(); 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_default_param_file(); 
.................... 			break; 
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_param_file(); 
.................... 			break; 
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
.................... 				timer.factory_unlocked=0; 
.................... 				return ILLEGAL_DATA_VALUE; 
.................... 			} 
.................... 			timer.factory_unlocked=1; 
.................... 			/* green LED for 2 seconds */ 
.................... 			timer.led_on_green=200; 
.................... 			timer.led_on_red=0; 
.................... 			break; 
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
.................... 		/* check if it is addressed to us */ 
.................... 		if ( modbus_rx.address==config.modbus_address ) {	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=0; 
....................  
.................... 			switch(modbus_rx.func) { 
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
.................... 						timer.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					} else { 
.................... 						modbus_read_register_response(config.modbus_address,start_addr,num_registers); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
....................  
.................... 					if ( result ) { 
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 						timer.modbus_last_error=result; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					}  else { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(config.modbus_address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
....................  
.................... 						if ( result ) { 
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 							timer.modbus_last_error=result; 
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timer.led_on_red=100; 
.................... 							timer.led_on_green=0; 
.................... 			 
.................... 							break; 
.................... 						} 
.................... 					} 
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers); 
.................... 					} 
....................  
.................... 					break;   
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION); 
.................... 					timer.modbus_last_error=ILLEGAL_FUNCTION; 
....................  
.................... 					/* red led for 1 second */ 
.................... 					timer.led_on_red=100; 
.................... 					timer.led_on_green=0; 
.................... 			} 
.................... 		} else { 
.................... 			/* MODBUS packet for somebody else */ 
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=20; 
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void init() { 
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
00DEC:  MOVLW  72
00DEE:  MOVWF  FD3
00DF0:  MOVF   FD3,W
.................... 	setup_adc(ADC_OFF); 
00DF2:  BCF    FC2.0
.................... 	/*  
.................... 	setup_adc_ports(NO_ANALOGS); doesn't seem to work.  
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital 
.................... 	*/ 
.................... //	ANCON0=0xff; 
.................... //	ANCON1=0x1f; 
.................... 	 
.................... 	 
.................... //	setup_comparator(NC_NC_NC_NC); 
....................  
.................... 	setup_timer_2(T2_DIV_BY_16,61,2); // set 1 millisecond period with 8 MHz oscillator 
00DF4:  MOVLW  08
00DF6:  IORLW  06
00DF8:  MOVWF  FCA
00DFA:  MOVLW  3D
00DFC:  MOVWF  FCB
....................  
.................... 	port_b_pullups(TRUE); 
00DFE:  BCF    FF1.7
.................... 	delay_ms(10); 
00E00:  MOVLW  0A
00E02:  MOVLB  2
00E04:  MOVWF  x6A
00E06:  MOVLB  0
00E08:  RCALL  0A20
.................... 	 
.................... 	output_low(SYNC_OUT); 
00E0A:  BCF    F94.5
00E0C:  BCF    F8B.5
....................  
....................  
.................... 	timer.modbus_enable=FALSE; 
00E0E:  CLRF   2B
....................  
....................  
.................... 	/* xrw2g uart */ 
.................... 	uart_init(); 
00E10:  BRA    0AFC
....................  
.................... 	/* CAN interface to VCS */ 
.................... 	can_init(); 
00E12:  RCALL  0CE0
.................... 	/* set receive filter so we only get data from CAN ID 3*/ 
.................... //	can_set_mode(CAN_OP_CONFIG);  
.................... //	can_set_id(RX0MASK,0x003,false); ??? 
.................... //	can_set_mode(CAN_OP_NORMAL);  
....................    // mask bit n | filter bit n | message ID bit n | result 
....................    //     0             x               x             accept 
....................    //     1             0               0             accept 
....................    //     1             0               1             reject 
....................    //     1             1               0             reject 
....................    //     1             1               1             accept 
.................... 	/* receive and receiver error interrupts */ 
.................... 	enable_interrupts(INT_CANRX0);  
00E14:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1);  
00E16:  BSF    FA3.1
.................... 	enable_interrupts(INT_CANIRX); 
00E18:  BSF    FA3.7
....................  
....................  
....................  
.................... 	/* global structures */ 
.................... 	timer.factory_unlocked=0; 
00E1A:  CLRF   2D
.................... 	timer.telem_age=0; 
00E1C:  CLRF   2F
00E1E:  CLRF   2E
....................  
.................... 	timer.xrw2g_age=65535; 
00E20:  SETF   xB2
00E22:  SETF   xB1
.................... 	timer.xrw2g_buff_pos=0; 
00E24:  CLRF   xB0
.................... 	memset(timer.xrw2g_packet, 0, sizeof(timer.xrw2g_packet)); 
00E26:  CLRF   FEA
00E28:  MOVLW  30
00E2A:  MOVWF  FE9
00E2C:  CLRF   00
00E2E:  CLRF   02
00E30:  MOVLW  80
00E32:  MOVWF  01
00E34:  RCALL  0DD2
....................  
.................... 	timer.vcs_read_lock=0; 
00E36:  MOVLB  1
00E38:  CLRF   x55
.................... 	timer.vcs_query_age=0; 
00E3A:  CLRF   x54
00E3C:  CLRF   x53
.................... 	timer.vcs_last_data_age=65535; 
00E3E:  SETF   x57
00E40:  SETF   x56
.................... 	memset(timer.vcs_register, 0, sizeof(timer.vcs_register)); 
00E42:  CLRF   FEA
00E44:  MOVLW  B3
00E46:  MOVWF  FE9
00E48:  CLRF   00
00E4A:  CLRF   02
00E4C:  MOVLW  A0
00E4E:  MOVWF  01
00E50:  MOVLB  0
00E52:  RCALL  0DD2
....................  
.................... 	timer.dump_register=255;  
00E54:  MOVLB  1
00E56:  SETF   x5C
.................... 	timer.now_telem=0; 
00E58:  CLRF   x5D
....................  
.................... 	/* receive data from serial ports */ 
.................... 	enable_interrupts(INT_RDA);  /* inverter */ 
00E5A:  BSF    F9D.5
.................... //	enable_interrupts(INT_RDA2); /* world (ethernet or xbee */ 
....................  
.................... 	/* timer0 is used for modbus handler */ 
....................  
.................... 	/* 1 millisecond timer */ 
.................... 	enable_interrupts(INT_TIMER2); 
00E5C:  BSF    F9D.1
....................  
....................  
.................... } 
00E5E:  MOVLB  0
00E60:  GOTO   17A8 (RETURN)
....................  
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... void read_data_xrw2g(void) { 
.................... 	int8 c; 
....................  
.................... 	if ( uart_kbhit() ) { 
*
0125E:  RCALL  124C
01260:  MOVF   01,F
01262:  BZ    1296
.................... 		while ( uart_kbhit() ) { 
01264:  RCALL  124C
01266:  MOVF   01,F
01268:  BZ    1296
.................... //			output_high(TP_ORANGE); 
.................... 			c=uart_getc(); 
*
01274:  MOVFF  01,26A
.................... //			output_low(TP_ORANGE); 
.................... 			timer.xrw2g_age=0; 
01278:  CLRF   xB2
0127A:  CLRF   xB1
....................  
.................... 			if ( timer.xrw2g_buff_pos < sizeof(timer.xrw2g_packet) ) { 
0127C:  MOVF   xB0,W
0127E:  SUBLW  7F
01280:  BNC   1294
.................... 				timer.xrw2g_packet[timer.xrw2g_buff_pos++]=c; 
01282:  MOVF   xB0,W
01284:  INCF   xB0,F
01286:  ADDLW  30
01288:  MOVWF  FE9
0128A:  CLRF   FEA
0128C:  BTFSC  FD8.0
0128E:  INCF   FEA,F
01290:  MOVFF  26A,FEF
.................... 			} 
.................... 		} 
01294:  BRA    1264
.................... 	} 
.................... } 
01296:  GOTO   1850 (RETURN)
....................  
....................  
.................... void send_can_query(int8 queryRegister) { 
.................... 	unsigned int32 can_id; 
.................... 	unsigned int8 data[4]; 
....................  
.................... 	/* message ID 3 is query */ 
.................... 	can_id=(int32) 3; 
*
0136C:  MOVLB  2
0136E:  CLRF   x6F
01370:  CLRF   x6E
01372:  CLRF   x6D
01374:  MOVLW  03
01376:  MOVWF  x6C
....................  
.................... 	data[0]=queryRegister; 
01378:  MOVFF  26B,270
.................... 	data[1]=0x00; 
0137C:  CLRF   x71
.................... 	data[2]=0x00; 
0137E:  CLRF   x72
.................... 	data[3]=0x00;  
01380:  CLRF   x73
....................  
.................... 	if ( 0 == can_putd(can_id,data,4,0,FALSE,FALSE) ) { 
01382:  MOVFF  26F,277
01386:  MOVFF  26E,276
0138A:  MOVFF  26D,275
0138E:  MOVFF  26C,274
01392:  MOVLW  02
01394:  MOVWF  x79
01396:  MOVLW  70
01398:  MOVWF  x78
0139A:  MOVLW  04
0139C:  MOVWF  x7A
0139E:  CLRF   x7B
013A0:  CLRF   x7C
013A2:  CLRF   x7D
013A4:  MOVLB  0
013A6:  BRA    129A
013A8:  MOVF   01,F
013AA:  BNZ   13B0
.................... 		can_abort(); 
013AC:  BSF    F6F.4
.................... 		can_init(); 
013AE:  RCALL  0CE0
.................... //		timer.led_on_red=50; 
.................... 	} 
....................  
.................... } 
013B0:  GOTO   1886 (RETURN)
....................  
....................  
.................... /* this is started after the bootloader is done loading or times out */ 
.................... void main(void) { 
*
0176C:  CLRF   FF8
0176E:  BCF    FD0.7
01770:  BSF    07.7
01772:  CLRF   FEA
01774:  CLRF   FE9
01776:  CLRF   1F
01778:  BCF    FB8.3
0177A:  MOVLW  0C
0177C:  MOVWF  FAF
0177E:  MOVLW  A2
01780:  MOVWF  FAC
01782:  MOVLW  90
01784:  MOVWF  FAB
01786:  MOVLB  1
01788:  CLRF   x5F
0178A:  CLRF   x5E
0178C:  BCF    x60.0
0178E:  CLRF   x61
01790:  MOVLB  2
01792:  CLRF   x68
01794:  CLRF   x67
01796:  MOVF   FC1,W
01798:  ANDLW  C0
0179A:  IORLW  0F
0179C:  MOVWF  FC1
0179E:  CLRF   19
017A0:  CLRF   1A
.................... 	int8 last; 
....................  
.................... 	/* normal device startup */ 
.................... 	init(); 
017A2:  MOVLB  0
017A4:  GOTO   0DEC
.................... 	read_param_file(); 
017A8:  BRA    101C
.................... 	 
.................... 	write_default_param_file(); 
017AA:  RCALL  0FEC
....................  
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	modbus_init(); 
....................  
.................... 	enable_interrupts(GLOBAL); 
017AC:  MOVLW  C0
017AE:  IORWF  FF2,F
....................  
.................... 	fprintf(rs232,"# (world) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
017B0:  MOVLW  EC
017B2:  MOVWF  FF6
017B4:  MOVLW  09
017B6:  MOVWF  FF7
017B8:  MOVLW  13
017BA:  MOVLB  2
017BC:  MOVWF  x6A
017BE:  MOVLB  0
017C0:  RCALL  1074
017C2:  MOVLW  16
017C4:  MOVWF  FF6
017C6:  MOVLW  0A
017C8:  MOVWF  FF7
017CA:  BRA    109E
017CC:  MOVLW  01
017CE:  MOVWF  FF6
017D0:  MOVLW  0A
017D2:  MOVWF  FF7
017D4:  MOVLW  0D
017D6:  MOVLB  2
017D8:  MOVWF  x6A
017DA:  MOVLB  0
017DC:  RCALL  1074
017DE:  MOVF   22,W
017E0:  BTFSS  F9E.4
017E2:  BRA    17E0
017E4:  MOVWF  FAD
017E6:  MOVLW  10
017E8:  MOVWF  FE9
017EA:  MOVFF  24,26B
017EE:  MOVFF  23,26A
017F2:  BRA    10C2
017F4:  MOVLW  0D
017F6:  BTFSS  F9E.4
017F8:  BRA    17F6
017FA:  MOVWF  FAD
017FC:  MOVLW  0A
017FE:  BTFSS  F9E.4
01800:  BRA    17FE
01802:  MOVWF  FAD
.................... //	fprintf(rs232,"# (rs232) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
....................  
.................... 	/* fast red, yellow, green */ 
.................... 	timer.led_on_red  =200; 
01804:  MOVLB  1
01806:  CLRF   x59
01808:  MOVLW  C8
0180A:  MOVWF  x58
.................... 	delay_ms(160); 
0180C:  MOVLW  A0
0180E:  MOVLB  2
01810:  MOVWF  x6A
01812:  MOVLB  0
01814:  CALL   0A20
.................... 	timer.led_on_green=400; 
01818:  MOVLW  01
0181A:  MOVLB  1
0181C:  MOVWF  x5B
0181E:  MOVLW  90
01820:  MOVWF  x5A
.................... 	delay_ms(160); 
01822:  MOVLW  A0
01824:  MOVLB  2
01826:  MOVWF  x6A
01828:  MOVLB  0
0182A:  CALL   0A20
.................... 	timer.led_on_red=0; 
0182E:  MOVLB  1
01830:  CLRF   x59
01832:  CLRF   x58
.................... 	delay_ms(160); 
01834:  MOVLW  A0
01836:  MOVLB  2
01838:  MOVWF  x6A
0183A:  MOVLB  0
0183C:  CALL   0A20
.................... 	timer.led_on_green=0; 
01840:  MOVLB  1
01842:  CLRF   x5B
01844:  CLRF   x5A
....................  
....................  
.................... 	last=0; 
01846:  MOVLB  2
01848:  CLRF   x69
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
0184A:  CLRWDT
....................  
.................... 		/* read data from our different sources */ 
.................... 		read_data_xrw2g(); 
0184C:  MOVLB  0
0184E:  BRA    125E
.................... 		 
.................... 		/* transmit buffer empty */ 
.................... 		if ( can_tbe() && timer.vcs_query_age>=25 ) { 
01850:  MOVLB  F
01852:  BTFSS  x40.3
01854:  BRA    185E
01856:  BTFSS  x30.3
01858:  BRA    185E
0185A:  BTFSC  x20.3
0185C:  BRA    188C
0185E:  MOVLB  1
01860:  MOVF   x54,F
01862:  BNZ   1870
01864:  MOVF   x53,W
01866:  SUBLW  18
01868:  BTFSS  FD8.0
0186A:  BRA    1870
0186C:  MOVLB  F
0186E:  BRA    188C
.................... 			/* loop through our list of registers */ 
.................... 			if ( last == VCS_N_REGISTERS ) 
01870:  MOVLB  2
01872:  MOVF   x69,W
01874:  SUBLW  28
01876:  BNZ   187A
.................... 				last=0; 
01878:  CLRF   x69
....................  
.................... 			send_can_query(last++); 
0187A:  MOVF   x69,W
0187C:  INCF   x69,F
0187E:  MOVWF  x6A
01880:  MOVWF  x6B
01882:  MOVLB  0
01884:  BRA    136C
.................... //			send_can_query(10); 
.................... 			timer.vcs_query_age=0; 
01886:  MOVLB  1
01888:  CLRF   x54
0188A:  CLRF   x53
.................... 		} 
....................  
....................  
.................... #if 0 
.................... 		if ( timer.dump_register != 255 ) { 
.................... 			/* takes about 4 milliseconds */ 
.................... 			disable_interrupts(INT_CANRX0); 
.................... 			disable_interrupts(INT_CANRX1); 
....................  
.................... 			fprintf(rs232,"# [%u] {%02x %02x %02x %02x}\r\n", 
.................... 				timer.dump_register, 
.................... 				timer.vcs_register[timer.dump_register<<2 + 0], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 1], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 2], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 3] 
.................... 			); 
.................... //			fputc('*',rs232); 
....................  
.................... 			timer.dump_register=255; 
....................  
.................... 			enable_interrupts(INT_CANRX0); 
.................... 			enable_interrupts(INT_CANRX1); 
.................... 		} 
.................... #endif 
....................  
....................  
....................  
.................... //		modbus_process(); 
....................  
.................... 	    /* 
.................... 	     * every 10 seconds we send a sync pulse which should trigger another packet from XRW2G 
.................... 	     * if we have wirless sensors, then this doesn't matter 
.................... 	     */ 
.................... 	    if ( timer.now_telem ) { 
0188C:  MOVLB  1
0188E:  MOVF   x5D,F
01890:  BZ    189C
.................... 			timer.now_telem=0; 
01892:  CLRF   x5D
.................... //			output_high(SYNC_OUT); 
.................... 			live_send_vcs(); 
01894:  MOVLB  0
01896:  BRA    1422
.................... //			output_high(TP_ORANGE); 
.................... 	    } else { 
01898:  BRA    18A2
0189A:  MOVLB  1
.................... 			output_low(SYNC_OUT); 
0189C:  BCF    F94.5
0189E:  BCF    F8B.5
018A0:  MOVLB  0
.................... //			output_low(TP_ORANGE); 
.................... 	    } 
....................  
....................  
.................... 		/* we have XRW2G data, and we haven't gotten any more in last 50 miliseconds */ 
.................... 		if ( 0 != timer.xrw2g_buff_pos && timer.xrw2g_age > 50 ) { 
018A2:  MOVF   xB0,F
018A4:  BZ    18B2
018A6:  MOVF   xB2,F
018A8:  BNZ   18B0
018AA:  MOVF   xB1,W
018AC:  SUBLW  32
018AE:  BC    18B2
.................... #if 1 
.................... 			live_send_xrw2g(); 
018B0:  BRA    1614
.................... #else 
.................... 			fprintf(rs232,"# XRW2G %c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			if ( 0 == live_send_xrw2g() ) { 
.................... 				fprintf(rs232,"error-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} else { 
.................... 				fprintf(rs232,"success-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} 
.................... 			timer.telem_age=0; 
.................... #endif 
.................... 		} 
....................  
.................... #if 0 
.................... 		 /* we haven't sent live data for 32 seconds */ 
.................... 		if (  timer.telem_age > 32000 ) { 
.................... 			live_send(1); 
.................... 			timer.telem_age=0; 
.................... 		} 
....................  
.................... 	 
....................  
.................... 		if ( ! timer.modbus_enable ) { 
.................... 			/* 	 
.................... 				Status LEDs:  
.................... 					Solid red if no VCS data 
.................... 					Flash of red on bad packets from inverter (in packet parse routine) 
.................... 					Solid green if XRW2G in last 12 seconds 
.................... 			*/ 
.................... //			if ( timer.inverter_conditions_age > 1025 ) { 
.................... //				timer.led_on_red=2000; 
.................... //			}  
.................... 	 
.................... 			if (timer.xrw2g_age < 12000 ) { 
.................... 				timer.led_on_green=2000; 
.................... 			} 
.................... 		} 
....................  
.................... 		/* full time RED LED if default serial number */ 
.................... //		if ( config.serial_prefix == SERIAL_PREFIX_DEFAULT && config.serial_number == SERIAL_NUMBER_DEFAULT ) { 
.................... //			timer.led_on_red=200; 
.................... //		} 
.................... #endif 
.................... 	} 
018B2:  MOVLB  2
018B4:  BRA    184A
.................... } 
....................  
018B6:  BRA    18B6

Configuration Fuses:
   Word  1: 4F00   FCMEN NOIESO
   Word  2: 1A19   NOPUT NOBROWNOUT BORV21 NOWDT WDT8192
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
