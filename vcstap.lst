CCS PCH C Compiler, Version 4.135, 4375               29-Aug-16 14:14

               Filename: C:\Users\James Jarvis\Desktop\planetPrecision\vcstap\vcstap.lst

               ROM used: 6274 bytes (10%)
                         Largest free fragment is 58686
               RAM used: 617 (19%) at main() level
                         845 (25%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   031E
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   0350
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   040A
00078:  BTFSS  FA3.7
0007A:  GOTO   0084
0007E:  BTFSC  FA4.7
00080:  GOTO   0000
00084:  BTFSS  FA3.1
00086:  GOTO   0090
0008A:  BTFSC  FA4.1
0008C:  GOTO   0822
00090:  BTFSS  FA3.0
00092:  GOTO   009C
00096:  BTFSC  FA4.0
00098:  GOTO   0678
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVF   04,W
000E0:  MOVFF  06,FE0
000E4:  MOVFF  05,FD8
000E8:  RETFIE 0
*
0FDBC:  GOTO   1732
.................... #include "vcstap.h" 
.................... #include <18F2680.h> 
.................... //////// Standard Header file for the PIC18F2680 device //////////////// 
.................... #device PIC18F2680 
.................... #list 
....................  
.................... #device ADC=10 
.................... #device *=16 
....................  
.................... /* leave last nine pages alone for boot loader. first two words do the jump to the boot loader */ 
.................... #build(reset=0xfdbc:0xfdbf) 
.................... #org 0xfdc0,0xffff {} 
....................  
....................  
.................... /* 
.................... 		#define		BLPLP		9			;bootloader placement, pages from end 
.................... 		#define		BLSIZEP		9			;bootloader size [pages], used by bootloader protection	 
.................... */ 
....................  
....................  
.................... /* EEPROM locations */ 
.................... #define PARAM_CRC_ADDRESS 0x00 
.................... #define PARAM_ADDRESS     0x01 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#FUSES INTRC_IO,NOPROTECT,WDT8192, NOIESO, NODEBUG 
.................... #use delay(clock=8000000, restart_wdt) 
*
00A00:  MOVLW  02
00A02:  MOVWF  FEA
00A04:  MOVLW  68
00A06:  MOVWF  FE9
00A08:  MOVF   FEF,W
00A0A:  BZ    0A2E
00A0C:  MOVLW  02
00A0E:  MOVWF  01
00A10:  MOVLW  BF
00A12:  MOVWF  00
00A14:  CLRWDT
00A16:  DECFSZ 00,F
00A18:  BRA    0A14
00A1A:  DECFSZ 01,F
00A1C:  BRA    0A10
00A1E:  MOVLW  96
00A20:  MOVWF  00
00A22:  DECFSZ 00,F
00A24:  BRA    0A22
00A26:  BRA    0A28
00A28:  CLRWDT
00A2A:  DECFSZ FEF,F
00A2C:  BRA    0A0C
00A2E:  RETURN 0
....................  
.................... /* 
....................  Sensors  WorldData R33 R34 R35 R36 XBee | UART1    | UART2 | SCI_UART                  | STATUS 
....................  on-board Ethernet  DNS DNS DNS DNS DNS  | inverter | world | (onboard XRW2G)           | done 
....................  802.15.4 Ethernet  0   DNS DNS DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  802.15.4 802.15.4  0   0   0   DNS YES  | inverter | world | (external XRW2G via xBee) | (testing) 
....................  on-board 802.15.4  DNS 0   0   DNS YES  | inverter | world | (onboard XRW2G)           | done 
....................  */ 
....................  
....................  
....................  
.................... #use rs232(UART1,stream=rs232,baud=9600,xmit=PIN_C6,rcv=PIN_C7, errors)	 /* also connected to XPort transmit ... xport receive not connected */ 
*
003C4:  BTFSS  F9E.5
003C6:  BRA    03C4
003C8:  MOVFF  FAB,1F
003CC:  MOVFF  FAE,01
003D0:  BTFSS  1F.1
003D2:  BRA    03D8
003D4:  BCF    FAB.4
003D6:  BSF    FAB.4
003D8:  GOTO   0410 (RETURN)
*
013F4:  BTFSS  F9E.4
013F6:  BRA    13F4
013F8:  MOVWF  FAD
013FA:  RETURN 0
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST) 
*
00A30:  MOVLW  08
00A32:  MOVWF  01
00A34:  NOP   
00A36:  BCF    F8B.3
00A38:  BCF    F94.3
00A3A:  NOP   
00A3C:  MOVLB  2
00A3E:  RLCF   x73,F
00A40:  BCF    F8B.4
00A42:  BTFSC  FD8.0
00A44:  BSF    F94.4
00A46:  BTFSS  FD8.0
00A48:  BCF    F94.4
00A4A:  BSF    F94.3
00A4C:  BTFSS  F82.3
00A4E:  BRA    0A4C
00A50:  DECFSZ 01,F
00A52:  BRA    0A56
00A54:  BRA    0A5A
00A56:  MOVLB  0
00A58:  BRA    0A34
00A5A:  NOP   
00A5C:  BCF    F8B.3
00A5E:  BCF    F94.3
00A60:  NOP   
00A62:  BSF    F94.4
00A64:  NOP   
00A66:  NOP   
00A68:  BSF    F94.3
00A6A:  BTFSS  F82.3
00A6C:  BRA    0A6A
00A6E:  CLRF   01
00A70:  NOP   
00A72:  BTFSC  F82.4
00A74:  BSF    01.0
00A76:  BCF    F8B.3
00A78:  BCF    F94.3
00A7A:  BCF    F8B.4
00A7C:  BCF    F94.4
00A7E:  MOVLB  0
00A80:  RETURN 0
*
0114C:  MOVLW  08
0114E:  MOVLB  2
01150:  MOVWF  x6C
01152:  MOVFF  00,26D
01156:  BSF    F94.4
01158:  NOP   
0115A:  BSF    F94.3
0115C:  BTFSS  F82.3
0115E:  BRA    115C
01160:  BTFSC  F82.4
01162:  BSF    FD8.0
01164:  BTFSS  F82.4
01166:  BCF    FD8.0
01168:  RLCF   01,F
0116A:  NOP   
0116C:  BCF    F94.3
0116E:  BCF    F8B.3
01170:  DECFSZ x6C,F
01172:  BRA    1156
01174:  BSF    F94.4
01176:  NOP   
01178:  BCF    F8B.4
0117A:  MOVF   x6D,W
0117C:  BTFSS  FD8.2
0117E:  BCF    F94.4
01180:  NOP   
01182:  BSF    F94.3
01184:  BTFSS  F82.3
01186:  BRA    1184
01188:  NOP   
0118A:  BCF    F8B.3
0118C:  BCF    F94.3
0118E:  NOP   
01190:  BCF    F8B.4
01192:  BCF    F94.4
01194:  MOVLB  0
01196:  GOTO   1208 (RETURN)
....................  
....................  
....................  
....................  
.................... #use standard_io(A) 
.................... #use standard_io(B) 
.................... #use standard_io(C) 
....................  
.................... #define LED_GREEN                  PIN_B4 
.................... // #define LED_RED                    PIN_B5 repurposed as relay 
.................... #define RELAY_RED                  PIN_B5 
....................  
.................... #define XBEE_SLEEP                 PIN_A0 
.................... #define XBEE_NRTS                  PIN_A1 
.................... #define XBEE_NCTS                  PIN_A2 
....................  
.................... #define SYNC_OUT                   PIN_C5 /* really labeled sync in */ 
....................  
.................... #define UART_IRQ                   PIN_B0 
.................... #define UART_RESET                 PIN_B1 
....................  
.................... #define TP14                       PIN_B3 
.................... #define TP15                       PIN_B2 
....................  
....................  
.................... #define TP_RED     PIN_B6 
.................... #define TP_ORANGE  PIN_B7 
....................  
....................  
.................... //#byte ANCON0=GETENV("SFR:ancon0") 
.................... //#byte ANCON1=GETENV("SFR:ancon1") 
....................  
....................  
....................  
.................... #define SERIAL_PREFIX_DEFAULT      'Z' 
.................... #define SERIAL_NUMBER_DEFAULT      6543 
....................  
.................... #define SENSOR_SOURCE_ONBOARD  0 
.................... #define SENSOR_SOURCE_WIRELESS 1 
....................  
....................  
.................... /* can baud rate registers */ 
.................... //#byte BRGCON1=GETENV("SFR:brgcon1") 
.................... //#byte BRGCON2=GETENV("SFR:brgcon2") 
.................... //#byte BRGCON3=GETENV("SFR:brgcon3") 
....................  
....................  
....................  
....................  
.................... typedef struct { 
.................... 	int8 revision; 
....................  
.................... 	int8 modbus_address; 
....................  
.................... 	int8  serial_prefix; 
.................... 	int16 serial_number; 
....................  
.................... 	int8  pair_serial_prefix; 
.................... 	int16 pair_serial_number; 
....................  
.................... 	int8  sensor_source; 
.................... 	int8  world_to_xbee; 
.................... 	int8  world_to_xport; 
.................... } struct_config; 
....................  
.................... #define VCS_N_REGISTERS 40 
....................  
.................... typedef struct { 
.................... 	int8  modbus_enable; 
.................... 	int8  modbus_last_error; 
.................... 	int8  factory_unlocked; 
.................... 	int16 telem_age; 
....................  
.................... 	int8  xrw2g_packet[128]; 
.................... 	int8  xrw2g_buff_pos; 
.................... 	int16 xrw2g_age; 
....................  
.................... 	/* VCS data as updated by the CAN bus */ 
.................... 	int8 vcs_register     [VCS_N_REGISTERS*4]; /* 40 32-bit registers */ 
.................... 	int16 vcs_query_age; 
.................... 	int8 vcs_read_lock; /* 1 means nobody can modify the data */ 
....................  
.................... 	int16 led_on_red; 
.................... 	int16 led_on_green; 
....................  
.................... 	int8 dump_register; 
....................  
.................... 	int8 now_telem; 
.................... } struct_timer; 
....................  
.................... /* global structures */ 
.................... struct_config config; 
.................... struct_timer  timer; 
....................  
.................... #include "can.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specifid message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transeiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "can.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #define CAN_DO_DEBUG                FALSE 
....................  
.................... #define CAN_USE_EXTENDED_ID         FALSE 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH    0  //synchronized jump width (def: 1 x Tq) 
.................... #define CAN_BRG_PRESCALAR           4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #define CAN_BRG_SEG_2_PHASE_TS      TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #define CAN_BRG_SAM                 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #define CAN_BRG_PHASE_SEGMENT_1     5 //phase segment 1 (def: 6 x Tq) 
.................... #define CAN_BRG_PROPAGATION_TIME    2 //propagation time select (def: 3 x Tq) 
.................... #define CAN_BRG_WAKE_FILTER         FALSE   //selects can bus line filter for wake up bit 
.................... #define CAN_BRG_PHASE_SEGMENT_2     5 //phase segment 2 time select (def: 6 x Tq) 
.................... #define CAN_USE_RX_DOUBLE_BUFFER    TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #define CAN_ENABLE_DRIVE_HIGH       1      // required by CTIW CAN / VCSTAP 
.................... #define CAN_ENABLE_CAN_CAPTURE      0 
.................... #define CAN_ENABLE_CANTX2           0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #define CAN_CANTX2_SOURCE           0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive caputre 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote tranmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extendid id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard indifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended indifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifer mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifer mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
....................  
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
00CC0:  MOVLW  04
00CC2:  MOVLB  2
00CC4:  MOVWF  x68
00CC6:  MOVLB  0
00CC8:  RCALL  0B58
....................    can_set_baud(); 
00CCA:  BRA    0B7E
....................  
....................    RXB0CON=0; 
00CCC:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
00CCE:  MOVLW  9F
00CD0:  ANDWF  F60,W
00CD2:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
00CD4:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
00CD6:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
00CDA:  BSF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
00CDC:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
00CDE:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
00CE0:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
00CE2:  MOVLW  0F
00CE4:  MOVLB  2
00CE6:  MOVWF  x81
00CE8:  MOVLW  1B
00CEA:  MOVWF  x80
00CEC:  CLRF   x85
00CEE:  CLRF   x84
00CF0:  CLRF   x83
00CF2:  CLRF   x82
00CF4:  CLRF   x86
00CF6:  MOVLB  0
00CF8:  RCALL  0B8C
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
00CFA:  MOVLW  0F
00CFC:  MOVLB  2
00CFE:  MOVWF  x81
00D00:  MOVLW  03
00D02:  MOVWF  x80
00D04:  CLRF   x85
00D06:  CLRF   x84
00D08:  CLRF   x83
00D0A:  CLRF   x82
00D0C:  CLRF   x86
00D0E:  MOVLB  0
00D10:  RCALL  0B8C
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
00D12:  MOVLW  0F
00D14:  MOVLB  2
00D16:  MOVWF  x81
00D18:  MOVLW  07
00D1A:  MOVWF  x80
00D1C:  CLRF   x85
00D1E:  CLRF   x84
00D20:  CLRF   x83
00D22:  CLRF   x82
00D24:  CLRF   x86
00D26:  MOVLB  0
00D28:  RCALL  0B8C
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
00D2A:  MOVLW  0F
00D2C:  MOVLB  2
00D2E:  MOVWF  x81
00D30:  MOVLW  1F
00D32:  MOVWF  x80
00D34:  CLRF   x85
00D36:  CLRF   x84
00D38:  CLRF   x83
00D3A:  CLRF   x82
00D3C:  CLRF   x86
00D3E:  MOVLB  0
00D40:  RCALL  0B8C
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
00D42:  MOVLW  0F
00D44:  MOVLB  2
00D46:  MOVWF  x81
00D48:  MOVLW  0B
00D4A:  MOVWF  x80
00D4C:  CLRF   x85
00D4E:  CLRF   x84
00D50:  CLRF   x83
00D52:  CLRF   x82
00D54:  CLRF   x86
00D56:  MOVLB  0
00D58:  RCALL  0B8C
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
00D5A:  MOVLW  0F
00D5C:  MOVLB  2
00D5E:  MOVWF  x81
00D60:  MOVWF  x80
00D62:  CLRF   x85
00D64:  CLRF   x84
00D66:  CLRF   x83
00D68:  CLRF   x82
00D6A:  CLRF   x86
00D6C:  MOVLB  0
00D6E:  RCALL  0B8C
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
00D70:  MOVLW  0F
00D72:  MOVLB  2
00D74:  MOVWF  x81
00D76:  MOVLW  13
00D78:  MOVWF  x80
00D7A:  CLRF   x85
00D7C:  CLRF   x84
00D7E:  CLRF   x83
00D80:  CLRF   x82
00D82:  CLRF   x86
00D84:  MOVLB  0
00D86:  RCALL  0B8C
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
00D88:  MOVLW  0F
00D8A:  MOVLB  2
00D8C:  MOVWF  x81
00D8E:  MOVLW  17
00D90:  MOVWF  x80
00D92:  CLRF   x85
00D94:  CLRF   x84
00D96:  CLRF   x83
00D98:  CLRF   x82
00D9A:  CLRF   x86
00D9C:  MOVLB  0
00D9E:  RCALL  0B8C
....................  
....................    set_tris_b((*0xF93 & 0xFB ) | 0x08);   //b3 is out, b2 is in 
00DA0:  MOVF   F93,W
00DA2:  ANDLW  FB
00DA4:  IORLW  08
00DA6:  MOVLB  2
00DA8:  MOVWF  F93
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
00DAA:  CLRF   x68
00DAC:  MOVLB  0
00DAE:  RCALL  0B58
.................... } 
00DB0:  GOTO   0DF6 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
.................... /* 250 kbps from 8 MHz oscillator */ 
.................... 	BRGCON1=0x00; 
*
00B7E:  CLRF   F70
.................... 	BRGCON2=0xB8; 
00B80:  MOVLW  B8
00B82:  MOVWF  F71
.................... 	BRGCON3=0x05; 
00B84:  MOVLW  05
00B86:  MOVWF  F72
.................... #if 0 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
....................    BRGCON2.sam=CAN_BRG_SAM; 
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
.................... #endif 
.................... } 
00B88:  GOTO   0CCC (RETURN)
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
00B58:  MOVLB  2
00B5A:  SWAPF  x68,W
00B5C:  ANDLW  70
00B5E:  MOVWF  00
00B60:  BCF    FD8.0
00B62:  RLCF   00,F
00B64:  MOVLW  1F
00B66:  ANDWF  F6F,W
00B68:  IORWF  00,W
00B6A:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
00B6C:  MOVFF  F6E,00
00B70:  SWAPF  00,F
00B72:  RRCF   00,W
00B74:  ANDLW  07
00B76:  SUBWF  x68,W
00B78:  BNZ   0B6C
.................... } 
00B7A:  MOVLB  0
00B7C:  RETURN 0
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
00B8C:  MOVFF  281,288
00B90:  MOVFF  280,287
....................  
....................    if (ext) {  //extended 
00B94:  MOVLB  2
00B96:  MOVF   x86,F
00B98:  BZ    0C3E
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
00B9A:  MOVFF  287,FE9
00B9E:  MOVFF  288,FEA
00BA2:  MOVFF  282,FEF
....................  
....................       //eidh 
....................       ptr--; 
00BA6:  MOVF   x87,W
00BA8:  BTFSC  FD8.2
00BAA:  DECF   x88,F
00BAC:  DECF   x87,F
....................       *ptr=make8(id,1); //8:15 
00BAE:  MOVFF  287,FE9
00BB2:  MOVFF  288,FEA
00BB6:  MOVFF  283,FEF
....................  
....................       //sidl 
....................       ptr--; 
00BBA:  MOVF   x87,W
00BBC:  BTFSC  FD8.2
00BBE:  DECF   x88,F
00BC0:  DECF   x87,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
00BC2:  MOVFF  287,FE9
00BC6:  MOVFF  288,FEA
00BCA:  MOVF   x84,W
00BCC:  ANDLW  03
00BCE:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
00BD0:  MOVFF  287,FE9
00BD4:  MOVFF  288,FEA
00BD8:  MOVFF  284,00
00BDC:  RLCF   00,F
00BDE:  RLCF   00,F
00BE0:  RLCF   00,F
00BE2:  MOVLW  F8
00BE4:  ANDWF  00,F
00BE6:  MOVF   00,W
00BE8:  ANDLW  E0
00BEA:  IORWF  FEF,W
00BEC:  MOVWF  FEF
....................       *ptr|=0x08; 
00BEE:  MOVFF  287,FE9
00BF2:  MOVFF  288,FEA
00BF6:  MOVF   FEF,W
00BF8:  IORLW  08
00BFA:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
00BFC:  MOVF   x87,W
00BFE:  BTFSC  FD8.2
00C00:  DECF   x88,F
00C02:  DECF   x87,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
00C04:  MOVFF  287,FE9
00C08:  MOVFF  288,FEA
00C0C:  MOVFF  284,00
00C10:  SWAPF  00,F
00C12:  RRCF   00,F
00C14:  MOVLW  07
00C16:  ANDWF  00,F
00C18:  MOVF   00,W
00C1A:  ANDLW  07
00C1C:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
00C1E:  MOVFF  287,FE9
00C22:  MOVFF  288,FEA
00C26:  MOVFF  285,00
00C2A:  RLCF   00,F
00C2C:  RLCF   00,F
00C2E:  RLCF   00,F
00C30:  MOVLW  F8
00C32:  ANDWF  00,F
00C34:  MOVF   00,W
00C36:  ANDLW  F8
00C38:  IORWF  FEF,W
00C3A:  MOVWF  FEF
....................    } 
....................    else {   //standard 
00C3C:  BRA    0CBC
....................       //eidl 
....................       *ptr=0; 
00C3E:  MOVFF  287,FE9
00C42:  MOVFF  288,FEA
00C46:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
00C48:  MOVF   x87,W
00C4A:  BTFSC  FD8.2
00C4C:  DECF   x88,F
00C4E:  DECF   x87,F
....................       *ptr=0; 
00C50:  MOVFF  287,FE9
00C54:  MOVFF  288,FEA
00C58:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
00C5A:  MOVF   x87,W
00C5C:  BTFSC  FD8.2
00C5E:  DECF   x88,F
00C60:  DECF   x87,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
00C62:  MOVFF  287,FE9
00C66:  MOVFF  288,FEA
00C6A:  MOVFF  282,00
00C6E:  SWAPF  00,F
00C70:  RLCF   00,F
00C72:  MOVLW  E0
00C74:  ANDWF  00,F
00C76:  MOVF   00,W
00C78:  ANDLW  E0
00C7A:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
00C7C:  MOVF   x87,W
00C7E:  BTFSC  FD8.2
00C80:  DECF   x88,F
00C82:  DECF   x87,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
00C84:  MOVFF  287,FE9
00C88:  MOVFF  288,FEA
00C8C:  MOVFF  282,00
00C90:  RRCF   00,F
00C92:  RRCF   00,F
00C94:  RRCF   00,F
00C96:  MOVLW  1F
00C98:  ANDWF  00,F
00C9A:  MOVF   00,W
00C9C:  ANDLW  1F
00C9E:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
00CA0:  MOVFF  287,FE9
00CA4:  MOVFF  288,FEA
00CA8:  MOVFF  283,00
00CAC:  SWAPF  00,F
00CAE:  RLCF   00,F
00CB0:  MOVLW  E0
00CB2:  ANDWF  00,F
00CB4:  MOVF   00,W
00CB6:  ANDLW  E0
00CB8:  IORWF  FEF,W
00CBA:  MOVWF  FEF
....................    } 
.................... } 
00CBC:  MOVLB  0
00CBE:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Paramaters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
00480:  MOVLB  3
00482:  CLRF   x45
00484:  CLRF   x44
00486:  CLRF   x43
00488:  CLRF   x42
....................    ptr=addr; 
0048A:  MOVFF  340,347
0048E:  MOVFF  33F,346
....................  
....................    if (ext) { 
00492:  MOVF   x41,F
00494:  BTFSC  FD8.2
00496:  BRA    05BE
....................       ret=*ptr;  //eidl 
00498:  MOVFF  347,03
0049C:  MOVFF  346,FE9
004A0:  MOVFF  347,FEA
004A4:  MOVFF  FEF,00
004A8:  CLRF   01
004AA:  CLRF   02
004AC:  CLRF   03
004AE:  MOVFF  03,345
004B2:  MOVFF  02,344
004B6:  MOVFF  01,343
004BA:  MOVFF  00,342
....................  
....................       ptr--;     //eidh 
004BE:  MOVF   x46,W
004C0:  BTFSC  FD8.2
004C2:  DECF   x47,F
004C4:  DECF   x46,F
....................       ret|=((unsigned int32)*ptr << 8); 
004C6:  MOVFF  346,FE9
004CA:  MOVFF  347,FEA
004CE:  MOVF   FEF,W
004D0:  CLRF   x4A
004D2:  CLRF   x49
004D4:  MOVWF  x48
004D6:  CLRF   00
004D8:  MOVF   00,W
004DA:  IORWF  x42,F
004DC:  MOVF   x48,W
004DE:  IORWF  x43,F
004E0:  MOVF   x49,W
004E2:  IORWF  x44,F
004E4:  MOVF   x4A,W
004E6:  IORWF  x45,F
....................  
....................       ptr--;     //sidl 
004E8:  MOVF   x46,W
004EA:  BTFSC  FD8.2
004EC:  DECF   x47,F
004EE:  DECF   x46,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
004F0:  MOVFF  346,FE9
004F4:  MOVFF  347,FEA
004F8:  MOVF   FEF,W
004FA:  CLRF   x4B
004FC:  CLRF   x4A
004FE:  CLRF   x49
00500:  MOVWF  x48
00502:  MOVLW  03
00504:  ANDWF  x48,F
00506:  CLRF   x49
00508:  CLRF   x4A
0050A:  CLRF   x4B
0050C:  CLRF   00
0050E:  CLRF   01
00510:  MOVF   00,W
00512:  IORWF  x42,F
00514:  MOVF   01,W
00516:  IORWF  x43,F
00518:  MOVF   x48,W
0051A:  IORWF  x44,F
0051C:  MOVF   x49,W
0051E:  IORWF  x45,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
00520:  MOVFF  346,FE9
00524:  MOVFF  347,FEA
00528:  MOVF   FEF,W
0052A:  CLRF   x4B
0052C:  CLRF   x4A
0052E:  CLRF   x49
00530:  MOVWF  x48
00532:  MOVLW  E0
00534:  ANDWF  x48,F
00536:  CLRF   x49
00538:  CLRF   x4A
0053A:  CLRF   x4B
0053C:  CLRF   00
0053E:  RLCF   x48,W
00540:  MOVWF  01
00542:  RLCF   x49,W
00544:  MOVWF  02
00546:  RLCF   x4A,W
00548:  MOVWF  03
0054A:  RLCF   01,F
0054C:  RLCF   02,F
0054E:  RLCF   03,F
00550:  RLCF   01,F
00552:  RLCF   02,F
00554:  RLCF   03,F
00556:  RLCF   01,F
00558:  RLCF   02,F
0055A:  RLCF   03,F
0055C:  RLCF   01,F
0055E:  RLCF   02,F
00560:  RLCF   03,F
00562:  MOVLW  E0
00564:  ANDWF  01,F
00566:  MOVF   00,W
00568:  IORWF  x42,F
0056A:  MOVF   01,W
0056C:  IORWF  x43,F
0056E:  MOVF   02,W
00570:  IORWF  x44,F
00572:  MOVF   03,W
00574:  IORWF  x45,F
....................  
....................       ptr--;     //sidh 
00576:  MOVF   x46,W
00578:  BTFSC  FD8.2
0057A:  DECF   x47,F
0057C:  DECF   x46,F
....................       ret|=((unsigned int32)*ptr << 21); 
0057E:  MOVFF  346,FE9
00582:  MOVFF  347,FEA
00586:  MOVF   FEF,W
00588:  CLRF   x49
0058A:  MOVWF  x48
0058C:  CLRF   00
0058E:  CLRF   01
00590:  RLCF   x48,W
00592:  MOVWF  02
00594:  RLCF   x49,W
00596:  MOVWF  03
00598:  RLCF   02,F
0059A:  RLCF   03,F
0059C:  RLCF   02,F
0059E:  RLCF   03,F
005A0:  RLCF   02,F
005A2:  RLCF   03,F
005A4:  RLCF   02,F
005A6:  RLCF   03,F
005A8:  MOVLW  E0
005AA:  ANDWF  02,F
005AC:  MOVF   00,W
005AE:  IORWF  x42,F
005B0:  MOVF   01,W
005B2:  IORWF  x43,F
005B4:  MOVF   02,W
005B6:  IORWF  x44,F
005B8:  MOVF   03,W
005BA:  IORWF  x45,F
....................  
....................    } 
....................    else { 
005BC:  BRA    0664
....................       ptr-=2;    //sidl 
005BE:  MOVLW  02
005C0:  SUBWF  x46,F
005C2:  MOVLW  00
005C4:  SUBWFB x47,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
005C6:  MOVFF  346,FE9
005CA:  MOVFF  347,FEA
005CE:  MOVF   FEF,W
005D0:  CLRF   x4B
005D2:  CLRF   x4A
005D4:  CLRF   x49
005D6:  MOVWF  x48
005D8:  MOVLW  E0
005DA:  ANDWF  x48,F
005DC:  CLRF   x49
005DE:  CLRF   x4A
005E0:  CLRF   x4B
005E2:  RRCF   x4B,W
005E4:  MOVWF  x45
005E6:  RRCF   x4A,W
005E8:  MOVWF  x44
005EA:  RRCF   x49,W
005EC:  MOVWF  x43
005EE:  RRCF   x48,W
005F0:  MOVWF  x42
005F2:  RRCF   x45,F
005F4:  RRCF   x44,F
005F6:  RRCF   x43,F
005F8:  RRCF   x42,F
005FA:  RRCF   x45,F
005FC:  RRCF   x44,F
005FE:  RRCF   x43,F
00600:  RRCF   x42,F
00602:  RRCF   x45,F
00604:  RRCF   x44,F
00606:  RRCF   x43,F
00608:  RRCF   x42,F
0060A:  RRCF   x45,F
0060C:  RRCF   x44,F
0060E:  RRCF   x43,F
00610:  RRCF   x42,F
00612:  MOVLW  07
00614:  ANDWF  x45,F
....................  
....................       ptr--;     //sidh 
00616:  MOVF   x46,W
00618:  BTFSC  FD8.2
0061A:  DECF   x47,F
0061C:  DECF   x46,F
....................       ret|=((unsigned int32)*ptr << 3); 
0061E:  MOVFF  346,FE9
00622:  MOVFF  347,FEA
00626:  MOVF   FEF,W
00628:  CLRF   x4B
0062A:  CLRF   x4A
0062C:  CLRF   x49
0062E:  MOVWF  x48
00630:  RLCF   x48,W
00632:  MOVWF  00
00634:  RLCF   x49,W
00636:  MOVWF  01
00638:  RLCF   x4A,W
0063A:  MOVWF  02
0063C:  RLCF   x4B,W
0063E:  MOVWF  03
00640:  RLCF   00,F
00642:  RLCF   01,F
00644:  RLCF   02,F
00646:  RLCF   03,F
00648:  RLCF   00,F
0064A:  RLCF   01,F
0064C:  RLCF   02,F
0064E:  RLCF   03,F
00650:  MOVLW  F8
00652:  ANDWF  00,F
00654:  MOVF   00,W
00656:  IORWF  x42,F
00658:  MOVF   01,W
0065A:  IORWF  x43,F
0065C:  MOVF   02,W
0065E:  IORWF  x44,F
00660:  MOVF   03,W
00662:  IORWF  x45,F
....................    } 
....................  
....................    return(ret); 
00664:  MOVFF  342,00
00668:  MOVFF  343,01
0066C:  MOVFF  344,02
00670:  MOVFF  345,03
.................... } 
00674:  MOVLB  0
00676:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Paramaters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
01278:  MOVLW  0F
0127A:  MOVLB  2
0127C:  MOVWF  x7E
0127E:  MOVLW  66
01280:  MOVWF  x7D
....................  
....................     // find emtpy transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
01282:  MOVLB  F
01284:  BTFSC  x40.3
01286:  BRA    1298
....................       CANCON.win=CAN_WIN_TX0; 
01288:  MOVLW  F1
0128A:  ANDWF  F6F,W
0128C:  IORLW  08
0128E:  MOVWF  F6F
....................       port=0; 
01290:  MOVLB  2
01292:  CLRF   x7F
....................    } 
....................    else if (!TXB1CON.txreq) { 
01294:  BRA    12CC
01296:  MOVLB  F
01298:  BTFSC  x30.3
0129A:  BRA    12AE
....................       CANCON.win=CAN_WIN_TX1; 
0129C:  MOVLW  F1
0129E:  ANDWF  F6F,W
012A0:  IORLW  06
012A2:  MOVWF  F6F
....................       port=1; 
012A4:  MOVLW  01
012A6:  MOVLB  2
012A8:  MOVWF  x7F
....................    } 
....................    else if (!TXB2CON.txreq) { 
012AA:  BRA    12CC
012AC:  MOVLB  F
012AE:  BTFSC  x20.3
012B0:  BRA    12C4
....................       CANCON.win=CAN_WIN_TX2; 
012B2:  MOVLW  F1
012B4:  ANDWF  F6F,W
012B6:  IORLW  04
012B8:  MOVWF  F6F
....................       port=2; 
012BA:  MOVLW  02
012BC:  MOVLB  2
012BE:  MOVWF  x7F
....................    } 
....................    else { 
012C0:  BRA    12CC
012C2:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
012C4:  MOVLW  00
012C6:  MOVWF  01
012C8:  BRA    1344
012CA:  MOVLB  2
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
012CC:  MOVF   x79,W
012CE:  ANDLW  03
012D0:  MOVWF  00
012D2:  MOVLW  FC
012D4:  ANDWF  F60,W
012D6:  IORWF  00,W
012D8:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
012DA:  MOVLW  0F
012DC:  MOVWF  x81
012DE:  MOVLW  64
012E0:  MOVWF  x80
012E2:  MOVFF  275,285
012E6:  MOVFF  274,284
012EA:  MOVFF  273,283
012EE:  MOVFF  272,282
012F2:  MOVFF  27A,286
012F6:  MOVLB  0
012F8:  RCALL  0B8C
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
012FA:  MOVFF  278,F65
....................    TXBaDLC.rtr=rtr; 
012FE:  BCF    F65.6
01300:  MOVLB  2
01302:  BTFSC  x7B.0
01304:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
01306:  CLRF   x7C
01308:  MOVF   x78,W
0130A:  SUBWF  x7C,W
0130C:  BC    1336
....................       *txd0=*data; 
0130E:  MOVFF  276,FE9
01312:  MOVFF  277,FEA
01316:  MOVFF  FEF,282
0131A:  MOVFF  27E,FEA
0131E:  MOVFF  27D,FE9
01322:  MOVFF  282,FEF
....................       txd0++; 
01326:  INCF   x7D,F
01328:  BTFSC  FD8.2
0132A:  INCF   x7E,F
....................       data++; 
0132C:  INCF   x76,F
0132E:  BTFSC  FD8.2
01330:  INCF   x77,F
....................     } 
01332:  INCF   x7C,F
01334:  BRA    1308
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
01336:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
01338:  MOVLW  F1
0133A:  ANDWF  F6F,W
0133C:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
0133E:  MOVLW  01
01340:  MOVWF  01
01342:  MOVLB  F
.................... } 
01344:  MOVLB  0
01346:  GOTO   1386 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             recieved it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
00686:  BTFSS  F60.7
00688:  BRA    06B8
*
00830:  BTFSS  F60.7
00832:  BRA    0862
....................         CANCON.win=CAN_WIN_RX0; 
*
0068A:  MOVLW  F1
0068C:  ANDWF  F6F,W
0068E:  MOVWF  F6F
*
00834:  MOVLW  F1
00836:  ANDWF  F6F,W
00838:  MOVWF  F6F
....................         stat.buffer=0; 
*
00690:  BCF    x32.4
*
0083A:  BCF    x32.4
....................  
....................         CAN_INT_RXB0IF=0; 
*
00692:  BCF    FA4.0
*
0083C:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
*
00694:  BCF    x32.0
00696:  BTFSC  F74.7
00698:  BSF    x32.0
*
0083E:  BCF    x32.0
00840:  BTFSC  F74.7
00842:  BSF    x32.0
....................         COMSTAT.rx0ovfl=0; 
*
0069A:  BCF    F74.7
*
00844:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
*
0069C:  BTFSS  F60.2
0069E:  BRA    06B6
*
00846:  BTFSS  F60.2
00848:  BRA    0860
....................          stat.filthit=RXB0CON.filthit0; 
*
006A0:  MOVLW  00
006A2:  BTFSC  F60.0
006A4:  MOVLW  01
006A6:  ANDLW  07
006A8:  MOVWF  00
006AA:  BCF    FD8.0
006AC:  RLCF   00,F
006AE:  MOVLW  F1
006B0:  ANDWF  x32,W
006B2:  IORWF  00,W
006B4:  MOVWF  x32
*
0084A:  MOVLW  00
0084C:  BTFSC  F60.0
0084E:  MOVLW  01
00850:  ANDLW  07
00852:  MOVWF  00
00854:  BCF    FD8.0
00856:  RLCF   00,F
00858:  MOVLW  F1
0085A:  ANDWF  x32,W
0085C:  IORWF  00,W
0085E:  MOVWF  x32
....................         } 
....................     } 
....................     else if ( RXB1CON.rxful ) 
*
006B6:  BRA    06F8
006B8:  MOVLB  F
006BA:  BTFSS  x50.7
006BC:  BRA    06F0
*
00860:  BRA    08A2
00862:  MOVLB  F
00864:  BTFSS  x50.7
00866:  BRA    089A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
*
006BE:  MOVLW  F1
006C0:  ANDWF  F6F,W
006C2:  IORLW  0A
006C4:  MOVWF  F6F
*
00868:  MOVLW  F1
0086A:  ANDWF  F6F,W
0086C:  IORLW  0A
0086E:  MOVWF  F6F
....................         stat.buffer=1; 
*
006C6:  MOVLB  3
006C8:  BSF    x32.4
*
00870:  MOVLB  3
00872:  BSF    x32.4
....................  
....................         CAN_INT_RXB1IF=0; 
*
006CA:  BCF    FA4.1
*
00874:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
*
006CC:  BCF    x32.0
006CE:  BTFSC  F74.6
006D0:  BSF    x32.0
*
00876:  BCF    x32.0
00878:  BTFSC  F74.6
0087A:  BSF    x32.0
....................         COMSTAT.rx1ovfl=0; 
*
006D2:  BCF    F74.6
*
0087C:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
*
006D4:  MOVLB  F
006D6:  MOVF   x50,W
006D8:  ANDLW  07
006DA:  ANDLW  07
006DC:  MOVWF  00
006DE:  BCF    FD8.0
006E0:  RLCF   00,F
006E2:  MOVLW  F1
006E4:  MOVLB  3
006E6:  ANDWF  x32,W
006E8:  IORWF  00,W
006EA:  MOVWF  x32
*
0087E:  MOVLB  F
00880:  MOVF   x50,W
00882:  ANDLW  07
00884:  ANDLW  07
00886:  MOVWF  00
00888:  BCF    FD8.0
0088A:  RLCF   00,F
0088C:  MOVLW  F1
0088E:  MOVLB  3
00890:  ANDWF  x32,W
00892:  IORWF  00,W
00894:  MOVWF  x32
....................     } 
....................     else { 
*
006EC:  BRA    06F8
006EE:  MOVLB  F
*
00896:  BRA    08A2
00898:  MOVLB  F
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
*
006F0:  MOVLW  00
006F2:  MOVWF  01
006F4:  BRA    078E
006F6:  MOVLB  3
*
0089A:  MOVLW  00
0089C:  MOVWF  01
0089E:  BRA    0938
008A0:  MOVLB  3
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
*
006F8:  MOVF   F65,W
006FA:  ANDLW  0F
006FC:  MOVWF  x31
*
008A2:  MOVF   F65,W
008A4:  ANDLW  0F
008A6:  MOVWF  x31
....................     stat.rtr=RXBaDLC.rtr; 
*
006FE:  BCF    x32.5
00700:  BTFSC  F65.6
00702:  BSF    x32.5
*
008A8:  BCF    x32.5
008AA:  BTFSC  F65.6
008AC:  BSF    x32.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
*
00704:  BCF    x32.6
00706:  BTFSC  F62.3
00708:  BSF    x32.6
*
008AE:  BCF    x32.6
008B0:  BTFSC  F62.3
008B2:  BSF    x32.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
*
0070A:  MOVLW  00
0070C:  BTFSC  x32.6
0070E:  MOVLW  01
00710:  MOVWF  x38
00712:  MOVLW  0F
00714:  MOVWF  x40
00716:  MOVLW  64
00718:  MOVWF  x3F
0071A:  MOVFF  338,341
0071E:  MOVLB  0
00720:  RCALL  0480
00722:  MOVFF  03,330
00726:  MOVFF  02,32F
0072A:  MOVFF  01,32E
0072E:  MOVFF  00,32D
*
008B4:  MOVLW  00
008B6:  BTFSC  x32.6
008B8:  MOVLW  01
008BA:  MOVWF  x38
008BC:  MOVLW  0F
008BE:  MOVWF  x40
008C0:  MOVLW  64
008C2:  MOVWF  x3F
008C4:  MOVFF  338,341
008C8:  MOVLB  0
008CA:  RCALL  0480
008CC:  MOVFF  03,330
008D0:  MOVFF  02,32F
008D4:  MOVFF  01,32E
008D8:  MOVFF  00,32D
....................  
....................     ptr = &TXRXBaD0; 
*
00732:  MOVLW  0F
00734:  MOVLB  3
00736:  MOVWF  x37
00738:  MOVLW  66
0073A:  MOVWF  x36
*
008DC:  MOVLW  0F
008DE:  MOVLB  3
008E0:  MOVWF  x37
008E2:  MOVLW  66
008E4:  MOVWF  x36
....................     for ( i = 0; i < len; i++ ) { 
*
0073C:  CLRF   x35
0073E:  MOVF   x31,W
00740:  SUBWF  x35,W
00742:  BC    076C
*
008E6:  CLRF   x35
008E8:  MOVF   x31,W
008EA:  SUBWF  x35,W
008EC:  BC    0916
....................         *data = *ptr; 
*
00744:  MOVFF  336,FE9
00748:  MOVFF  337,FEA
0074C:  MOVFF  FEF,33A
00750:  MOVFF  334,FEA
00754:  MOVFF  333,FE9
00758:  MOVFF  33A,FEF
*
008EE:  MOVFF  336,FE9
008F2:  MOVFF  337,FEA
008F6:  MOVFF  FEF,33A
008FA:  MOVFF  334,FEA
008FE:  MOVFF  333,FE9
00902:  MOVFF  33A,FEF
....................         data++; 
*
0075C:  INCF   x33,F
0075E:  BTFSC  FD8.2
00760:  INCF   x34,F
*
00906:  INCF   x33,F
00908:  BTFSC  FD8.2
0090A:  INCF   x34,F
....................         ptr++; 
*
00762:  INCF   x36,F
00764:  BTFSC  FD8.2
00766:  INCF   x37,F
*
0090C:  INCF   x36,F
0090E:  BTFSC  FD8.2
00910:  INCF   x37,F
....................     } 
*
00768:  INCF   x35,F
0076A:  BRA    073E
*
00912:  INCF   x35,F
00914:  BRA    08E8
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
*
0076C:  MOVLW  F1
0076E:  ANDWF  F6F,W
00770:  MOVWF  F6F
*
00916:  MOVLW  F1
00918:  ANDWF  F6F,W
0091A:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
*
00772:  BCF    x32.7
00774:  BTFSC  FA4.7
00776:  BSF    x32.7
*
0091C:  BCF    x32.7
0091E:  BTFSC  FA4.7
00920:  BSF    x32.7
....................     CAN_INT_IRXIF = 0; 
*
00778:  BCF    FA4.7
*
00922:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
*
0077A:  BTFSS  x32.4
0077C:  BRA    0786
*
00924:  BTFSS  x32.4
00926:  BRA    0930
....................       RXB1CON.rxful=0; 
*
0077E:  MOVLB  F
00780:  BCF    x50.7
*
00928:  MOVLB  F
0092A:  BCF    x50.7
....................     } 
....................     else { 
*
00782:  BRA    078A
00784:  MOVLB  3
*
0092C:  BRA    0934
0092E:  MOVLB  3
....................       RXB0CON.rxful=0; 
*
00786:  BCF    F60.7
00788:  MOVLB  F
*
00930:  BCF    F60.7
00932:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
*
0078A:  MOVLW  01
0078C:  MOVWF  01
*
00934:  MOVLW  01
00936:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include "uart_sci16is740.c" 
.................... /* register map for SCI16IS740 */ 
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode 
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode 
.................... #define UART_IER          0x01  // Interrupt Enable Register 
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode 
.................... #define UART_LCR          0x03  // Line Control Register 
.................... #define UART_MCR          0x04  // Modem Control Register 
.................... #define UART_LSR          0x05  // Line status Register 
.................... #define UART_MSR          0x06  // Modem Status Register 
.................... #define UART_SPR          0x07  // ScratchPad Register 
.................... #define UART_TCR          0x06  // Transmission Control Register 
.................... #define UART_TLR          0x07  // Trigger Level Register 
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register 
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register 
.................... #define UART_EFCR         0x0F  // Extra Features Control Register 
....................  
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00 
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01 
....................  
.................... #define UART_EFR          0x02  // Enhanced Function Register 
....................  
.................... #define UART_I2C_WRITE    0x00 
.................... #define UART_I2C_READ     0x01                                                
....................  
.................... /* A0 and A1 at VSS */ 
.................... #define UART_ADDR         0x9A 
....................  
.................... int8 uart_read(int8 regaddr) { 
.................... 	int8 data; 
....................  
.................... 	i2c_start(); 
*
0119A:  BSF    F94.4
0119C:  NOP   
0119E:  BSF    F94.3
011A0:  NOP   
011A2:  BCF    F8B.4
011A4:  BCF    F94.4
011A6:  NOP   
011A8:  BCF    F8B.3
011AA:  BCF    F94.3
.................... 	delay_us(15); 
011AC:  CLRWDT
011AE:  MOVLW  09
011B0:  MOVWF  00
011B2:  DECFSZ 00,F
011B4:  BRA    11B2
011B6:  NOP   
.................... 	i2c_write(UART_ADDR); 
011B8:  MOVLW  9A
011BA:  MOVLB  2
011BC:  MOVWF  x73
011BE:  MOVLB  0
011C0:  RCALL  0A30
.................... 	i2c_write(regaddr<<3); 
011C2:  MOVLB  2
011C4:  RLCF   x69,W
011C6:  MOVWF  x6B
011C8:  RLCF   x6B,F
011CA:  RLCF   x6B,F
011CC:  MOVLW  F8
011CE:  ANDWF  x6B,F
011D0:  MOVFF  26B,273
011D4:  MOVLB  0
011D6:  RCALL  0A30
.................... 	i2c_start(); 
011D8:  BSF    F94.4
011DA:  NOP   
011DC:  BSF    F94.3
011DE:  NOP   
011E0:  BTFSS  F82.3
011E2:  BRA    11E0
011E4:  BCF    F8B.4
011E6:  BCF    F94.4
011E8:  NOP   
011EA:  BCF    F8B.3
011EC:  BCF    F94.3
.................... 	delay_us(15); 
011EE:  CLRWDT
011F0:  MOVLW  09
011F2:  MOVWF  00
011F4:  DECFSZ 00,F
011F6:  BRA    11F4
011F8:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                  
011FA:  MOVLW  9B
011FC:  MOVLB  2
011FE:  MOVWF  x73
01200:  MOVLB  0
01202:  RCALL  0A30
.................... 	data=i2c_read(0); 
01204:  CLRF   00
01206:  BRA    114C
01208:  MOVFF  01,26A
.................... 	i2c_stop(); 
0120C:  BCF    F94.4
0120E:  NOP   
01210:  BSF    F94.3
01212:  BTFSS  F82.3
01214:  BRA    1212
01216:  NOP   
01218:  BRA    121A
0121A:  NOP   
0121C:  BSF    F94.4
0121E:  NOP   
....................  
.................... 	return data; 
01220:  MOVLB  2
01222:  MOVFF  26A,01
.................... } 
01226:  MOVLB  0
01228:  RETURN 0
....................  
.................... void uart_write(int8 regaddr, int8 data ) {                                                                   
.................... 	i2c_start(); 
*
00A82:  BSF    F94.4
00A84:  NOP   
00A86:  BSF    F94.3
00A88:  NOP   
00A8A:  BCF    F8B.4
00A8C:  BCF    F94.4
00A8E:  NOP   
00A90:  BCF    F8B.3
00A92:  BCF    F94.3
.................... 	delay_us(15);                                                  
00A94:  CLRWDT
00A96:  MOVLW  09
00A98:  MOVWF  00
00A9A:  DECFSZ 00,F
00A9C:  BRA    0A9A
00A9E:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                        
00AA0:  MOVLW  9A
00AA2:  MOVLB  2
00AA4:  MOVWF  x73
00AA6:  MOVLB  0
00AA8:  RCALL  0A30
.................... 	i2c_write(regaddr<< 3);  // write cycle          
00AAA:  MOVLB  2
00AAC:  RLCF   x70,W
00AAE:  MOVWF  x72
00AB0:  RLCF   x72,F
00AB2:  RLCF   x72,F
00AB4:  MOVLW  F8
00AB6:  ANDWF  x72,F
00AB8:  MOVFF  272,273
00ABC:  MOVLB  0
00ABE:  RCALL  0A30
.................... 	i2c_write(data); 
00AC0:  MOVFF  271,273
00AC4:  RCALL  0A30
.................... 	i2c_stop(); 
00AC6:  BCF    F94.4
00AC8:  NOP   
00ACA:  BSF    F94.3
00ACC:  BTFSS  F82.3
00ACE:  BRA    0ACC
00AD0:  NOP   
00AD2:  BRA    0AD4
00AD4:  NOP   
00AD6:  BSF    F94.4
00AD8:  NOP   
.................... }  
00ADA:  RETURN 0
....................  
.................... void uart_putc(int8 data ) { 
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register 
*
015C8:  MOVLB  2
015CA:  CLRF   x70
015CC:  MOVFF  26F,271
015D0:  MOVLB  0
015D2:  CALL   0A82
.................... } 
015D6:  GOTO   1720 (RETURN)
....................  
.................... int1 uart_kbhit(void) { 
.................... 	return (uart_read(UART_LSR) & 0x01); 
*
0122A:  MOVLW  05
0122C:  MOVLB  2
0122E:  MOVWF  x69
01230:  MOVLB  0
01232:  RCALL  119A
01234:  MOVF   01,W
01236:  ANDLW  01
01238:  MOVWF  01
.................... } 
0123A:  RETURN 0
....................  
.................... #inline 
.................... int8 uart_getc() { 
.................... 	return uart_read(UART_RHR); 
*
01248:  MOVLB  2
0124A:  CLRF   x69
0124C:  MOVLB  0
0124E:  RCALL  119A
01250:  MOVF   01,W
.................... } 
....................  
.................... void uart_init(void) { 
.................... 	output_low(UART_RESET); 
*
00ADC:  BCF    F93.1
00ADE:  BCF    F8A.1
.................... 	delay_ms(10); 
00AE0:  MOVLW  0A
00AE2:  MOVLB  2
00AE4:  MOVWF  x68
00AE6:  MOVLB  0
00AE8:  RCALL  0A00
.................... 	output_high(UART_RESET); 
00AEA:  BCF    F93.1
00AEC:  BSF    F8A.1
.................... 	delay_ms(10); 
00AEE:  MOVLW  0A
00AF0:  MOVLB  2
00AF2:  MOVWF  x68
00AF4:  MOVLB  0
00AF6:  RCALL  0A00
....................  
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */ 
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor 
00AF8:  MOVLW  03
00AFA:  MOVLB  2
00AFC:  MOVWF  x70
00AFE:  MOVLW  80
00B00:  MOVWF  x71
00B02:  MOVLB  0
00B04:  RCALL  0A82
.................... 	uart_write(UART_DLL, 12);    // divide clock by 12 for 9600 baud when using 1.8432 crystal 
00B06:  MOVLB  2
00B08:  CLRF   x70
00B0A:  MOVLW  0C
00B0C:  MOVWF  x71
00B0E:  MOVLB  0
00B10:  RCALL  0A82
.................... 	uart_write(UART_DLH, 0); 
00B12:  MOVLW  01
00B14:  MOVLB  2
00B16:  MOVWF  x70
00B18:  CLRF   x71
00B1A:  MOVLB  0
00B1C:  RCALL  0A82
....................  
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register 
00B1E:  MOVLW  03
00B20:  MOVLB  2
00B22:  MOVWF  x70
00B24:  MOVLW  BF
00B26:  MOVWF  x71
00B28:  MOVLB  0
00B2A:  RCALL  0A82
.................... 	uart_write(UART_EFR, 0x10); // enable enhanced registers 
00B2C:  MOVLW  02
00B2E:  MOVLB  2
00B30:  MOVWF  x70
00B32:  MOVLW  10
00B34:  MOVWF  x71
00B36:  MOVLB  0
00B38:  RCALL  0A82
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity 
00B3A:  MOVLW  03
00B3C:  MOVLB  2
00B3E:  MOVWF  x70
00B40:  MOVWF  x71
00B42:  MOVLB  0
00B44:  RCALL  0A82
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available 
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode 
00B46:  MOVLW  02
00B48:  MOVLB  2
00B4A:  MOVWF  x70
00B4C:  MOVLW  07
00B4E:  MOVWF  x71
00B50:  MOVLB  0
00B52:  RCALL  0A82
.................... } 
00B54:  GOTO   0DF4 (RETURN)
....................  
....................  
.................... #include "live.c" 
.................... int16 crc_chk(int8 *data, int8 length) { 
*
0138E:  MOVLB  3
01390:  SETF   x22
01392:  SETF   x21
.................... 	int8 j; 
.................... 	int16 reg_crc=0xFFFF; 
....................  
.................... 	while ( length-- ) { 
01394:  MOVF   x1F,W
01396:  DECF   x1F,F
01398:  XORLW  00
0139A:  BZ    13E8
.................... 		reg_crc ^= *data++; 
0139C:  MOVFF  31E,03
013A0:  MOVF   x1D,W
013A2:  INCF   x1D,F
013A4:  BTFSC  FD8.2
013A6:  INCF   x1E,F
013A8:  MOVWF  FE9
013AA:  MOVFF  03,FEA
013AE:  MOVF   FEF,W
013B0:  XORWF  x21,F
....................  
.................... 		for ( j=0 ; j<8 ; j++ ) { 
013B2:  CLRF   x20
013B4:  MOVF   x20,W
013B6:  SUBLW  07
013B8:  BNC   13E6
.................... 			if ( reg_crc & 0x01 ) { 
013BA:  MOVF   x21,W
013BC:  ANDLW  01
013BE:  MOVWF  00
013C0:  CLRF   03
013C2:  MOVF   00,W
013C4:  IORWF  03,W
013C6:  BZ    13DC
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001; 
013C8:  BCF    FD8.0
013CA:  RRCF   x22,W
013CC:  MOVWF  x24
013CE:  RRCF   x21,W
013D0:  XORLW  01
013D2:  MOVWF  x21
013D4:  MOVF   x24,W
013D6:  XORLW  A0
013D8:  MOVWF  x22
.................... 			} else { 
013DA:  BRA    13E2
.................... 				reg_crc=reg_crc>>1; 
013DC:  BCF    FD8.0
013DE:  RRCF   x22,F
013E0:  RRCF   x21,F
.................... 			} 
.................... 		}	 
013E2:  INCF   x20,F
013E4:  BRA    13B4
.................... 	} 
013E6:  BRA    1394
.................... 	 
.................... 	return reg_crc; 
013E8:  MOVFF  321,01
013EC:  MOVFF  322,02
.................... } 
013F0:  MOVLB  0
013F2:  RETURN 0
....................  
.................... /* send CAN registers in RSTap data format */ 
.................... void live_send_vcs(void) { 
.................... 	static int16 sequenceNumber=0; 
.................... 	int16 lCRC; 
.................... 	int8 i,j; 
.................... 	int8 buff[177]; 
....................  
.................... 	memset(buff,0,sizeof(buff)); 
*
013FC:  MOVLW  02
013FE:  MOVWF  FEA
01400:  MOVLW  6C
01402:  MOVWF  FE9
01404:  CLRF   00
01406:  CLRF   02
01408:  MOVLW  B1
0140A:  MOVWF  01
0140C:  RCALL  0DB4
....................  
.................... 	buff[0]='#'; 
0140E:  MOVLW  23
01410:  MOVLB  2
01412:  MOVWF  x6C
.................... 	buff[1]=config.serial_prefix; 
01414:  MOVFF  22,26D
.................... 	buff[2]=make8(config.serial_number,1); 
01418:  MOVFF  24,26E
.................... 	buff[3]=make8(config.serial_number,0);  
0141C:  MOVFF  23,26F
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */ 
01420:  SETF   x70
.................... 	buff[5]=18; /* packet type */ 
01422:  MOVLW  12
01424:  MOVWF  x71
.................... 	buff[6]=0; 
01426:  CLRF   x72
.................... 	buff[7]=179; /* 17 bytes header + 160 bytes CAN data + 2 bytes CRC */ 
01428:  MOVLW  B3
0142A:  MOVWF  x73
....................  
.................... 	buff[8]=make8(sequenceNumber,1); 
0142C:  MOVFF  15D,274
01430:  MOVLB  2
.................... 	buff[9]=make8(sequenceNumber,0); 
01432:  MOVFF  15C,275
01436:  MOVLB  2
....................  
.................... 	/* device info */ 
.................... 	/* WorldData device type identifier (16-bit) .... 1600 for VCSTap */ 
.................... 	buff[10]=make8(1600,1); 
01438:  MOVLW  06
0143A:  MOVWF  x76
.................... 	buff[11]=make8(1600,0); 
0143C:  MOVLW  40
0143E:  MOVWF  x77
.................... 	/* manufacturers serial number */ 
.................... 	buff[12]=0; 
01440:  CLRF   x78
.................... 	buff[13]=config.pair_serial_prefix; 
01442:  MOVFF  25,279
.................... 	buff[14]=make8(config.pair_serial_number,1); 
01446:  MOVFF  27,27A
.................... 	buff[15]=make8(config.pair_serial_number,0); 
0144A:  MOVFF  26,27B
.................... 	/* status of the data read  .... no error */ 
.................... 	buff[16]=0; 
0144E:  CLRF   x7C
....................  
.................... 	/* shut down CAN reception and copy CAN registers over */ 
.................... 	disable_interrupts(INT_CANRX0); 
01450:  BCF    FA3.0
.................... 	disable_interrupts(INT_CANRX1); 
01452:  BCF    FA3.1
.................... 	/* do our endian swap one word at a time */ 
.................... 	for ( i=0 ; i<160 ; i+=4 ) { 
01454:  CLRF   x6A
01456:  MOVF   x6A,W
01458:  SUBLW  9F
0145A:  BNC   152C
.................... 		j=i + 17; 
0145C:  MOVLW  11
0145E:  ADDWF  x6A,W
01460:  MOVWF  x6B
....................  
.................... 		buff[j+0]=timer.vcs_register[i+1]; 
01462:  CLRF   03
01464:  MOVF   x6B,W
01466:  ADDLW  6C
01468:  MOVWF  01
0146A:  MOVLW  02
0146C:  ADDWFC 03,F
0146E:  MOVLW  01
01470:  MOVLB  2
01472:  ADDWF  x6A,W
01474:  ADDLW  B3
01476:  MOVWF  FE9
01478:  CLRF   FEA
0147A:  BTFSC  FD8.0
0147C:  INCF   FEA,F
0147E:  MOVFF  FEF,31F
01482:  MOVLB  3
01484:  MOVFF  03,FEA
01488:  MOVFF  01,FE9
0148C:  MOVFF  31F,FEF
.................... 		buff[j+1]=timer.vcs_register[i+0]; 
01490:  MOVLW  01
01492:  MOVLB  2
01494:  ADDWF  x6B,W
01496:  CLRF   03
01498:  ADDLW  6C
0149A:  MOVWF  01
0149C:  MOVLW  02
0149E:  ADDWFC 03,F
014A0:  MOVLW  B3
014A2:  MOVLB  2
014A4:  ADDWF  x6A,W
014A6:  MOVWF  FE9
014A8:  CLRF   FEA
014AA:  BTFSC  FD8.0
014AC:  INCF   FEA,F
014AE:  MOVFF  FEF,31F
014B2:  MOVLB  3
014B4:  MOVFF  03,FEA
014B8:  MOVFF  01,FE9
014BC:  MOVFF  31F,FEF
.................... 		buff[j+2]=timer.vcs_register[i+3]; 
014C0:  MOVLW  02
014C2:  MOVLB  2
014C4:  ADDWF  x6B,W
014C6:  CLRF   03
014C8:  ADDLW  6C
014CA:  MOVWF  01
014CC:  MOVLW  02
014CE:  ADDWFC 03,F
014D0:  MOVLW  03
014D2:  MOVLB  2
014D4:  ADDWF  x6A,W
014D6:  ADDLW  B3
014D8:  MOVWF  FE9
014DA:  CLRF   FEA
014DC:  BTFSC  FD8.0
014DE:  INCF   FEA,F
014E0:  MOVFF  FEF,31F
014E4:  MOVLB  3
014E6:  MOVFF  03,FEA
014EA:  MOVFF  01,FE9
014EE:  MOVFF  31F,FEF
.................... 		buff[j+3]=timer.vcs_register[i+2]; 
014F2:  MOVLW  03
014F4:  MOVLB  2
014F6:  ADDWF  x6B,W
014F8:  CLRF   03
014FA:  ADDLW  6C
014FC:  MOVWF  01
014FE:  MOVLW  02
01500:  ADDWFC 03,F
01502:  MOVLW  02
01504:  MOVLB  2
01506:  ADDWF  x6A,W
01508:  ADDLW  B3
0150A:  MOVWF  FE9
0150C:  CLRF   FEA
0150E:  BTFSC  FD8.0
01510:  INCF   FEA,F
01512:  MOVFF  FEF,31F
01516:  MOVLB  3
01518:  MOVFF  03,FEA
0151C:  MOVFF  01,FE9
01520:  MOVFF  31F,FEF
.................... 	} 
01524:  MOVLW  04
01526:  MOVLB  2
01528:  ADDWF  x6A,F
0152A:  BRA    1456
....................  
.................... 	/* set fault indicator LED */ 
....................  
.................... 	/* any fault */ 
.................... //	if ( timer.vcs_register[30*4] || timer.vcs_register[30*4+1] || timer.vcs_register[30*4+2] || timer.vcs_register[30*4+3] ) { 
.................... 	/* system state 6 (FAULT) */ 
.................... 	if ( 6==timer.vcs_register[19*4+3] && 0==timer.vcs_register[19*4+2] && 0==timer.vcs_register[19*4+1] && 0==timer.vcs_register[19*4+0] ) { 
0152C:  MOVLB  1
0152E:  MOVF   x02,W
01530:  SUBLW  06
01532:  BNZ   1550
01534:  MOVF   x01,F
01536:  BNZ   1550
01538:  MOVF   x00,F
0153A:  BNZ   1550
0153C:  MOVLB  0
0153E:  MOVF   xFF,F
01540:  BTFSC  FD8.2
01542:  BRA    1548
01544:  MOVLB  1
01546:  BRA    1550
.................... 		output_high(RELAY_RED); 
01548:  BCF    F93.5
0154A:  BSF    F8A.5
.................... 	} else { 
0154C:  BRA    1556
0154E:  MOVLB  1
.................... 		output_low(RELAY_RED); 
01550:  BCF    F93.5
01552:  BCF    F8A.5
01554:  MOVLB  0
.................... 	} 
....................  
.................... 	enable_interrupts(INT_CANRX0); 
01556:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1); 
01558:  BSF    FA3.1
....................  
.................... 	/* compute CRC on header and result data */ 
.................... 	lCRC=crc_chk(buff+1,sizeof(buff)-1); 
0155A:  MOVLW  02
0155C:  MOVLB  3
0155E:  MOVWF  x1E
01560:  MOVLW  6D
01562:  MOVWF  x1D
01564:  MOVLW  B0
01566:  MOVWF  x1F
01568:  MOVLB  0
0156A:  RCALL  138E
0156C:  MOVFF  02,269
01570:  MOVFF  01,268
....................  
.................... 	/* send buff, qbuff.rResult, CRC */ 
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) { 
01574:  MOVLB  2
01576:  CLRF   x6A
01578:  MOVF   x6A,W
0157A:  SUBLW  B0
0157C:  BNC   159E
.................... 		fputc(buff[i],rs232); 
0157E:  CLRF   03
01580:  MOVF   x6A,W
01582:  ADDLW  6C
01584:  MOVWF  FE9
01586:  MOVLW  02
01588:  ADDWFC 03,W
0158A:  MOVWF  FEA
0158C:  MOVFF  FEF,31D
01590:  MOVLB  3
01592:  MOVF   x1D,W
01594:  MOVLB  0
01596:  RCALL  13F4
.................... 	}	 
01598:  MOVLB  2
0159A:  INCF   x6A,F
0159C:  BRA    1578
.................... 	fputc(make8(lCRC,1),rs232); 
0159E:  MOVFF  269,31D
015A2:  MOVLB  3
015A4:  MOVF   x1D,W
015A6:  MOVLB  0
015A8:  RCALL  13F4
.................... 	fputc(make8(lCRC,0),rs232); 
015AA:  MOVFF  268,31D
015AE:  MOVLB  3
015B0:  MOVF   x1D,W
015B2:  MOVLB  0
015B4:  RCALL  13F4
....................  
.................... 	sequenceNumber++; 
015B6:  MOVLB  1
015B8:  INCF   x5C,F
015BA:  BTFSC  FD8.2
015BC:  INCF   x5D,F
....................  
.................... 	output_high(SYNC_OUT); 
015BE:  BCF    F94.5
015C0:  BSF    F8B.5
.................... } 
015C2:  MOVLB  0
015C4:  GOTO   185E (RETURN)
....................  
.................... /*		 
.................... '#'                 0  STX 
.................... UNIT ID PREFIX      1  First character (A-Z) for serial number 
.................... UNIT ID MSB         2  high byte of sending station ID 
.................... UNIT ID LSB         3  low byte of sending station ID 
.................... PACKET LENGTH       4  number of byte for packet including STX through CRC 
.................... PACKET TYPE         5  type of packet we are sending, 27 
.................... SEQUENCE MSB        6 
.................... SEQUENCE LSB        7 
....................  
.................... CRC MSB              high byte of CRC on everything after STX and before CRC 
.................... CRC LSB              low byte of CRC 
.................... */ 
....................  
....................  
.................... int1 live_send_xrw2g() { 
*
015DA:  MOVLB  2
015DC:  BSF    x6D.0
.................... 	int16 lCRC, rCRC; 
.................... 	int8 i; 
.................... 	int1 valid=1; 
....................  
.................... //	fprintf(rs232,"# (live) xrw2g_packet{=0x%02X, 0x%02X, 0x%02X}\r\n",timer.xrw2g_packet[1],timer.xrw2g_packet[2],timer.xrw2g_packet[3]); 
....................  
....................  
....................  
.................... 	/* if wireless sensors, we might have heard something else and gotten in here. In that case, we 
.................... 	 drop back out and try again*/ 
.................... 	if ( SENSOR_SOURCE_WIRELESS == config.sensor_source ) { 
015DE:  DECFSZ 28,W
015E0:  BRA    1636
.................... 	    valid=0; 
015E2:  BCF    x6D.0
....................  
.................... 	    /* check packet type */ 
.................... 	    if ( 23==timer.xrw2g_packet[5] && timer.xrw2g_buff_pos>10 ) { 
015E4:  MOVF   35,W
015E6:  SUBLW  17
015E8:  BNZ   1636
015EA:  MOVLB  0
015EC:  MOVF   xB0,W
015EE:  SUBLW  0A
015F0:  BTFSS  FD8.0
015F2:  BRA    15F8
015F4:  MOVLB  2
015F6:  BRA    1636
.................... 			/* is XRW2G packet */ 
.................... 			if ( 0==config.pair_serial_prefix && 0==config.pair_serial_number ) { 
015F8:  MOVF   25,F
015FA:  BNZ   160C
015FC:  MOVF   26,F
015FE:  BNZ   160C
01600:  MOVF   27,F
01602:  BNZ   160C
.................... 			    /* valid packet from an XRW2G, and we don't care which one */ 
.................... 			    valid=1; 
01604:  MOVLB  2
01606:  BSF    x6D.0
.................... 			} else if ( timer.xrw2g_packet[1] == config.pair_serial_prefix && make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) == config.pair_serial_number ) { 
01608:  BRA    1636
0160A:  MOVLB  0
0160C:  MOVF   25,W
0160E:  SUBWF  31,W
01610:  BNZ   1638
01612:  MOVFF  32,26F
01616:  MOVFF  33,26E
0161A:  MOVF   26,W
0161C:  MOVLB  2
0161E:  SUBWF  33,W
01620:  BTFSC  FD8.2
01622:  BRA    1628
01624:  MOVLB  0
01626:  BRA    1638
01628:  MOVF   27,W
0162A:  SUBWF  x6F,W
0162C:  BTFSC  FD8.2
0162E:  BRA    1634
01630:  MOVLB  0
01632:  BRA    1638
.................... 			    valid=1; 
01634:  BSF    x6D.0
01636:  MOVLB  0
.................... 			} 
.................... 	    } 
.................... 	} 
....................  
.................... 	if ( 0 == valid ) { 
01638:  MOVLB  2
0163A:  BTFSC  x6D.0
0163C:  BRA    1648
.................... 	    /* clear buffer and we'll try again next time */ 
.................... 	    timer.xrw2g_buff_pos=0; 
0163E:  MOVLB  0
01640:  CLRF   xB0
.................... 	    return false; 
01642:  MOVLW  00
01644:  MOVWF  01
01646:  BRA    172E
.................... 	} 
....................  
.................... /*		 
.................... '#'                   0  STX 
.................... UNIT ID PREFIX        1  First character (A-Z) for serial number 
.................... UNIT ID MSB           2  high byte of sending station ID 
.................... UNIT ID LSB           3  low byte of sending station ID 
.................... PACKET LENGTH         4  number of byte for packet including STX through CRC 
.................... PACKET TYPE           5  type of packet we are sending, 23 
.................... SEQUENCE MSB          6 
.................... SEQUENCE LSB          7 
.................... (snip) 
.................... CRC MSB               96 high byte of CRC on everything after STX and before CRC 
.................... CRC LSB               97 low byte of CRC 
.................... 	config.serial_prefix='Z'; 
.................... 	config.serial_number=9876; 
.................... */ 
.................... 	/* check for valid CRC */ 
.................... 	if ( timer.xrw2g_buff_pos>=98 ) { 
01648:  MOVLB  0
0164A:  MOVF   xB0,W
0164C:  SUBLW  61
0164E:  BC    1688
.................... 		rCRC = make16(timer.xrw2g_packet[96],timer.xrw2g_packet[97]); 
01650:  MOVFF  90,26B
01654:  MOVFF  91,26A
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
01658:  MOVLB  3
0165A:  CLRF   x1E
0165C:  MOVLW  31
0165E:  MOVWF  x1D
01660:  MOVLW  5F
01662:  MOVWF  x1F
01664:  MOVLB  0
01666:  RCALL  138E
01668:  MOVFF  02,269
0166C:  MOVFF  01,268
....................  
.................... 		if ( lCRC != rCRC ) { 
01670:  MOVLB  2
01672:  MOVF   x6A,W
01674:  SUBWF  x68,W
01676:  BNZ   167E
01678:  MOVF   x6B,W
0167A:  SUBWF  x69,W
0167C:  BZ    168A
.................... 		    /* clear buffer and we'll try again next time */ 
.................... 		    timer.xrw2g_buff_pos=0; 
0167E:  MOVLB  0
01680:  CLRF   xB0
.................... 		    return false; 
01682:  MOVLW  00
01684:  MOVWF  01
01686:  BRA    172E
01688:  MOVLB  2
.................... 		} 
.................... 	} 
....................  
.................... //	fprintf(rs232,"@ (sp=%c) (sn=%lu) (buff_pos=%u) @\r\n",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]),timer.xrw2g_buff_pos); 
.................... 	/* check for default serial number */ 
.................... 	if ( 'Z' == timer.xrw2g_packet[1] && 9876 == make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3]) && timer.xrw2g_buff_pos>=98 ) { 
0168A:  MOVF   31,W
0168C:  SUBLW  5A
0168E:  BNZ   16E0
01690:  MOVFF  32,03
01694:  MOVF   33,W
01696:  SUBLW  94
01698:  BNZ   16E0
0169A:  MOVF   03,W
0169C:  SUBLW  26
0169E:  BNZ   16E0
016A0:  MOVLB  0
016A2:  MOVF   xB0,W
016A4:  SUBLW  61
016A6:  BTFSS  FD8.0
016A8:  BRA    16AE
016AA:  MOVLB  2
016AC:  BRA    16E0
.................... 		/* valid XRW2G packet with default serial number ... now we overwrite with our serial number */ 
.................... 		timer.xrw2g_packet[1]=config.serial_prefix; 
016AE:  MOVFF  22,31
.................... 		timer.xrw2g_packet[2]=make8(config.serial_number,1); 
016B2:  MOVFF  24,32
.................... 		timer.xrw2g_packet[3]=make8(config.serial_number,0); 
016B6:  MOVFF  23,33
....................  
.................... 		/* and re-calculate and replace CRC */ 
.................... 		lCRC=crc_chk(timer.xrw2g_packet+1,95); 
016BA:  MOVLB  3
016BC:  CLRF   x1E
016BE:  MOVLW  31
016C0:  MOVWF  x1D
016C2:  MOVLW  5F
016C4:  MOVWF  x1F
016C6:  MOVLB  0
016C8:  RCALL  138E
016CA:  MOVFF  02,269
016CE:  MOVFF  01,268
.................... 		timer.xrw2g_packet[96]=make8(lCRC,1);		timer.xrw2g_packet[97]=make8(lCRC,0); 
016D2:  MOVFF  269,90
016D6:  MOVLB  2
016D8:  MOVFF  268,91
016DC:  MOVLB  0
016DE:  MOVLB  2
.................... 	} 
....................  
....................  
....................  
.................... 	for ( i=0 ; i<98 ; i++ ) { 
016E0:  CLRF   x6C
016E2:  MOVF   x6C,W
016E4:  SUBLW  61
016E6:  BNC   1726
.................... 	    if ( config.world_to_xport ) 
016E8:  MOVF   2A,F
016EA:  BZ    1704
.................... 			fputc(timer.xrw2g_packet[i],rs232); 
016EC:  MOVLW  30
016EE:  ADDWF  x6C,W
016F0:  MOVWF  FE9
016F2:  CLRF   FEA
016F4:  BTFSC  FD8.0
016F6:  INCF   FEA,F
016F8:  MOVFF  FEF,26E
016FC:  MOVF   x6E,W
016FE:  MOVLB  0
01700:  RCALL  13F4
01702:  MOVLB  2
.................... 	    if ( config.world_to_xbee ) 
01704:  MOVF   29,F
01706:  BZ    1722
.................... 			uart_putc(timer.xrw2g_packet[i]); 
01708:  MOVLW  30
0170A:  ADDWF  x6C,W
0170C:  MOVWF  FE9
0170E:  CLRF   FEA
01710:  BTFSC  FD8.0
01712:  INCF   FEA,F
01714:  MOVFF  FEF,26E
01718:  MOVFF  26E,26F
0171C:  MOVLB  0
0171E:  BRA    15C8
01720:  MOVLB  2
.................... 	} 
01722:  INCF   x6C,F
01724:  BRA    16E2
....................  
.................... 	timer.xrw2g_buff_pos=0; 
01726:  MOVLB  0
01728:  CLRF   xB0
.................... 	return true; 
0172A:  MOVLW  01
0172C:  MOVWF  01
.................... } 
0172E:  GOTO   1878 (RETURN)
....................  
....................  
.................... #include "modbus_slave_vcstap.c" 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE 88888 
.................... #define MODBUS_INT_RDA2 66666 
....................  
.................... #define MODBUS_TYPE                MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_INT_SOURCE   MODBUS_INT_RDA    // Select between external interrupt 
.................... #define MODBUS_SERIAL_TIMEOUT      10000    //in us 
....................  
.................... #inline  
.................... void rcv_off(void) { 
.................... 	disable_interrupts(INT_RDA); 
.................... } 
....................  
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer 
....................  
....................  
.................... #byte TXSTA=0xfad // PIC18F24J11 TXSTA for UART1 */ 
.................... #bit  TRMT=TXSTA.1 
....................  
.................... #inline 
.................... void wait_for_hw_buffer(void) { 
.................... 	while ( ! TRMT ) 
.................... 		; 
.................... } 
....................  
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    int8 b[2]; 
....................    int16 d; 
.................... } modbus_serial_crc; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) { 
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
.................... 	while(kbhit(rs232)) { 
.................... 		fgetc(rs232); 
.................... 	}   
.................... 	 
.................... 	clear_interrupt(INT_RDA); 
.................... 	enable_interrupts(INT_RDA); 
.................... } 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() { 
....................  
.................... 	RCV_ON(); 
....................  
.................... 	setup_timer_0(RTCC_INTERNAL | RTCC_DIV_32 | RTCC_8_BIT); 
.................... 	enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... void modbus_enable_timeout(int1 enable) { 
.................... 	disable_interrupts(INT_TIMER0); 
*
0030A:  BCF    FF2.5
.................... 	if (enable) { 
0030C:  MOVLB  3
0030E:  MOVF   x26,F
00310:  BZ    031A
.................... 		set_timer0(0); 
00312:  CLRF   FD7
00314:  CLRF   FD6
.................... 		clear_interrupt(INT_TIMER0); 
00316:  BCF    FF2.2
.................... 		enable_interrupts(INT_TIMER0); 
00318:  BSF    FF2.5
.................... 	} 
.................... } 
0031A:  MOVLB  0
0031C:  RETURN 0
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... //#int_timer2 
.................... #int_timer0 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0031E:  MOVLB  1
00320:  MOVF   x5F,W
00322:  SUBLW  02
00324:  BNZ   033A
00326:  MOVF   x60,F
00328:  BNZ   033A
0032A:  MOVF   x61,F
0032C:  BNZ   033A
0032E:  BTFSC  x5E.0
00330:  BRA    033A
....................    { 
....................       modbus_rx.len-=2; 
00332:  MOVLW  02
00334:  SUBWF  x63,F
....................       modbus_serial_new=TRUE; 
00336:  BSF    x5E.0
....................    } 
....................    else 
00338:  BRA    033C
....................       modbus_serial_new=FALSE; 
0033A:  BCF    x5E.0
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0033C:  SETF   x61
0033E:  SETF   x60
....................    modbus_serial_state=MODBUS_GETADDY; 
00340:  CLRF   x5F
....................    modbus_enable_timeout(FALSE); 
00342:  MOVLB  3
00344:  CLRF   x26
00346:  MOVLB  0
00348:  RCALL  030A
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0034A:  BCF    FF2.2
0034C:  GOTO   009C
.................... void modbus_calc_crc(char data) 
.................... { 
....................   unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
003DC:  MOVLB  1
003DE:  MOVF   x61,W
003E0:  MOVLB  3
003E2:  XORWF  x26,W
003E4:  MOVWF  x27
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
003E6:  CLRF   03
003E8:  MOVF   x27,W
003EA:  MOVLB  0
003EC:  RCALL  00EA
003EE:  MOVWF  01
003F0:  MOVLB  1
003F2:  MOVF   x60,W
003F4:  XORWF  01,W
003F6:  MOVWF  x61
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
003F8:  CLRF   03
003FA:  MOVLB  3
003FC:  MOVF   x27,W
003FE:  MOVLB  0
00400:  RCALL  01FA
00402:  MOVFF  FE8,160
.................... } 
00406:  GOTO   0468 (RETURN)
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) { 
.................... 	fputc(c, rs232); 
.................... 	modbus_calc_crc(c); 
.................... 	delay_us(53); 
.................... } 
....................  
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
....................    modbus_serial_new=FALSE; 
....................  
....................    RCV_OFF(); 
....................     
....................  
....................  
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    modbus_serial_putc(to); 
....................    modbus_serial_putc(func); 
.................... } 
....................  
.................... void modbus_serial_send_stop() { 
....................    int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
....................    crc_low=modbus_serial_crc.b[0]; 
....................  
....................    modbus_serial_putc(crc_high); 
....................    modbus_serial_putc(crc_low); 
....................  
....................    WAIT_FOR_HW_BUFFER(); 
....................      
.................... 	/* 3.5 character delay */ 
.................... 	delay_us(183); 
....................  
....................    RCV_ON(); 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
....................       return FALSE; 
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
....................       modbus_rx.len = 1; 
....................    } 
....................    modbus_serial_new=FALSE; 
....................    return TRUE; 
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*reg_data); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "interrupt.c" 
.................... #int_timer2 
.................... void isr_1ms(void) { 
.................... 	static int16 telem_count=0; 
.................... 	output_high(TP_RED); 
*
00350:  BCF    F93.6
00352:  BSF    F8A.6
.................... 	 
.................... 	if ( timer.vcs_query_age < 65535 ) 
00354:  MOVLB  1
00356:  INCFSZ x53,W
00358:  BRA    0360
0035A:  INCFSZ x54,W
0035C:  BRA    0360
0035E:  BRA    0366
.................... 		timer.vcs_query_age++; 
00360:  INCF   x53,F
00362:  BTFSC  FD8.2
00364:  INCF   x54,F
....................  
....................  
.................... 	/* data ages */ 
.................... 	if ( timer.xrw2g_age < 65535 ) 
00366:  MOVLB  0
00368:  INCFSZ xB1,W
0036A:  BRA    0372
0036C:  INCFSZ xB2,W
0036E:  BRA    0372
00370:  BRA    0378
.................... 		timer.xrw2g_age++; 
00372:  INCF   xB1,F
00374:  BTFSC  FD8.2
00376:  INCF   xB2,F
....................  
....................  
.................... 	if ( telem_count < 10000 ) { 
00378:  MOVLB  2
0037A:  MOVF   x66,W
0037C:  SUBLW  27
0037E:  BNC   0390
00380:  BNZ   0388
00382:  MOVF   x65,W
00384:  SUBLW  0F
00386:  BNC   0390
.................... 		telem_count++; 
00388:  INCF   x65,F
0038A:  BTFSC  FD8.2
0038C:  INCF   x66,F
.................... 	} else { 
0038E:  BRA    039C
.................... 		timer.now_telem=1; 
00390:  MOVLW  01
00392:  MOVLB  1
00394:  MOVWF  x5B
.................... 		telem_count=0; 
00396:  MOVLB  2
00398:  CLRF   x66
0039A:  CLRF   x65
.................... 	} 
....................  
....................  
.................... 	/* LED Green */ 
.................... 	if ( 0==timer.led_on_green ) { 
0039C:  MOVLB  1
0039E:  MOVF   x58,F
003A0:  BNZ   03AC
003A2:  MOVF   x59,F
003A4:  BNZ   03AC
.................... 		output_low(LED_GREEN); 
003A6:  BCF    F93.4
003A8:  BCF    F8A.4
.................... 	} else { 
003AA:  BRA    03B8
.................... 		output_high(LED_GREEN); 
003AC:  BCF    F93.4
003AE:  BSF    F8A.4
.................... 		timer.led_on_green--; 
003B0:  MOVF   x58,W
003B2:  BTFSC  FD8.2
003B4:  DECF   x59,F
003B6:  DECF   x58,F
.................... 	} 
....................  
.................... #if 0 
.................... 	/* LED Red */ 
.................... 	if ( 0==timer.led_on_red ) { 
.................... 		output_low(LED_RED); 
.................... 	} else { 
.................... 		output_high(LED_RED); 
.................... 		timer.led_on_red--; 
.................... 	} 
.................... #endif 
....................  
.................... 	output_low(TP_RED); 
003B8:  BCF    F93.6
003BA:  BCF    F8A.6
.................... } 
....................  
003BC:  BCF    F9E.1
003BE:  MOVLB  0
003C0:  GOTO   009C
.................... #int_rda 
.................... void isr_serial_inverter(void) { 
.................... 	int8 c; 
.................... 	output_high(TP_ORANGE); 
*
0040A:  BCF    F93.7
0040C:  BSF    F8A.7
....................  
.................... 	c=fgetc(rs232); 
0040E:  BRA    03C4
00410:  MOVFF  01,325
....................  
.................... 	if ( timer.modbus_enable )  { 
00414:  MOVF   2B,F
00416:  BZ    0472
.................... 		if ( ! modbus_serial_new) { 
00418:  MOVLB  1
0041A:  BTFSC  x5E.0
0041C:  BRA    0474
.................... 			if ( modbus_serial_state == MODBUS_GETADDY) { 
0041E:  MOVF   x5F,F
00420:  BNZ   0432
.................... 				modbus_serial_crc.d = 0xFFFF; 
00422:  SETF   x61
00424:  SETF   x60
.................... 				modbus_rx.address = c; 
00426:  MOVFF  325,162
.................... 				modbus_serial_state++; 
0042A:  INCF   x5F,F
.................... 				modbus_rx.len = 0; 
0042C:  CLRF   x63
.................... 				modbus_rx.error=0; 
0042E:  CLRF   x65
.................... 			} else if ( modbus_serial_state == MODBUS_GETFUNC) { 
00430:  BRA    0460
00432:  DECFSZ x5F,W
00434:  BRA    043E
.................... 				modbus_rx.func = c; 
00436:  MOVFF  325,164
.................... 				modbus_serial_state++; 
0043A:  INCF   x5F,F
.................... 			} else if(modbus_serial_state == MODBUS_GETDATA) { 
0043C:  BRA    0460
0043E:  MOVF   x5F,W
00440:  SUBLW  02
00442:  BNZ   0460
.................... 				if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) { 
00444:  INCFSZ x63,W
00446:  BRA    044C
.................... 					modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
00448:  MOVLW  FE
0044A:  MOVWF  x63
.................... 				} 
.................... 				modbus_rx.data[modbus_rx.len]=c; 
0044C:  MOVLW  66
0044E:  ADDWF  x63,W
00450:  MOVWF  FE9
00452:  MOVLW  01
00454:  MOVWF  FEA
00456:  BTFSC  FD8.0
00458:  INCF   FEA,F
0045A:  MOVFF  325,FEF
.................... 				modbus_rx.len++; 
0045E:  INCF   x63,F
.................... 			} 
.................... 	 
.................... 			modbus_calc_crc(c); 
00460:  MOVFF  325,326
00464:  MOVLB  0
00466:  BRA    03DC
.................... 			modbus_enable_timeout(TRUE); 
00468:  MOVLW  01
0046A:  MOVLB  3
0046C:  MOVWF  x26
0046E:  MOVLB  0
00470:  RCALL  030A
00472:  MOVLB  1
.................... 		} 
.................... 	} 
.................... 	 
.................... 	output_low(TP_ORANGE); 
00474:  BCF    F93.7
00476:  BCF    F8A.7
.................... } 
....................  
....................  
....................  
00478:  BCF    F9E.5
0047A:  MOVLB  0
0047C:  GOTO   009C
.................... #inline 
.................... void can_receive(void) { 
.................... 	int8 buffer[8]; 
.................... 	int32 rx_id; 
.................... 	int8 rx_len; 
.................... 	struct rx_stat rx; 
....................  
....................  
.................... 	if ( can_getd(rx_id,&buffer,rx_len,rx) ) { 
*
0067C:  MOVLW  03
0067E:  MOVLB  3
00680:  MOVWF  x34
00682:  MOVLW  25
00684:  MOVWF  x33
*
0078E:  MOVF   01,F
00790:  BZ    0816
*
00826:  MOVLW  03
00828:  MOVLB  3
0082A:  MOVWF  x34
0082C:  MOVLW  25
0082E:  MOVWF  x33
*
00938:  MOVF   01,F
0093A:  BZ    09C0
.................... 		/* got something! */ 
.................... 		timer.led_on_green=50; 
*
00792:  MOVLB  1
00794:  CLRF   x59
00796:  MOVLW  32
00798:  MOVWF  x58
*
0093C:  MOVLB  1
0093E:  CLRF   x59
00940:  MOVLW  32
00942:  MOVWF  x58
....................  
.................... 		/* VCS is ID ... ignore everything else */ 
.................... 		if ( 3 != rx_id ) 
*
0079A:  MOVLB  3
0079C:  MOVF   x2D,W
0079E:  SUBLW  03
007A0:  BNZ   07AE
007A2:  MOVF   x2E,F
007A4:  BNZ   07AE
007A6:  MOVF   x2F,F
007A8:  BNZ   07AE
007AA:  MOVF   x30,F
007AC:  BZ    07B0
*
00944:  MOVLB  3
00946:  MOVF   x2D,W
00948:  SUBLW  03
0094A:  BNZ   0958
0094C:  MOVF   x2E,F
0094E:  BNZ   0958
00950:  MOVF   x2F,F
00952:  BNZ   0958
00954:  MOVF   x30,F
00956:  BZ    095A
.................... 			return; 
*
007AE:  BRA    0814
*
00958:  BRA    09BE
....................  
.................... 		if ( 8 != rx_len ) 
*
007B0:  MOVF   x31,W
007B2:  SUBLW  08
007B4:  BZ    07B8
*
0095A:  MOVF   x31,W
0095C:  SUBLW  08
0095E:  BZ    0962
.................... 			return; 
*
007B6:  BRA    0814
*
00960:  BRA    09BE
....................  
.................... 		/* make sure register number is in range */ 
.................... 		if ( buffer[0] >= VCS_N_REGISTERS )  
*
007B8:  MOVF   x25,W
007BA:  SUBLW  27
007BC:  BC    07C0
*
00962:  MOVF   x25,W
00964:  SUBLW  27
00966:  BC    096A
.................... 			return; 
*
007BE:  BRA    0814
*
00968:  BRA    09BE
....................  
.................... 		timer.dump_register=buffer[0]; 
*
007C0:  MOVFF  325,15A
*
0096A:  MOVFF  325,15A
....................  
.................... 		/* re-use rx_len */ 
.................... 		rx_len = buffer[0]<<2; 
*
007C4:  RLCF   x25,W
007C6:  MOVWF  x31
007C8:  RLCF   x31,F
007CA:  MOVLW  FC
007CC:  ANDWF  x31,F
*
0096E:  RLCF   x25,W
00970:  MOVWF  x31
00972:  RLCF   x31,F
00974:  MOVLW  FC
00976:  ANDWF  x31,F
....................  
.................... 		/* copy CAN data into appropriate register */ 
.................... 		timer.vcs_register[rx_len + 0]=buffer[4]; 
*
007CE:  MOVLW  B3
007D0:  ADDWF  x31,W
007D2:  MOVWF  FE9
007D4:  CLRF   FEA
007D6:  BTFSC  FD8.0
007D8:  INCF   FEA,F
007DA:  MOVFF  329,FEF
*
00978:  MOVLW  B3
0097A:  ADDWF  x31,W
0097C:  MOVWF  FE9
0097E:  CLRF   FEA
00980:  BTFSC  FD8.0
00982:  INCF   FEA,F
00984:  MOVFF  329,FEF
.................... 		timer.vcs_register[rx_len + 1]=buffer[5]; 
*
007DE:  MOVLW  01
007E0:  ADDWF  x31,W
007E2:  ADDLW  B3
007E4:  MOVWF  FE9
007E6:  CLRF   FEA
007E8:  BTFSC  FD8.0
007EA:  INCF   FEA,F
007EC:  MOVFF  32A,FEF
*
00988:  MOVLW  01
0098A:  ADDWF  x31,W
0098C:  ADDLW  B3
0098E:  MOVWF  FE9
00990:  CLRF   FEA
00992:  BTFSC  FD8.0
00994:  INCF   FEA,F
00996:  MOVFF  32A,FEF
.................... 		timer.vcs_register[rx_len + 2]=buffer[6]; 
*
007F0:  MOVLW  02
007F2:  ADDWF  x31,W
007F4:  ADDLW  B3
007F6:  MOVWF  FE9
007F8:  CLRF   FEA
007FA:  BTFSC  FD8.0
007FC:  INCF   FEA,F
007FE:  MOVFF  32B,FEF
*
0099A:  MOVLW  02
0099C:  ADDWF  x31,W
0099E:  ADDLW  B3
009A0:  MOVWF  FE9
009A2:  CLRF   FEA
009A4:  BTFSC  FD8.0
009A6:  INCF   FEA,F
009A8:  MOVFF  32B,FEF
.................... 		timer.vcs_register[rx_len + 3]=buffer[7]; 
*
00802:  MOVLW  03
00804:  ADDWF  x31,W
00806:  ADDLW  B3
00808:  MOVWF  FE9
0080A:  CLRF   FEA
0080C:  BTFSC  FD8.0
0080E:  INCF   FEA,F
00810:  MOVFF  32C,FEF
00814:  MOVLB  F
*
009AC:  MOVLW  03
009AE:  ADDWF  x31,W
009B0:  ADDLW  B3
009B2:  MOVWF  FE9
009B4:  CLRF   FEA
009B6:  BTFSC  FD8.0
009B8:  INCF   FEA,F
009BA:  MOVFF  32C,FEF
009BE:  MOVLB  F
.................... 	} 
.................... } 
....................  
....................  
.................... #INT_CANRX0 
.................... void isr_can_rx0(void) { 
.................... 	output_high(TP_ORANGE); 
*
00678:  BCF    F93.7
0067A:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
00816:  BCF    F93.7
00818:  BCF    F8A.7
.................... } 
....................  
0081A:  BCF    FA4.0
0081C:  MOVLB  0
0081E:  GOTO   009C
.................... #INT_CANRX1 
.................... void isr_can_rx1(void) { 
.................... 	output_high(TP_ORANGE); 
00822:  BCF    F93.7
00824:  BSF    F8A.7
.................... 	can_receive(); 
.................... 	output_low(TP_ORANGE); 
*
009C0:  BCF    F93.7
009C2:  BCF    F8A.7
.................... } 
....................  
....................  
009C4:  BCF    FA4.1
009C6:  MOVLB  0
009C8:  GOTO   009C
.................... #INT_CANIRX 
.................... /* CAN packet error lights up RED led for two seconds */ 
.................... void isr_canirx() { 
.................... 	clear_interrupt(INT_CANIRX); 
*
00000:  BCF    FA4.7
.................... //	timer.led_on_red=2000; 
.................... } 
....................  
.................... #include "param.c" 
00002:  BCF    FA4.7
00004:  GOTO   009C
.................... #inline 
.................... char xor_crc(char oldcrc, char data) { 
.................... 	return oldcrc ^ data; 
*
00EB2:  MOVF   x74,W
00EB4:  XORWF  x75,W
00EB6:  MOVWF  01
*
00F04:  MOVF   x74,W
00F06:  XORWF  x75,W
00F08:  MOVWF  01
.................... } 
....................  
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) { 
*
00E42:  MOVLB  2
00E44:  CLRF   x71
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00E46:  MOVFF  270,03
00E4A:  MOVF   x6F,W
00E4C:  BTFSC  FD8.2
00E4E:  DECF   x70,F
00E50:  DECF   x6F,F
00E52:  MOVWF  x72
00E54:  MOVFF  03,273
00E58:  MOVF   x72,F
00E5A:  BNZ   0E60
00E5C:  MOVF   x73,F
00E5E:  BZ    0EC4
.................... 		*data = read_eeprom( address++ ); 
00E60:  MOVFF  26E,03
00E64:  MOVF   x6D,W
00E66:  MOVWF  FE9
00E68:  MOVFF  03,FEA
00E6C:  MOVF   x6C,W
00E6E:  MOVWF  03
00E70:  MOVF   x6B,W
00E72:  INCF   x6B,F
00E74:  BTFSC  FD8.2
00E76:  INCF   x6C,F
00E78:  MOVWF  x74
00E7A:  MOVFF  03,275
00E7E:  MOVFF  FF2,276
00E82:  BCF    FF2.7
00E84:  MOVFF  275,FAA
00E88:  MOVFF  274,FA9
00E8C:  BCF    FA6.6
00E8E:  BCF    FA6.7
00E90:  BSF    FA6.0
00E92:  MOVF   FA8,W
00E94:  BTFSC  x76.7
00E96:  BSF    FF2.7
00E98:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data); 
00E9A:  MOVFF  26E,03
00E9E:  MOVF   x6D,W
00EA0:  MOVWF  FE9
00EA2:  MOVFF  03,FEA
00EA6:  MOVFF  FEF,272
00EAA:  MOVFF  271,274
00EAE:  MOVFF  272,275
*
00EB8:  MOVFF  01,271
.................... 		data++; 
00EBC:  INCF   x6D,F
00EBE:  BTFSC  FD8.2
00EC0:  INCF   x6E,F
.................... 	} 
00EC2:  BRA    0E46
.................... 	return crc; 
00EC4:  MOVFF  271,01
.................... } 
00EC8:  MOVLB  0
00ECA:  GOTO   101A (RETURN)
....................  
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) { 
00ECE:  MOVLB  2
00ED0:  CLRF   x72
.................... 	char crc=0; 
....................  
.................... 	while ( count-- != 0 ) { 
00ED2:  MOVFF  271,03
00ED6:  MOVF   x70,W
00ED8:  BTFSC  FD8.2
00EDA:  DECF   x71,F
00EDC:  DECF   x70,F
00EDE:  MOVWF  x73
00EE0:  MOVFF  03,274
00EE4:  MOVF   x73,F
00EE6:  BNZ   0EEC
00EE8:  MOVF   x74,F
00EEA:  BZ    0F68
.................... 		/* restart_wdt() */ 
.................... 		crc = xor_crc(crc,*data); 
00EEC:  MOVFF  26F,03
00EF0:  MOVF   x6E,W
00EF2:  MOVWF  FE9
00EF4:  MOVFF  03,FEA
00EF8:  MOVFF  FEF,273
00EFC:  MOVFF  272,274
00F00:  MOVFF  273,275
*
00F0A:  MOVFF  01,272
.................... 		write_eeprom( address++, *data++ ); 
00F0E:  MOVF   x6D,W
00F10:  MOVWF  03
00F12:  MOVF   x6C,W
00F14:  INCF   x6C,F
00F16:  BTFSC  FD8.2
00F18:  INCF   x6D,F
00F1A:  MOVWF  x73
00F1C:  MOVFF  03,274
00F20:  MOVF   x6F,W
00F22:  MOVWF  03
00F24:  MOVF   x6E,W
00F26:  INCF   x6E,F
00F28:  BTFSC  FD8.2
00F2A:  INCF   x6F,F
00F2C:  MOVWF  FE9
00F2E:  MOVFF  03,FEA
00F32:  MOVFF  FEF,275
00F36:  MOVFF  274,FAA
00F3A:  MOVFF  273,FA9
00F3E:  MOVFF  275,FA8
00F42:  BCF    FA6.6
00F44:  BCF    FA6.7
00F46:  BSF    FA6.2
00F48:  MOVF   FF2,W
00F4A:  MOVWF  00
00F4C:  BCF    FF2.7
00F4E:  MOVLB  F
00F50:  MOVLW  55
00F52:  MOVWF  FA7
00F54:  MOVLW  AA
00F56:  MOVWF  FA7
00F58:  BSF    FA6.1
00F5A:  BTFSC  FA6.1
00F5C:  BRA    0F5A
00F5E:  BCF    FA6.2
00F60:  MOVF   00,W
00F62:  IORWF  FF2,F
.................... 	} 
00F64:  MOVLB  2
00F66:  BRA    0ED2
....................  
.................... 	return crc; 
00F68:  MOVFF  272,01
.................... } 
00F6C:  MOVLB  0
00F6E:  GOTO   0F94 (RETURN)
....................  
.................... void write_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	restart_wdt(); 
00F72:  CLRWDT
....................  
.................... 	/* write the config structure */ 
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config)); 
00F74:  MOVLB  2
00F76:  CLRF   x6B
00F78:  MOVLW  20
00F7A:  MOVWF  x6A
00F7C:  CLRF   x6D
00F7E:  MOVLW  01
00F80:  MOVWF  x6C
00F82:  MOVFF  26B,26F
00F86:  MOVFF  26A,26E
00F8A:  CLRF   x71
00F8C:  MOVLW  0B
00F8E:  MOVWF  x70
00F90:  MOVLB  0
00F92:  BRA    0ECE
00F94:  MOVFF  01,269
.................... 	/* write the CRC was calculated on the structure */ 
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc); 
00F98:  CLRF   FAA
00F9A:  CLRF   FA9
00F9C:  MOVFF  269,FA8
00FA0:  BCF    FA6.6
00FA2:  BCF    FA6.7
00FA4:  BSF    FA6.2
00FA6:  MOVF   FF2,W
00FA8:  MOVWF  00
00FAA:  BCF    FF2.7
00FAC:  MOVLB  F
00FAE:  MOVLW  55
00FB0:  MOVWF  FA7
00FB2:  MOVLW  AA
00FB4:  MOVWF  FA7
00FB6:  BSF    FA6.1
00FB8:  BTFSC  FA6.1
00FBA:  BRA    0FB8
00FBC:  BCF    FA6.2
00FBE:  MOVF   00,W
00FC0:  IORWF  FF2,F
....................  
.................... 	restart_wdt(); 
00FC2:  CLRWDT
.................... } 
00FC4:  MOVLB  0
00FC6:  GOTO   0FF8 (RETURN)
....................  
.................... void write_default_param_file() { 
.................... 	/* red LED for 1.5 seconds */ 
.................... 	timer.led_on_red=150; 
00FCA:  MOVLB  1
00FCC:  CLRF   x57
00FCE:  MOVLW  96
00FD0:  MOVWF  x56
.................... //	fprintf(world,"# writing default parameters\r\n"); 
....................  
.................... 	config.revision='a'; 
00FD2:  MOVLW  61
00FD4:  MOVWF  20
....................  
.................... 	config.serial_prefix='A'; //SERIAL_PREFIX_DEFAULT; 
00FD6:  MOVLW  41
00FD8:  MOVWF  22
.................... 	config.serial_number=4745; //SERIAL_NUMBER_DEFAULT; 
00FDA:  MOVLW  12
00FDC:  MOVWF  24
00FDE:  MOVLW  89
00FE0:  MOVWF  23
....................  
....................  
.................... 	config.sensor_source=SENSOR_SOURCE_ONBOARD; 
00FE2:  CLRF   28
....................  
.................... 	config.world_to_xbee=0; 
00FE4:  CLRF   29
.................... 	config.world_to_xport=1; 
00FE6:  MOVLW  01
00FE8:  MOVWF  2A
....................  
.................... 	config.pair_serial_prefix=0; 
00FEA:  CLRF   25
.................... 	config.pair_serial_number=0; 
00FEC:  CLRF   27
00FEE:  CLRF   26
....................  
.................... 	config.modbus_address=29; 
00FF0:  MOVLW  1D
00FF2:  MOVWF  21
....................  
.................... 	/* write them so next time we use from EEPROM */ 
.................... 	write_param_file(); 
00FF4:  MOVLB  0
00FF6:  BRA    0F72
....................  
.................... } 
00FF8:  RETURN 0
....................  
....................  
.................... void read_param_file() { 
.................... 	int8 crc; 
....................  
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config));  
00FFA:  MOVLB  2
00FFC:  CLRF   x6A
00FFE:  MOVLW  20
01000:  MOVWF  x69
01002:  CLRF   x6C
01004:  MOVLW  01
01006:  MOVWF  x6B
01008:  MOVFF  26A,26E
0100C:  MOVFF  269,26D
01010:  CLRF   x70
01012:  MOVLW  0B
01014:  MOVWF  x6F
01016:  MOVLB  0
01018:  BRA    0E42
0101A:  MOVFF  01,268
....................  
.................... //	fprintf(modem,"# read_param_file()\r\n"); 
.................... //	print_param_file(); 
....................  
.................... 		 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) || config.revision<'a' || config.revision>'z' ) { 
0101E:  MOVFF  FF2,269
01022:  BCF    FF2.7
01024:  CLRF   FAA
01026:  CLRF   FA9
01028:  BCF    FA6.6
0102A:  BCF    FA6.7
0102C:  BSF    FA6.0
0102E:  MOVF   FA8,W
01030:  MOVLB  2
01032:  BTFSC  x69.7
01034:  BSF    FF2.7
01036:  SUBWF  x68,W
01038:  BNZ   1046
0103A:  MOVF   20,W
0103C:  SUBLW  60
0103E:  BC    1046
01040:  MOVF   20,W
01042:  SUBLW  7A
01044:  BC    104C
.................... 		write_default_param_file(); 
01046:  MOVLB  0
01048:  RCALL  0FCA
0104A:  MOVLB  2
.................... 	} 
....................  
.................... } 
0104C:  MOVLB  0
0104E:  GOTO   1770 (RETURN)
....................  
....................  
.................... #include "modbus_handler_vcstap.c" 
.................... #define MAX_DATA_REGISTER   100 
....................  
.................... #define MIN_CONFIG_REGISTER 1000 
.................... #define MAX_CONFIG_REGISTER 1011 
....................  
....................  
....................  
.................... int16 map_modbus(int16 addr) { 
.................... 	int16 val; 
.................... 	int8 i; 
....................  
.................... 	/* VCS registers */ 
.................... 	if ( addr >= 3 && addr <= 83 ) { 
.................... 		addr -= 3; 
....................  
.................... 		i=addr % 2; 
.................... 		if ( 1 == i ) 
.................... 			addr -= 1; 
....................  
.................... 		addr = addr >> 1; 
....................  
.................... 		timer.vcs_read_lock=1; 
.................... 		 
....................  
.................... 		return 0; 
.................... 	} 
....................  
.................... 	/* XRW2G data */ 
....................  
.................... 	switch ( addr ) { 
.................... 		 
.................... 		/* data */ 
.................... 		case   0: return 0; /* VCS control register ... always reads as 0 */ 
.................... 		case   1: return timer.vcs_query_age; 
.................... 		case   2: return timer.xrw2g_age; 
....................  
....................  
.................... 		/* configuration */ 
.................... 		case 1000: return config.serial_prefix; 
.................... 		case 1001: return config.serial_number; 
.................... 		case 1002: return 'V'; 
.................... 		case 1003: return 'C'; 
.................... 		case 1004: return 'S'; 
.................... 		case 1005: return  0; 
.................... 		case 1006: return config.modbus_address; 
.................... 		case 1007: return config.sensor_source; 
.................... 		case 1008: return config.pair_serial_prefix; 
.................... 		case 1009: return config.pair_serial_number; 
.................... 		case 1010: return config.world_to_xbee; 
.................... 		case 1011: return config.world_to_xport; 
....................  
.................... 	    
.................... 		/* we should have range checked, and never gotten here */ 
.................... 		default: return 65535; 
.................... 	} 
....................  
.................... } 
....................  
....................  
.................... int8 modbus_valid_read_registers(int16 start, int16 end) { 
.................... 	if ( start <= MAX_DATA_REGISTER && end <= MAX_DATA_REGISTER+1 )  
.................... 		return 1; 
....................  
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
....................  
.................... 	return 0; 
.................... } 
....................  
.................... int8 modbus_valid_write_registers(int16 start, int16 end) { 
.................... 	/* factory unlock */ 
.................... 	if ( 19999==start && 20000==end) 
.................... 		return 1; 
....................  
.................... 	/* write eeprom */ 
.................... 	if ( start >= 1998 && end <= 2000+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	if ( start >= MIN_CONFIG_REGISTER && end <= MAX_CONFIG_REGISTER+1 ) 
.................... 		return 1; 
.................... 	 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_read_register_response(int8 address, int16 start_address, int16 register_count ) { 
.................... 	int16 i; 
.................... 	int16 l; 
....................  
.................... 	modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
.................... 	modbus_serial_putc(register_count*2); 
....................  
....................  
.................... 	for( i=0 ; i<register_count ; i++ ) { 
.................... 		l=map_modbus(start_address+i); 
.................... 		modbus_serial_putc(make8(l,1)); 
....................   		modbus_serial_putc(make8(l,0)); 
.................... 	} 
....................  
.................... 	modbus_serial_send_stop(); 
.................... } 
....................  
.................... /*  
.................... try to write the specified register 
.................... if successful, return 0, otherwise return a modbus exception 
.................... */ 
.................... exception modbus_write_register(int16 address, int16 value) { 
....................  
.................... 	/* if we have been unlocked, then we can modify serial number */ 
.................... 	if ( timer.factory_unlocked ) { 
.................... 		if ( 1000 == address ) { 
.................... 			config.serial_prefix=value; 
.................... 			return 0; 
.................... 		} else if ( 1001 == address ) { 
.................... 			config.serial_number=value; 
.................... 			return 0; 
.................... 		} 
.................... 	} 
....................  
.................... 	/* publicly writeable addresses */ 
.................... 	switch ( address ) { 
.................... 		case 1006: 
.................... 			/* Modbus address {0 to 127} */ 
.................... 			if ( value > 127 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.modbus_address=value; 
.................... 			break; 
....................                 case 1007: 
....................                         if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
....................                         config.sensor_source=value; 
....................                         break; 
....................                 case 1008: 
....................                         if ( value > 255 ) return ILLEGAL_DATA_VALUE; 
....................                         config.pair_serial_prefix=value; 
....................                         break; 
....................                 case 1009: 
....................                         config.pair_serial_number=value; 
....................                         break; 
.................... 		case 1010: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xbee=value; 
.................... 			break; 
.................... 		case 1011: 
.................... 			if ( value > 1 ) return ILLEGAL_DATA_VALUE; 
.................... 			config.world_to_xport=value; 
.................... 			break; 
.................... 		case 1997: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			reset_cpu(); 
.................... 		case 1998: 
.................... 			/* write default config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_default_param_file(); 
.................... 			break; 
.................... 		case 1999: 
.................... 			/* write config to EEPROM */ 
.................... 			if ( 1 != value ) return ILLEGAL_DATA_VALUE; 
.................... 			write_param_file(); 
.................... 			break; 
.................... 		case 19999: 
.................... 			/* unlock factory programming registers when we get 1802 in passcode register */ 
.................... 			if ( 1802 != value ) { 
.................... 				timer.factory_unlocked=0; 
.................... 				return ILLEGAL_DATA_VALUE; 
.................... 			} 
.................... 			timer.factory_unlocked=1; 
.................... 			/* green LED for 2 seconds */ 
.................... 			timer.led_on_green=200; 
.................... 			timer.led_on_red=0; 
.................... 			break; 
.................... 		default: 
.................... 			return ILLEGAL_DATA_ADDRESS; 
....................  
.................... 	} 
....................  
.................... 	/* must not have triggered an exception */ 
.................... 	return 0; 
.................... } 
....................  
.................... void modbus_process(void) { 
.................... 	int16 start_addr; 
.................... 	int16 num_registers; 
.................... 	exception result; 
.................... 	int8 i; 
....................  
....................  
.................... 	/* check for message */ 
.................... 	if ( modbus_kbhit() ) { 
.................... 		/* check if it is addressed to us */ 
.................... 		if ( modbus_rx.address==config.modbus_address ) {	 
.................... 			/* green LED for 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=0; 
....................  
.................... 			switch(modbus_rx.func) { 
.................... 				case FUNC_READ_HOLDING_REGISTERS: /* 3 */ 
.................... 				case FUNC_READ_INPUT_REGISTERS:   /* 4 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
.................... 	 
.................... 					/* make sure our address is within range */ 
.................... 					if ( ! modbus_valid_read_registers(start_addr,start_addr+num_registers) ) { 
.................... 					    modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
.................... 						timer.modbus_last_error=ILLEGAL_DATA_ADDRESS; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					} else { 
.................... 						modbus_read_register_response(config.modbus_address,start_addr,num_registers); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_SINGLE_REGISTER: /* 6 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
....................  
.................... 					/* try the write */ 
.................... 					result=modbus_write_register(start_addr,make16(modbus_rx.data[2],modbus_rx.data[3])); 
....................  
.................... 					if ( result ) { 
.................... 						/* exception */ 
.................... 						modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 						timer.modbus_last_error=result; 
....................  
.................... 						/* red LED for 1 second */ 
.................... 						timer.led_on_red=100; 
.................... 						timer.led_on_green=0; 
.................... 					}  else { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_single_register_rsp(config.modbus_address, 
.................... 							start_addr, 
.................... 							make16(modbus_rx.data[2],modbus_rx.data[3]) 
.................... 						); 
.................... 					} 
.................... 					break; 
.................... 				case FUNC_WRITE_MULTIPLE_REGISTERS: /* 16 */ 
.................... 					start_addr=make16(modbus_rx.data[0],modbus_rx.data[1]); 
.................... 					num_registers=make16(modbus_rx.data[2],modbus_rx.data[3]); 
....................  
.................... 					/* attempt to write each register. Stop if exception */ 
.................... 					for ( i=0 ; i<num_registers ; i++ ) { 
.................... 						result=modbus_write_register(start_addr+i,make16(modbus_rx.data[5+i*2],modbus_rx.data[6+i*2])); 
....................  
.................... 						if ( result ) { 
.................... 							/* exception */ 
.................... 							modbus_exception_rsp(config.modbus_address,modbus_rx.func,result); 
.................... 							timer.modbus_last_error=result; 
.................... 	 
.................... 							/* red LED for 1 second */ 
.................... 							timer.led_on_red=100; 
.................... 							timer.led_on_green=0; 
.................... 			 
.................... 							break; 
.................... 						} 
.................... 					} 
.................... 		 
.................... 					/* we could have gotten here with an exception already send, so only send if no exception */ 
.................... 					if ( 0 == result ) { 
.................... 						/* no exception, send ack */ 
.................... 						modbus_write_multiple_registers_rsp(config.modbus_address,start_addr,num_registers); 
.................... 					} 
....................  
.................... 					break;   
.................... 				default: 
.................... 					/* we don't support most operations, so return ILLEGAL_FUNCTION exception */ 
.................... 					modbus_exception_rsp(config.modbus_address,modbus_rx.func,ILLEGAL_FUNCTION); 
.................... 					timer.modbus_last_error=ILLEGAL_FUNCTION; 
....................  
.................... 					/* red led for 1 second */ 
.................... 					timer.led_on_red=100; 
.................... 					timer.led_on_green=0; 
.................... 			} 
.................... 		} else { 
.................... 			/* MODBUS packet for somebody else */ 
.................... 			/* yellow LED 200 milliseconds */ 
.................... 			timer.led_on_green=20; 
.................... 			timer.led_on_red=20; 
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void init() { 
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
00DCE:  MOVLW  72
00DD0:  MOVWF  FD3
00DD2:  MOVF   FD3,W
.................... 	setup_adc(ADC_OFF); 
00DD4:  BCF    FC2.0
.................... 	/*  
.................... 	setup_adc_ports(NO_ANALOGS); doesn't seem to work.  
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital 
.................... 	*/ 
.................... //	ANCON0=0xff; 
.................... //	ANCON1=0x1f; 
.................... 	 
.................... 	 
.................... //	setup_comparator(NC_NC_NC_NC); 
....................  
.................... 	setup_timer_2(T2_DIV_BY_16,61,2); // set 1 millisecond period with 8 MHz oscillator 
00DD6:  MOVLW  08
00DD8:  IORLW  06
00DDA:  MOVWF  FCA
00DDC:  MOVLW  3D
00DDE:  MOVWF  FCB
....................  
.................... 	port_b_pullups(TRUE); 
00DE0:  BCF    FF1.7
.................... 	delay_ms(10); 
00DE2:  MOVLW  0A
00DE4:  MOVLB  2
00DE6:  MOVWF  x68
00DE8:  MOVLB  0
00DEA:  RCALL  0A00
.................... 	 
.................... 	output_low(SYNC_OUT); 
00DEC:  BCF    F94.5
00DEE:  BCF    F8B.5
....................  
....................  
.................... 	timer.modbus_enable=FALSE; 
00DF0:  CLRF   2B
....................  
....................  
.................... 	/* xrw2g uart */ 
.................... 	uart_init(); 
00DF2:  BRA    0ADC
....................  
.................... 	/* CAN interface to VCS */ 
.................... 	can_init(); 
00DF4:  BRA    0CC0
.................... 	/* set receive filter so we only get data from CAN ID 3*/ 
.................... //	can_set_mode(CAN_OP_CONFIG);  
.................... //	can_set_id(RX0MASK,0x003,false); ??? 
.................... //	can_set_mode(CAN_OP_NORMAL);  
....................    // mask bit n | filter bit n | message ID bit n | result 
....................    //     0             x               x             accept 
....................    //     1             0               0             accept 
....................    //     1             0               1             reject 
....................    //     1             1               0             reject 
....................    //     1             1               1             accept 
.................... 	/* receive and receiver error interrupts */ 
.................... 	enable_interrupts(INT_CANRX0);  
00DF6:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANRX1);  
00DF8:  BSF    FA3.1
.................... 	enable_interrupts(INT_CANIRX); 
00DFA:  BSF    FA3.7
....................  
....................  
....................  
.................... 	/* global structures */ 
.................... 	timer.factory_unlocked=0; 
00DFC:  CLRF   2D
.................... 	timer.telem_age=0; 
00DFE:  CLRF   2F
00E00:  CLRF   2E
....................  
.................... 	timer.xrw2g_age=65535; 
00E02:  SETF   xB2
00E04:  SETF   xB1
.................... 	timer.xrw2g_buff_pos=0; 
00E06:  CLRF   xB0
.................... 	memset(timer.xrw2g_packet, 0, sizeof(timer.xrw2g_packet)); 
00E08:  CLRF   FEA
00E0A:  MOVLW  30
00E0C:  MOVWF  FE9
00E0E:  CLRF   00
00E10:  CLRF   02
00E12:  MOVLW  80
00E14:  MOVWF  01
00E16:  RCALL  0DB4
....................  
.................... 	timer.vcs_read_lock=0; 
00E18:  MOVLB  1
00E1A:  CLRF   x55
.................... 	timer.vcs_query_age=0; 
00E1C:  CLRF   x54
00E1E:  CLRF   x53
.................... 	memset(timer.vcs_register, 0, sizeof(timer.vcs_register)); 
00E20:  CLRF   FEA
00E22:  MOVLW  B3
00E24:  MOVWF  FE9
00E26:  CLRF   00
00E28:  CLRF   02
00E2A:  MOVLW  A0
00E2C:  MOVWF  01
00E2E:  MOVLB  0
00E30:  RCALL  0DB4
....................  
.................... 	timer.dump_register=255;  
00E32:  MOVLB  1
00E34:  SETF   x5A
.................... 	timer.now_telem=0; 
00E36:  CLRF   x5B
....................  
.................... 	/* receive data from serial ports */ 
.................... 	enable_interrupts(INT_RDA);  /* inverter */ 
00E38:  BSF    F9D.5
.................... //	enable_interrupts(INT_RDA2); /* world (ethernet or xbee */ 
....................  
.................... 	/* timer0 is used for modbus handler */ 
....................  
.................... 	/* 1 millisecond timer */ 
.................... 	enable_interrupts(INT_TIMER2); 
00E3A:  BSF    F9D.1
....................  
....................  
.................... } 
00E3C:  MOVLB  0
00E3E:  GOTO   176E (RETURN)
....................  
.................... #define interrupt_enabled(x)  !!(*(make8(x,1) | 0xF00) & make8(x,0))  
....................  
.................... void read_data_xrw2g(void) { 
.................... 	int8 c; 
....................  
.................... 	if ( uart_kbhit() ) { 
*
0123C:  RCALL  122A
0123E:  MOVF   01,F
01240:  BZ    1274
.................... 		while ( uart_kbhit() ) { 
01242:  RCALL  122A
01244:  MOVF   01,F
01246:  BZ    1274
.................... //			output_high(TP_ORANGE); 
.................... 			c=uart_getc(); 
*
01252:  MOVFF  01,268
.................... //			output_low(TP_ORANGE); 
.................... 			timer.xrw2g_age=0; 
01256:  CLRF   xB2
01258:  CLRF   xB1
....................  
.................... 			if ( timer.xrw2g_buff_pos < sizeof(timer.xrw2g_packet) ) { 
0125A:  MOVF   xB0,W
0125C:  SUBLW  7F
0125E:  BNC   1272
.................... 				timer.xrw2g_packet[timer.xrw2g_buff_pos++]=c; 
01260:  MOVF   xB0,W
01262:  INCF   xB0,F
01264:  ADDLW  30
01266:  MOVWF  FE9
01268:  CLRF   FEA
0126A:  BTFSC  FD8.0
0126C:  INCF   FEA,F
0126E:  MOVFF  268,FEF
.................... 			} 
.................... 		} 
01272:  BRA    1242
.................... 	} 
.................... } 
01274:  GOTO   1816 (RETURN)
....................  
....................  
.................... void send_can_query(int8 queryRegister) { 
.................... 	unsigned int32 can_id; 
.................... 	unsigned int8 data[4]; 
....................  
.................... 	/* message ID 3 is query */ 
.................... 	can_id=(int32) 3; 
*
0134A:  MOVLB  2
0134C:  CLRF   x6D
0134E:  CLRF   x6C
01350:  CLRF   x6B
01352:  MOVLW  03
01354:  MOVWF  x6A
....................  
.................... 	data[0]=queryRegister; 
01356:  MOVFF  269,26E
.................... 	data[1]=0x00; 
0135A:  CLRF   x6F
.................... 	data[2]=0x00; 
0135C:  CLRF   x70
.................... 	data[3]=0x00;  
0135E:  CLRF   x71
....................  
.................... 	if ( 0 == can_putd(can_id,data,4,0,FALSE,FALSE) ) { 
01360:  MOVFF  26D,275
01364:  MOVFF  26C,274
01368:  MOVFF  26B,273
0136C:  MOVFF  26A,272
01370:  MOVLW  02
01372:  MOVWF  x77
01374:  MOVLW  6E
01376:  MOVWF  x76
01378:  MOVLW  04
0137A:  MOVWF  x78
0137C:  CLRF   x79
0137E:  CLRF   x7A
01380:  CLRF   x7B
01382:  MOVLB  0
01384:  BRA    1278
01386:  MOVF   01,F
01388:  BNZ   138A
.................... //		timer.led_on_red=50; 
.................... 	} 
....................  
.................... } 
0138A:  GOTO   184C (RETURN)
....................  
....................  
.................... /* this is started after the bootloader is done loading or times out */ 
.................... void main(void) { 
*
01732:  CLRF   FF8
01734:  BCF    FD0.7
01736:  BSF    07.7
01738:  CLRF   FEA
0173A:  CLRF   FE9
0173C:  CLRF   1F
0173E:  BCF    FB8.3
01740:  MOVLW  0C
01742:  MOVWF  FAF
01744:  MOVLW  A2
01746:  MOVWF  FAC
01748:  MOVLW  90
0174A:  MOVWF  FAB
0174C:  MOVLB  1
0174E:  CLRF   x5D
01750:  CLRF   x5C
01752:  BCF    x5E.0
01754:  CLRF   x5F
01756:  MOVLB  2
01758:  CLRF   x66
0175A:  CLRF   x65
0175C:  MOVF   FC1,W
0175E:  ANDLW  C0
01760:  IORLW  0F
01762:  MOVWF  FC1
01764:  CLRF   19
01766:  CLRF   1A
.................... 	int8 last; 
....................  
.................... 	/* normal device startup */ 
.................... 	init(); 
01768:  MOVLB  0
0176A:  GOTO   0DCE
.................... 	read_param_file(); 
0176E:  BRA    0FFA
.................... 	 
.................... 	write_default_param_file(); 
01770:  RCALL  0FCA
....................  
.................... 	/* modbus_init turns on global interrupts */ 
.................... //	modbus_init(); 
....................  
.................... 	enable_interrupts(GLOBAL); 
01772:  MOVLW  C0
01774:  IORWF  FF2,F
....................  
.................... 	fprintf(rs232,"# (world) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
01776:  MOVLW  CC
01778:  MOVWF  FF6
0177A:  MOVLW  09
0177C:  MOVWF  FF7
0177E:  MOVLW  13
01780:  MOVLB  2
01782:  MOVWF  x68
01784:  MOVLB  0
01786:  RCALL  1052
01788:  MOVLW  F6
0178A:  MOVWF  FF6
0178C:  MOVLW  09
0178E:  MOVWF  FF7
01790:  BRA    107C
01792:  MOVLW  E1
01794:  MOVWF  FF6
01796:  MOVLW  09
01798:  MOVWF  FF7
0179A:  MOVLW  0D
0179C:  MOVLB  2
0179E:  MOVWF  x68
017A0:  MOVLB  0
017A2:  RCALL  1052
017A4:  MOVF   22,W
017A6:  BTFSS  F9E.4
017A8:  BRA    17A6
017AA:  MOVWF  FAD
017AC:  MOVLW  10
017AE:  MOVWF  FE9
017B0:  MOVFF  24,269
017B4:  MOVFF  23,268
017B8:  BRA    10A0
017BA:  MOVLW  0D
017BC:  BTFSS  F9E.4
017BE:  BRA    17BC
017C0:  MOVWF  FAD
017C2:  MOVLW  0A
017C4:  BTFSS  F9E.4
017C6:  BRA    17C4
017C8:  MOVWF  FAD
.................... //	fprintf(rs232,"# (rs232) vcstap.c %s - my serial %c%lu\r\n",__DATE__,config.serial_prefix,config.serial_number); 
....................  
.................... 	/* fast red, yellow, green */ 
.................... 	timer.led_on_red  =200; 
017CA:  MOVLB  1
017CC:  CLRF   x57
017CE:  MOVLW  C8
017D0:  MOVWF  x56
.................... 	delay_ms(160); 
017D2:  MOVLW  A0
017D4:  MOVLB  2
017D6:  MOVWF  x68
017D8:  MOVLB  0
017DA:  CALL   0A00
.................... 	timer.led_on_green=400; 
017DE:  MOVLW  01
017E0:  MOVLB  1
017E2:  MOVWF  x59
017E4:  MOVLW  90
017E6:  MOVWF  x58
.................... 	delay_ms(160); 
017E8:  MOVLW  A0
017EA:  MOVLB  2
017EC:  MOVWF  x68
017EE:  MOVLB  0
017F0:  CALL   0A00
.................... 	timer.led_on_red=0; 
017F4:  MOVLB  1
017F6:  CLRF   x57
017F8:  CLRF   x56
.................... 	delay_ms(160); 
017FA:  MOVLW  A0
017FC:  MOVLB  2
017FE:  MOVWF  x68
01800:  MOVLB  0
01802:  CALL   0A00
.................... 	timer.led_on_green=0; 
01806:  MOVLB  1
01808:  CLRF   x59
0180A:  CLRF   x58
....................  
....................  
.................... 	last=0; 
0180C:  MOVLB  2
0180E:  CLRF   x67
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
01810:  CLRWDT
....................  
.................... 		/* read data from our different sources */ 
.................... 		read_data_xrw2g(); 
01812:  MOVLB  0
01814:  BRA    123C
.................... 		 
.................... 		/* transmit buffer empty */ 
.................... 		if ( can_tbe() && timer.vcs_query_age>=25 ) { 
01816:  MOVLB  F
01818:  BTFSS  x40.3
0181A:  BRA    1824
0181C:  BTFSS  x30.3
0181E:  BRA    1824
01820:  BTFSC  x20.3
01822:  BRA    1852
01824:  MOVLB  1
01826:  MOVF   x54,F
01828:  BNZ   1836
0182A:  MOVF   x53,W
0182C:  SUBLW  18
0182E:  BTFSS  FD8.0
01830:  BRA    1836
01832:  MOVLB  F
01834:  BRA    1852
.................... 			/* loop through our list of registers */ 
.................... 			if ( last == VCS_N_REGISTERS ) 
01836:  MOVLB  2
01838:  MOVF   x67,W
0183A:  SUBLW  28
0183C:  BNZ   1840
.................... 				last=0; 
0183E:  CLRF   x67
....................  
.................... 			send_can_query(last++); 
01840:  MOVF   x67,W
01842:  INCF   x67,F
01844:  MOVWF  x68
01846:  MOVWF  x69
01848:  MOVLB  0
0184A:  BRA    134A
.................... //			send_can_query(10); 
.................... 			timer.vcs_query_age=0; 
0184C:  MOVLB  1
0184E:  CLRF   x54
01850:  CLRF   x53
.................... 		} 
....................  
....................  
.................... #if 0 
.................... 		if ( timer.dump_register != 255 ) { 
.................... 			/* takes about 4 milliseconds */ 
.................... 			disable_interrupts(INT_CANRX0); 
.................... 			disable_interrupts(INT_CANRX1); 
....................  
.................... 			fprintf(rs232,"# [%u] {%02x %02x %02x %02x}\r\n", 
.................... 				timer.dump_register, 
.................... 				timer.vcs_register[timer.dump_register<<2 + 0], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 1], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 2], 
.................... 				timer.vcs_register[timer.dump_register<<2 + 3] 
.................... 			); 
.................... //			fputc('*',rs232); 
....................  
.................... 			timer.dump_register=255; 
....................  
.................... 			enable_interrupts(INT_CANRX0); 
.................... 			enable_interrupts(INT_CANRX1); 
.................... 		} 
.................... #endif 
....................  
....................  
....................  
.................... //		modbus_process(); 
....................  
.................... 	    /* 
.................... 	     * every 10 seconds we send a sync pulse which should trigger another packet from XRW2G 
.................... 	     * if we have wirless sensors, then this doesn't matter 
.................... 	     */ 
.................... 	    if ( timer.now_telem ) { 
01852:  MOVLB  1
01854:  MOVF   x5B,F
01856:  BZ    1862
.................... 			timer.now_telem=0; 
01858:  CLRF   x5B
.................... //			output_high(SYNC_OUT); 
.................... 			live_send_vcs(); 
0185A:  MOVLB  0
0185C:  BRA    13FC
.................... //			output_high(TP_ORANGE); 
.................... 	    } else { 
0185E:  BRA    1868
01860:  MOVLB  1
.................... 			output_low(SYNC_OUT); 
01862:  BCF    F94.5
01864:  BCF    F8B.5
01866:  MOVLB  0
.................... //			output_low(TP_ORANGE); 
.................... 	    } 
....................  
....................  
.................... 		/* we have XRW2G data, and we haven't gotten any more in last 50 miliseconds */ 
.................... 		if ( 0 != timer.xrw2g_buff_pos && timer.xrw2g_age > 50 ) { 
01868:  MOVF   xB0,F
0186A:  BZ    1878
0186C:  MOVF   xB2,F
0186E:  BNZ   1876
01870:  MOVF   xB1,W
01872:  SUBLW  32
01874:  BC    1878
.................... #if 1 
.................... 			live_send_xrw2g(); 
01876:  BRA    15DA
.................... #else 
.................... 			fprintf(rs232,"# XRW2G %c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			if ( 0 == live_send_xrw2g() ) { 
.................... 				fprintf(rs232,"error-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} else { 
.................... 				fprintf(rs232,"success-%c%lu ",timer.xrw2g_packet[1],make16(timer.xrw2g_packet[2],timer.xrw2g_packet[3])); 
.................... 			} 
.................... 			timer.telem_age=0; 
.................... #endif 
.................... 		} 
....................  
.................... #if 0 
.................... 		 /* we haven't sent live data for 32 seconds */ 
.................... 		if (  timer.telem_age > 32000 ) { 
.................... 			live_send(1); 
.................... 			timer.telem_age=0; 
.................... 		} 
....................  
.................... 	 
....................  
.................... 		if ( ! timer.modbus_enable ) { 
.................... 			/* 	 
.................... 				Status LEDs:  
.................... 					Solid red if no VCS data 
.................... 					Flash of red on bad packets from inverter (in packet parse routine) 
.................... 					Solid green if XRW2G in last 12 seconds 
.................... 			*/ 
.................... //			if ( timer.inverter_conditions_age > 1025 ) { 
.................... //				timer.led_on_red=2000; 
.................... //			}  
.................... 	 
.................... 			if (timer.xrw2g_age < 12000 ) { 
.................... 				timer.led_on_green=2000; 
.................... 			} 
.................... 		} 
....................  
.................... 		/* full time RED LED if default serial number */ 
.................... //		if ( config.serial_prefix == SERIAL_PREFIX_DEFAULT && config.serial_number == SERIAL_NUMBER_DEFAULT ) { 
.................... //			timer.led_on_red=200; 
.................... //		} 
.................... #endif 
.................... 	} 
01878:  MOVLB  2
0187A:  BRA    1810
.................... } 
....................  
0187C:  BRA    187C

Configuration Fuses:
   Word  1: 4F00   FCMEN NOIESO
   Word  2: 1A19   NOPUT NOBROWNOUT BORV21 NOWDT WDT8192
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0030   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
